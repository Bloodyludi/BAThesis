#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\captionsetup[table]{skip=10pt}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
\usepackage{lmodern}
\usepackage[scaled=0.92]{helvet}
\usepackage{mathptmx}
\usepackage{courier}

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{roman}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
\addto\captionsngerman{ 
\renewcommand{\figurename}{Abb.}% 
\renewcommand{\tablename}{Tab.}% 
\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}

%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
\usepackage{color}
\usepackage{listings}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
%xleftmargin = 15pt,
%frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\footnotesize,
backgroundcolor = \color{background},
tabsize=4,
}
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
todonotes
\end_modules
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 92
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Inversion of Control in Unity3D"
\pdf_author "Ludwig Lauer"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/hs-harz-logo.eps
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size larger
Bachelorarbeit
\end_layout

\begin_layout Standard
\noindent
\align left

\size large
Inversion Of Control in Unity3D
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eingereicht von:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrikelnummer: m18711
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fachbereich Automatisierung und Informatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Studiengang Medieninformatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erstprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Daniel Ackermann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zweitprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Ph.
 D.
 Jürgen K.
 Singer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Eidesstattliche Erklärung
\end_layout

\begin_layout Standard
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst
 und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.
 Alle Ausführungen, die anderen veröffentlichten oder nicht veröffentlichten
 Schriften wörtlich oder sinngemäß entnommen wurden, habe ich kenntlich
 gemacht.
\end_layout

\begin_layout Standard
Die Arbeit hat in gleicher oder ähnlicher Fassung noch keiner anderen Prüfungsbe
hörde vorgelegen.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Sperrvermerk
\end_layout

\begin_layout Standard
Die vorliegende Bachelorarbeit enthält vertrauliche Informationen der Firma
 Wooga GmbH, die der Geheimhaltung unterliegen.
 Veröffentlichungen oder Vervielfältigungen der Bachelorarbeit - auch nur
 auszugsweise - sind ohne ausdrückliche Genehmigung der Firma Wooga GmbH
 nicht gestattet.
 Die Bachelorarbeit ist nur den Mitarbeitern des betreuenden Lehrstuhls
 sowie den Mitgliedern des Prüfungsausschusses zugänglich zu machen.
 Alle Rechte zum Erwerb und zur Anmeldung gewerblicher Schutzrechte, insbesonder
e zur Anmeldung von Patenten, Gebrauchsmustern und/oder Geschmacksmustern
 sind der Firma Wooga GmbH vorbehalten.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Exposé
\end_layout

\begin_layout Standard
Unity3D hat sich in den letzten Jahren als Spieleengine etabliert.
 Immer größere und ambitioniertere Projekte werden mit der Engine umgesetzt.
 Da Unity als Rapid Prototyping Tool für unabhängige Spieleentwickler konzipiert
 wurde, fällt die parallele Entwicklung in mittleren bis großen Teams schwer.
 Eine der Ursachen dieses Problems ist die enge Kopplung von Abhängigkeiten
 zwischen Objekten.
 Die Folgen sind Starrheit und Zerbrechlichkeit bei Veränderung des Programmcode
s.
\end_layout

\begin_layout Standard
In der objektorientierten Programmierung gilt Inversion Of Control als Maßnahme
 um lose Kopplung zu erzielen.
 In dieser Arbeit soll untersucht werden, ob sich das Paradigma auch in
 der komponentenbasierten Architektur von Unity3D anwenden lässt.
 Dafür soll das Framework StrangeIoC herangezogen und genauer betrachtet
 werden.
 Mit Features wie Automated Dependency Injection, eigenem Eventsystem und
 einer MVC(S) Architektur sollen die Qualität, Testbarkeit, Skalierbarkeit
 und Wartbarkeit der Anwendung erhöht werden.
\end_layout

\begin_layout Standard
Ziel der Bachelorarbeit ist folglich das Erstellen einer lose gekoppelten
 Beispielanwendung in Unity3D unter Verwendung von StrangeIoC.
 Zudem soll untersucht werden, welche Praktiken die Ursache von enger Kopplung
 in Unity3D sind, welche Folgen diese haben und wie diese mit Inversion
 Of Control, Dependency Injection und StrangeIoC im speziellen, vermeidbar
 sind.
\end_layout

\begin_layout Standard
Die Bachelorarbeit beinhaltet folgende Teilaufgaben:
\end_layout

\begin_layout Itemize
Analyse von Ursachen und Folgen enger Kopplung zwischen Objekten in Unity3D
\end_layout

\begin_layout Itemize
Auseinandersetzung mit den Paradigmen Inversion Of Control und Dependency
 Injection
\end_layout

\begin_layout Itemize
Entwicklung einer Beispielanwendung mit StrangeIoC mit dem Ziel lose Kopplung
 unter Objekten umzusetzen
\end_layout

\begin_layout Itemize
Kritische Betrachtung von Entwicklungsaufwand, Qualität, Testbarkeit, Skalierbar
keit und Wartbarkeit im Vergleich mit anderen Architekturansätzen 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ACHTUNG: Hier am Ende noch die richtige Seite einstellen! Sonst passt die
 Nummerierung nicht!
\end_layout

\begin_layout Plain Layout
!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Unity hat sich in den letzten Jahren zu einer der bedeutendsten Spieleengines
 entwickelt.
 Mit über 45
\begin_inset space ~
\end_inset

% des globalen Marktanteils unter Spieleengines
\begin_inset Foot
status open

\begin_layout Plain Layout
http://unity3d.com/public-relations
\end_layout

\end_inset

 trägt Unity maßgeblich zu dem Independent Videogame Boom der letzten Jahre
 bei.
 Unity ermöglicht die plattformunabhängige Erstellung von 2D- und 3D-Spielen.
 Dies hat besonders auf dem fragmentierten Markt der mobilen Spieleindustrie
 Anklang gefunden.
 Mit sich fortlaufend verbessernder Performance und Rendertechniken sind
 fortlaufend ambitioniertere Projekte möglich.
 Dies bewegt nicht nur Indieentwickler und kleine Teams dazu, sich die Vorteile
 der Engine zunutze zu machen: Unity findet immer mehr Einzug in professionelle
 Spieleprojekte mit mittleren und großen Teams.
 Hier sind Tätigkeitsbereiche spezialisiert und klar definiert.
 Die Anforderungen an die Spieleengine beginnen sich zu wandeln: Parallele
 Entwicklung muss gewährleistet werden.
 Der Programmcode muss modular, skalierbar und wiederverwendbar sein.
 Es darf keinen Raum für Fehlkonfigurationen geben.
 Neue Geschäftsmodelle wie Free-to-Play bewirken, dass Spiele immer mehr
 zur Dienstleistung werden.
 Sie müssen über mehrere Jahre hinweg wartbar und erweiterbar bleiben.
\end_layout

\begin_layout Standard
Schaut man sich auf den zahlreichen Websites, Blogs und Foren über Unity
 um, scheinen diese Anforderungen Unitys Schwachstelle zu sein: Frustration
 und Beschwerden über entstehenden 
\begin_inset Quotes gld
\end_inset

Spaghetti
\begin_inset Quotes grd
\end_inset

-Code
\begin_inset Foot
status open

\begin_layout Plain Layout
https://np.reddit.com/r/gamedev/comments/3hr8al/coming_from_a_net_programming_back
ground_unitys/
\end_layout

\end_inset

, Kritik an der komponentenbasierten Architektur
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.unityninjas.com/code-architecture/unity3d-game-code-architecture/
\end_layout

\end_inset

, fehlende Testbarkeit
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.mikecann.co.uk/games/taming-unity/
\end_layout

\end_inset

 und Aussagen, dass Unity nur als Rapid Prototyping Tool tauglich ist und
 Kollaboration in großen Teams kaum möglich ist.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.namekdev.net/2014/06/why-i-hate-unity3d-popularity/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oft sollen die Ursachen gerade die Dinge sein, die unerfahrenen Programmierern
 den einfachen Einstieg in Unity ermöglichen.
 Eine Ursache ist so gut wie immer vertreten: die Auflösung von Abhängigkeiten
 und die Kommunikation zwischen Objekten.
 Enge Kopplung von Abhängigkeiten zwischen Objekten führt zu Starrheit und
 Zerbrechlichkeit bei Veränderung des Programmcodes.
 In der objektorientierten Programmierung ist dieses Problem seit Langem
 bekannt.
 Es existieren zahlreiche Lösungen für die unterschiedlichsten Situationen
 und Entwicklungsumgebungen.
 Oft sind diese Lösungen Frameworks, die eng mit den Begriffen Inversion
 Of Control und Dependency Injection in Verbindung stehen.
\end_layout

\begin_layout Standard
Nun implementiert Unity keine klassische objektorientierte Hierarchie, sondern
 eine komponentenbasierte Architektur.
 Trotzdem haben auch für Unity eine Handvoll Inversion Of Control Frameworks
 das Licht der Welt erblickt.
 
\end_layout

\begin_layout Section
Zielsetzung
\end_layout

\begin_layout Standard
In dieser Arbeit wird sich auf ein Problem beschränkt: die Kopplung von
 Abhängigkeiten zwischen Entitäten in Unity.
 Ziel dieser Arbeit ist es die Umsetzung von Spielen in Unity zu ermöglichen,
 ohne dessen Entitäten eng miteinander zu koppeln.
\end_layout

\begin_layout Standard
Zunächst soll die Problematik der Kopplung beschrieben werden.
 Voraussetzung dafür ist, zu erläutern, was Abhängigkeiten sind und warum
 diese entstehen.
 Weiter sollen die Folgen von enger Kopplung erläutert werden.
 Dem Leser soll verdeutlicht werden, dass Kopplung direkten Einfluss auf
 die Testbarkeit und Erweiterbarkeit des Programmcodes hat.
 
\end_layout

\begin_layout Standard
Nachfolgend soll anhand eines Beispiels erklärt werden, wie lose Kopplung
 mittels Dependency Injection umzusetzen ist.
 In diesem Zusammenhang sollen auch zugrunde liegende Prinzipien erläutert
 werden.
\end_layout

\begin_layout Standard
Infolgedessen soll der Schritt zu Unity getätigt werden.
 Es soll untersucht werden, inwiefern Unity von einer herkömmlichen objektorient
ierten Hierarchie abweicht und ob dies hinderlich dabei ist, lose Kopplung
 umzusetzen.
 Es sollen häufig verwendete Praktiken wie das Singletonpattern und Managerobjek
te untersucht werden.
 Wie im Verlauf der Arbeit im Detail erklärt wird, entstehen Abhängigkeiten
 unter anderem dadurch, dass Objekte miteinander kommunizieren müssen.
 Unity stellt unterschiedliche Wege der Kommunikation bereit.
 Es soll nachgeprüft werden, ob diese Wege es bereits ermöglichen lose Kopplung
 umzusetzen.
 Auf Basis dieser Erkenntnisse soll ein Zwischenfazit gezogen werden, um
 die Notwendigkeit eines Inversion Of Control Frameworks für Unity zu verdeutlic
hen.
\end_layout

\begin_layout Standard
Im nächsten Teil dieser Arbeit soll ein Inversion Of Control Container für
 Unity implementiert werden.
 Dieser Container soll Dependency Injection in MonoBehaviours automatisieren
 und somit die lose Kopplung unter MonoBehaviours ermöglichen.
 Die technische Umsetzung soll erläutert werden.
 Die mit Unity in Verbindung stehenden Hürden bei der Umsetzung sollen überwunde
n und beschrieben werden.
 Im Anschluss soll ein Überblick über die vorhandenen Inversion Of Control
 Frameworks für Unity geliefert werden.
 Besonderheiten, Funktionsweise und -Umfang sollen beschrieben werden.
 Besondere Betrachtung soll StrangeIoC finden: Die frameworkeigene MVC(S)-Archit
ektur und die damit verbundenen Muster und Praktiken sollen anhand von Beispiele
n beschrieben werden.
\end_layout

\begin_layout Standard
Auf Basis dieser Analysen soll eine Aussage über die Tauglichkeit von Inversion
 Of Control Frameworks in der komponentenbasierten Architektur Unitys getroffen
 werden.
 Im Speziellen soll ein Fazit über die MVC(S)-Architektur von StrangeIoC
 zur Entwicklung von Spielen in Unity gezogen werden.
 Es soll entschieden werden, für welche Anwendungsgebiete die Architektur
 besonders geeignet ist und für welche nicht.
 Für diese Anwendungsgebiete sollen alternative Architekturansätze in Aussicht
 gestellt werden.
 
\end_layout

\begin_layout Section
Aufbau der Arbeit
\end_layout

\begin_layout Standard
Brauche ich das hier?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Stichpunkte ausformulieren!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Teil 1
\end_layout

\begin_layout Itemize
Grundlagen: Abhängigkeiten, Kopplung, Kohäsion, Dependency Injection, SOLID
\end_layout

\begin_layout Itemize
Beispielhafte Umsetzung DI
\end_layout

\begin_layout Itemize
Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
Teil 2
\end_layout

\begin_layout Itemize
Analyse von Unity
\end_layout

\begin_layout Itemize
Architektur und Kommunikationsmittel
\end_layout

\begin_layout Itemize
Wertung: Notwendigkeit von DI
\end_layout

\begin_layout Standard
Teil 3
\end_layout

\begin_layout Itemize
Implementation Inversion Of Control Container für Unity
\end_layout

\begin_layout Itemize
Existierende Inversion Of Control Frameworks in Unity
\end_layout

\begin_layout Itemize
MVC(S) in StrangeIoC
\end_layout

\begin_layout Standard
Teil 5 
\end_layout

\begin_layout Itemize
Kritische Betrachtung DI
\end_layout

\begin_layout Itemize
Anwendungsgebiete MVC(S) von StrangeIoC
\end_layout

\begin_layout Itemize
Alternative Architekturansätze
\end_layout

\begin_layout Itemize
Fazit
\end_layout

\begin_layout Chapter
Grundlagen
\end_layout

\begin_layout Standard
Geringe Kopplung unter Softwareentitäten (Modulen, Klassen, Methoden) wird
 als Indiz für gute Softwarearchitektur angesehen.
 Inversion Of Control und genauer Dependency Injection sind Werkzeuge, die
 dabei helfen sollen, lose Kopplung umzusetzen.
 In diesem Teil der Arbeit soll zunächst erläutert werden, was Kopplung
 zwischen Entitäten ist und wie diese zustande kommt.
 Es wird verdeutlicht, warum hohe Kohäsion unter minimaler Kopplung anzustreben
 ist.
 Die Vorteile loser Kopplung sollen deutlich gemacht werden.
 Inversion Of Control, Dependency Injection und die eng mit diesen Begriffen
 zusammenhängenden SOLID-Prinzipien sollen beschrieben werden.
 Zum besseren Verständnis der vorgestellten Prinzipien, Muster und Praktiken
 wird lose Kopplung anhand eines Beispiels in einer Konsolenanwendung umgesetzt.
\end_layout

\begin_layout Section
Kopplung und Kohäsion
\end_layout

\begin_layout Standard
Kopplung ist ein Maß, das die Anzahl und Stärke von Abhängigkeiten unter
 Softwareentitäten einer Anwendung beschreibt (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 2-3"
key "Society2014"

\end_inset

).
 Ist eine Softwareentität direkt von der Implementation einer anderen Entität
 abhängig, so sind diese eng miteinander gekoppelt.
 Ziel ist es, die Anzahl und Stärke von Abhängigkeiten zu minimieren und
 so lose Kopplung umzusetzen.
 Martin Fowler beschreibt in dem Artikel 
\begin_inset Quotes gld
\end_inset

Reducing Coupling
\begin_inset Quotes grd
\end_inset

 Kopplung wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

If changing one module in a program requires changing another module, then
 coupling exists.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Fowler2001"

\end_inset

 
\end_layout

\begin_layout Standard
Eine Abhängigkeit zwischen Entitäten entsteht, sobald eine Entität von der
 anderen wissen muss, um zu funktionieren.
 Abhängigkeiten können unterschiedliche Stärken und Ausprägungen haben.
 Je größer das Wissen über eine andere Entität ist, desto stärker ist die
 Abhängigkeit zu ihr.
 Muss also eine Entität von der konkreten Implementation einer anderen Entität
 wissen, so existiert eine starke Abhängigkeit und folglich eine enge Kopplung.
 Wird sich hingegen auf eine Schnittstelle zur Kommunikation geeinigt, existiert
 lediglich eine Abhängigkeit zu eben dieser Schnittstelle.
 Die Entitäten selbst sind lose miteinander gekoppelt.
 Die tatsächliche Implementation einer Entität wird erst zur Laufzeit durch
 späte Bindung bekannt.
 
\end_layout

\begin_layout Standard
Kopplung steht im Kontrast zu dem Begriff der Kohäsion.
 Kohäsion beschreibt ein Maß für den inneren Zusammenhalt einer Softwareentität.
 Hohe Kohäsion liegt dann vor, wenn eine Entität nur Funktionalitäten aufweist,
 die einer einzelnen, wohldefinierten Aufgabe dienen.
 Mit anderen Worten: Eine Entität weist eine hohe Kohäsion auf, wenn ihre
 Elemente in einem engen Zusammenhang stehen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo {Quelle fuer Kohasion}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kohäsion beschreibt wie gut Entitäten aufgeteilt wurden.
 Kopplung beschreibt wie gut die Verbindungen zwischen Entitäten sind.
 Ein qualitativ hochwertiges Softwaredesign weist demzufolge hohe Kohäsion
 unter minimaler Kopplung auf.
 Im nächsten Abschnitt soll Inversion Of Control als Maßnahme präsentiert
 werden, um Kopplung zu minimieren.
\end_layout

\begin_layout Section
Inversion of Control
\begin_inset CommandInset label
LatexCommand label
name "sec:Inversion-of-Control"

\end_inset


\end_layout

\begin_layout Standard
Im ursprünglichen Sinne beschreibt Inversion Of Control nach 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "Johnson1988"

\end_inset

 lediglich die Charakteristik eines Frameworks: 
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

[...] methods defined by the user to tailor the framework will often be called
 from within the framework itself, rather than from the user's application
 code.
 The framework often plays the role of the main program in coordinating
 and sequencing application activity.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnson1988"

\end_inset

 
\end_layout

\begin_layout Standard
Frameworks diktieren die Architektur und den Kontrollfluss einer Anwendung.
 Sie definieren einen wiederverwendbaren Teil eines Softwaredesigns.
 Der vom Nutzer des Frameworks geschriebene, anwendungsspezifische Code
 wird vom Framework aufgerufen (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 27"
key "Gamma1994"

\end_inset

).
 Der Nutzer gibt also die Kontrolle über den Anwendungsfluss an das Framework.
 Die Kontrolle ist somit invertiert: Es ist nicht der Nutzer, der das Framework
 aufruft, sondern das Framework den Code des Nutzers.
 Diese Tatsache wird oft auch als Hollywood-Prinzip bezeichnet: "Don't call
 us, we'll call you" (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
key "Fowler2005"

\end_inset

).
\end_layout

\begin_layout Standard
Inversion Of Control ist eines der zentralen Merkmale, welches Frameworks
 von Bibliotheken unterscheidet.
 Allein Inversion Of Control ermöglicht die Definition einer wiederverwendbaren
 Softwarearchitektur, ohne dabei die konkrete Implementation einer Anwendung
 zu kennen.
 Das Framework ist lose mit der Implementation der eigentlichen Anwendung
 gekoppelt.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Wege und Entwurfsmuster um Inversion Of Control in unterschie
dlichen Aspekten einer Anwendung umzusetzen.
 In dieser Arbeit soll der Fokus auf die Umkehr der Kontrolle über die Auflösung
 von Abhängigkeiten liegen, mit dem Ziel lose Kopplung zu ermöglichen.
 Um diese spezielle Art von Inversion Of Control besser abzugrenzen, verwendet
 Fowler in seinem Artikel 
\begin_inset Quotes gld
\end_inset

Inversion of Control Containers and the Dependency Injection pattern
\begin_inset Quotes grd
\end_inset

 den Begriff Dependency Injection 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Fowler2004"

\end_inset

.
\end_layout

\begin_layout Section
Dependency Injection
\end_layout

\begin_layout Standard
Seemann gibt in 
\begin_inset Quotes gld
\end_inset

Dependency Injection in .NET
\begin_inset Quotes grd
\end_inset

 eine sehr vage Definition des Begriffs Dependency Injection:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency Injection is a set of software design principles and patterns
 that enable us to develop loosely coupled code.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 4"
key "Seemann2011"

\end_inset

 
\end_layout

\begin_layout Standard
Dependency Injection umfasst eine Reihe von Praktiken, die es ermöglichen
 lose Kopplung umzusetzen.
 Dabei lässt sich der Kern von Dependency Injection jedoch auf eine einzige
 Praktik reduzieren.
 James Shore beschreibt diese auf seiner Webseite wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency injection means giving an object its instance variables.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Shore2006"

\end_inset


\end_layout

\begin_layout Standard
Anstatt, dass sich das Objekt selbst um die Erstellung seiner Abhängigkeiten
 -- seiner Instanzvariablen -- kümmert, wird diese Aufgabe an einen Dritten
 übergeben.
 Die Verwendung des benötigten Objekts ist von der Konfiguration des Objekts
 getrennt.
 
\end_layout

\begin_layout Standard
Doch diese Praxis allein ist unzureichend, um lose Kopplung mittels Dependency
 Injection zu ermöglichen.
 Es müssen zudem eine Reihe von Prinzipien gewahrt werden.
 Diese wurden von Robert C.
 Martin geprägt und sind im Allgemeinen als SOLID-Prinzipien bekannt.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo {Quelle SOLID}
\end_layout

\end_inset


\end_layout

\begin_layout Section
SOLID
\end_layout

\begin_layout Standard
SOLID ist ein Akronym, welches für die folgenden Prinzipien steht: das Single-Re
sponsibility Principle, das Open/Closed Principle, das Liskov Substitution
 Principle, das Interface Segregation Principle und das Dependency-Inversion
 Principle.
 Es handelt sich um eine Sammlung von Richtlinien, die eine saubere Softwarearch
itektur ermöglichen sollen.
 An dieser Stelle wird auf eine ausführliche Beschreibung aller Prinzipien
 verzichtet.
 Es soll jedoch eine kurze Vorstellung der Prinzipien stattfinden und auf
 ihre Relevanz bei der Umsetzung von Dependency Injection eingegangen werden.
\end_layout

\begin_layout Subsection
Single-Responsibility Principle
\end_layout

\begin_layout Standard
Das Single-Responsibility Principle besagt, dass es niemals mehr als einen
 Grund geben sollte, um eine Klasse zu ändern.
 Darauf Folgend wird ein 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 in dem Zusammenhang als eine Verantwortung definiert.
 Jedoch wurde 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 bewusst gewählt, da es auch legitim ist mehrere Verantwortlichkeiten in
 einer Klasse unterzubringen, wenn diese sich mit hoher Wahrscheinlichkeit
 gemeinsam ändern.
\end_layout

\begin_layout Standard
Wird das Single-Responsibility Principle gewahrt, so ist in der Regel davon
 auszugehen, dass Klassen hohe Kohäsion aufweisen.
 Hohe Kohäsion ist jedoch nicht immer auf das Single-Responsibility Principle
 zurückzuführen.
 So kann eine Klasse hohe Kohäsion aufweisen, aber trotzdem mehrere Verantwortun
gen haben.
\end_layout

\begin_layout Standard
Dependency Injection wendet das Single-Responsibility Principle an, indem
 es Klassen die Verantwortung über die Erstellung von Instanzen ihrer Abhängigke
iten entzieht (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 24"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Open/Closed Principle
\end_layout

\begin_layout Standard
Softwareentitäten (Klassen, Methoden, Funktionen) sollen offen für Erweiterung,
 aber geschlossen für Modifikation sein.
 Mit 
\begin_inset Quotes gld
\end_inset

Offen für Erweiterung
\begin_inset Quotes grd
\end_inset

 ist gemeint, dass es möglich sein soll, die Entität in ihrem Umfang und
 Verhalten zu erweitern.
 
\begin_inset Quotes gld
\end_inset

Geschlossen für Modifikation
\begin_inset Quotes grd
\end_inset

 zum anderen bedeutet, dass zur Erweiterung keine Änderungen an der Entität
 an sich notwendig sind.
\end_layout

\begin_layout Standard
Abstraktion ermöglicht die Umsetzung des Open/Closed Principles.
 Wird von einer abstrakten Basisklasse geerbt, so ist es möglich das Verhalten
 der Abstraktion zu ändern, ohne die Abstraktion selbst zu manipulieren.
 Die Entwurfsmuster Strategy und Template-Method sind Beispiele für das
 Open/Closed Principle.
\end_layout

\begin_layout Standard
Auch Dependency Injection setzt das Open/Closed Principle um, indem Abhängigkeit
en lediglich in Form von Abstraktionen existieren.
 Damit ist dieses Prinzip ist eine wichtige Grundlage für lose Kopplung
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 106"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Liskov Substitution Principle
\end_layout

\begin_layout Standard
Das Liskov Substitution Principle beschreibt einer grundlegende Anforderung
 beim Einsatz von Vererbung: Untertypen einer Basisklasse sollen untereinander
 ersetzbar sein, ohne dabei das Verhalten des Programms selbst zu verändern.
 Das Programm selbst darf zu keinem Zeitpunkt einen Untertyp anders als
 einen anderen Untertypen behandeln.
\end_layout

\begin_layout Standard
Dependency Injection ermöglicht es, dass Abhängigkeiten beliebig austauschbar
 sind, solange sie die nötige Abstraktion implementieren.
 Dies ist jedoch nur möglich, wenn das Liskov Substitution Prinzip gewahrt
 wird (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 9-10"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
Dieses Prinzip kommt besonders beim Unit-Testing zum Vorschein: Abhängigkeiten
 eines Systems Under Test können durch Test Doubles ersetzt werden, ohne
 das Verhalten des Systems selbst zu verändern (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S.19"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Interface Segregation Principle
\end_layout

\begin_layout Standard
Anstatt große (
\begin_inset Quotes gld
\end_inset

fat
\begin_inset Quotes grd
\end_inset

) Interfaces zu nutzen, sollten diese in mehrere schlanke Interfaces aufgeteilt
 werden.
 Die Aufteilung soll nach Methodengruppen erfolgen, entsprechend wie sie
 von anderen Entitäten, die das Interface nutzen, gebraucht werden.
 So wird gewährleistet, dass andere Entitäten nur von Abstraktionen mit
 hoher Interfacekohäsion abhängig sind.
 Auch wenn diese Abstraktionen von einer einzigen nicht-kohäsiven Entität
 implementiert werden.
\end_layout

\begin_layout Standard
Das Interface Segregation Principle scheint zunächst nicht mit Dependency
 Injection im Zusammenhang zu stehen.
 Es ist eher eine Richtlinie, die bei der Anwendung von Dependency Injection
 gewahrt werden sollte.
 Wird eine Abhängigkeit von einem einzigen großen Interface repräsentiert,
 lenkt dieses Interface in die Richtung einer konkreten Implementation.
 Die Folge ist, dass Entitäten schwieriger auszutauschen sind, weil sie
 Interfacemethoden implementieren, die sie eigentlich gar nicht benötigen,
 um eine Abhängigkeit zu erfüllen (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 284"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Dependency-Inversion Principle
\end_layout

\begin_layout Standard
Das Dependency-Inversion Principle besteht aus zwei Teilen:
\end_layout

\begin_layout Itemize
High-Level Module sollen nicht von Low-Level Modulen abhängig sein.
 Beide sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Itemize
Abstraktionen sollten nicht von Details abhängen.
 Details sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Standard
Zum einen beschreibt das Dependency-Inversion Principle, dass die Architektur
 einer Anwendung in Schichten erfolgen sollte.
 Dabei soll die abstraktere, höher liegende Schicht ihre Abhängigkeiten
 in Form von Interfaces deklarieren.
 Die ihr untergeordnete Schicht wird basierend auf diesen Interfaces realisiert.
 Folglich sind die übergeordneten Schichten nicht von untergeordneten Schichten
 abhängig.
 Stattdessen sind untergeordnete Schichten von den abstrakten Interfaces
 in den übergeordneten Schichten abhängig.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Quelle fehlt!, Hierfür evtl.
 eine Grafik zur Veranschaulichung}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum anderen beschreibt Martin eine weitere, allgemeinere Interpretation
 des Dependency-Inversion Principles:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Depend on abstractions.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
So sollen Klassen keine Referenzen zu anderen konkreten Klassen halten,
 von ihnen ableiten oder Methoden ihrer Basisklasse überschreiben.
 Diese Praxis wurde bereits von der Gang of Four in 
\begin_inset Quotes gld
\end_inset

Design Patterns - Elements of Reusable Object-Oriented Software
\begin_inset Quotes grd
\end_inset

 mit den folgenden Worten beschrieben:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Program to an interface, not an implementation.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 17-18"
key "Gamma1994"

\end_inset

 
\end_layout

\begin_layout Standard
Die Deklaration von Abhängigkeiten in Form von Abstraktionen ist eine Grundlage,
 um lose Kopplung mittels Dependency Injection umzusetzen.
 Späte Bindung ermöglicht es, dass die konkrete Implementation auf diesem
 Wege erst zur Laufzeit bekannt sein muss.
\end_layout

\begin_layout Section
Umsetzung von Dependency Injection
\end_layout

\begin_layout Standard
Um zu erläutern, wie die in den vorherigen Abschnitten erklärten Prinzipien
 bei der Umsetzung von Inversion Of Control mittels Dependency Injection
 zusammenspielen, soll ein Beispiel herangezogen werden.
 Anhand dieses Beispiels sollen Patterns die im direkten Zusammenhang zu
 Dependency Injection stehen, beschrieben werden.
 Um das Beispiel so einfach wie möglich zu halten, wurde hierfür eine Konsolenan
wendung in C# gewählt.
\end_layout

\begin_layout Subsection
Ausgangssituation
\end_layout

\begin_layout Standard
Eine gewünschte Funktionalität eines zu entwickelnden Spiels ist, auszugeben,
 dass ein verwundbares Objekt Schaden genommen hat.
 Die in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Ausgangssituation"

\end_inset

 dargestellte Klasse 
\shape italic
DamageRenderer
\shape default
 setzt diese Funktionalität um.
 Zunächst scheint alles zu stimmen.
 Die Klasse beschränkt ihre Verantwortung auf eine einzige Funktionalität:
 Sie formatiert die Information in ein lesbares Format und gibt diese in
 der Konsole aus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format("{0} was attacked and took {1} damage.", target,
 damage);         		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausgangssituation des Beispiels
\begin_inset CommandInset label
LatexCommand label
name "fig:Ausgangssituation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Neue Anforderungen
\end_layout

\begin_layout Standard
Im Verlauf der Entwicklung des Spieles wird klar, dass das Spiel in verschiedene
n Sprachen veröffentlicht werden soll.
 Diese auch als Lokalisierung bekannte Anforderung ist eine gängige Anforderung
 für jegliche Art von Software.
 Es wird mit dem Refactoring begonnen und die Klasse 
\shape italic
EnglishLocalization
\shape default
 extrahiert.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Extraction"

\end_inset

 wird das Resultat des Refactorings gezeigt.
 Die Verantwortung über die Lokalisierung wurde in eine allein dafür vorgesehene
 Klasse verschoben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly EnglishLocalization localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Extraction der englischen Lokalisierung aus der existierenden Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:Extraction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Klasse 
\shape italic
DamageRenderer
\shape default
 funktioniert weiterhin wie im vorherigen Beispiel.
 Der Unterschied ist, dass 
\shape italic
DamageRenderer
\shape default
 nun eine Abhängigkeit zu 
\shape italic
EnglishLocalization
\shape default
 besitzt.
 Wie kann es nun ermöglicht werden, die englische Lokalisierung mit der
 Deutschen aus Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Deutsche-Lokalisierung"

\end_inset

 auszutauchen? Das Problem hierbei ist, dass 
\shape italic
DamageRenderer
\shape default
 eine konkrete Abhängigkeit zu 
\shape italic
EnglishLocalization
\shape default
 besitzt.
 Mit anderen Worten, sie sind eng miteinander gekoppelt.
 Die Folge ist, dass 
\shape italic
EnglishLocalization
\shape default
 nicht -- ohne 
\shape italic
DamageRenderer
\shape default
 zu ändern -- durch 
\shape italic
GermanLocalization
\shape default
 ausgetauscht werden kann.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GermanLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Deutsche Lokalisierung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Deutsche-Lokalisierung"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Programming to an Interface
\end_layout

\begin_layout Standard
Um lose Kopplung umzusetzen, darf keine Abhängigkeit zu einer konkreten
 Implementation existieren.
 Stattdessen muss sich auf eine Abstraktion als Abhängigkeit verlassen werden.
 In dem Beispiel in Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Depend-Abstractions"

\end_inset

 wird dies umgesetzt indem 
\shape italic
English-
\shape default
 und 
\shape italic
GermanLocalization
\shape default
 das Interface 
\shape italic
ILocalizationService
\shape default
 implementieren.
 Dadurch, dass 
\shape italic
DamageRenderer
\shape default
 nur noch eine Variable des Interfaces 
\shape italic
ILocalizationService
\shape default
 hält, lässt sich die konkrete Implementation austauschen.
 Dies ist jedoch immer noch nur möglich, indem 
\shape italic
DamageRenderer
\shape default
 geändert wird.
 Der Grund dafür ist, dass 
\shape italic
EnglishLocalization
\shape default
 im Konstruktor von 
\shape italic
DamageRenderer
\shape default
 instanziiert wird.
 Somit ist 
\shape italic
DamageRenderer
\shape default
 weiterhin eng mit 
\shape italic
EnglishLocalization
\shape default
 gekoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	string GetText();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class GermanLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von 
\begin_inset Quotes gld
\end_inset

Depend on abstractions
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:Depend-Abstractions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Injecting Dependencies
\end_layout

\begin_layout Standard
Um die Klassen lose miteinander zu koppeln, kommt an dieser Stelle der Einsatz
 von Dependency Injection ins Spiel: Anstatt, dass sich eine Klasse selbst
 um die Auflösung ihrer Abhängigkeiten kümmert, sollte sie von außen mit
 diesen versorgt werden.
 Die Verantwortung über die Auflösung der Abhängigkeiten wird abgegeben.
 Die Klasse selbst macht lediglich deutlich, dass Sie ein Objekt benötigt,
 welches die abstrakten Bedürfnisse eines Interfaces umsetzt.
 In diesem Fall, die eines 
\shape italic
ILocalizationServices
\shape default
.
 Dependency Injection lässt sich auf unterschiedlichen Wegen umsetzen.
 Die gebräuchlichsten sind Constructor Injection und Property Injection.
\end_layout

\begin_layout Subsubsection
Constructor Injection
\end_layout

\begin_layout Standard
Die Abhängigkeit wird über den Konstruktor bei der Instanziierung des Objektes
 bereitgestellt.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Constructor"

\end_inset

 wird Constructor Injection in der 
\shape italic
DamageRenderer
\shape default
-Klasse angewandt.
 Eine Instanz von 
\shape italic
ILocalizationService
\shape default
 muss bei Aufruf des Konstruktors übergeben werden.
\end_layout

\begin_layout Standard
Constructor Injection stellt sicher, dass die nötige Abhängigkeit auch tatsächli
ch verfügbar ist, indem eine Instanziierung des Objektes (ein Konstruktoraufruf)
 ohne diese nicht möglich ist.
 Damit wird erzwungen, dass der gesamte Abhängigkeitsgraph aufgebaut wird,
 bevor die Klasse genutzt werden kann.
 Eine Guard Clause stellt sicher, dass nicht null als Argument übergeben
 wird.
 Constructor Injection sollte in den meisten Fällen angewandt werden, denn
 in den meisten Fällen ist eine Abhängigkeit zwingend notwendig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer(ILocalizationService localization)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		this.localization = localization;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Constructor Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Constructor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Property Injection
\end_layout

\begin_layout Standard
Ist eine Abhängigkeit optional, kann die Klasse über ein Property mit einer
 Instanz dieser Abhängigkeit versorgt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Property"

\end_inset

 zeigt die Umsetzung von Property Injection anhand des gewählten Beispiels.
 Die Klasse stellt ein öffentlich setzbares Property vom Typ der Abhängigkeit
 bereit.
 In dem gezeigten Beispiel ist Property Injection wenig angebracht, da die
 Abhängigkeit notwendig ist.
 Man könnte jedoch, falls kein 
\shape italic
LocalizationService
\shape default
 bereitgestellt wird, beispielsweise im Getter eine Instanz von 
\shape italic
EnglishLocalization
\shape default
 erstellen und diese so als Local Default verwenden.
\end_layout

\begin_layout Standard
Das Open/Closed Principle lässt sich somit auch mit Properties umsetzen:
 Properties bieten die Möglichkeit eine optionale Abhängigkeit zur Erweiterung
 der Funktionalität einer Klasse preiszugeben, ohne dabei die Klasse selbst
 zu modifizieren.
\end_layout

\begin_layout Standard
Ein Nachteil ist, dass andere Klassen zu jeder Zeit Veränderungen an dem
 Property vornehmen können.
 Aus diesem Grund wird Property Injection in manchen Kreisen kritisiert,
 da es die Datenkapselung bricht.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo {Quelle hierfuer!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In einigen Fällen muss -- aufgrund von Beschränkungen durch die Verwendung
 von Frameworks wie z.
\begin_inset space ~
\end_inset

B.
 ASP.NET -- auf Constructor Injection verzichtet werden.
 Das Framework schreibt das Vorhandensein eines Default Constructors vor,
 der zur Initialisierung genutzt wird.
 In diesem Fällen kann auch alternativ auf Property Injection zurückgegriffen
 werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer : IDamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ILocalizationService Localization { private get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var output = string.Format(Localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Property Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Property"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Composition Root
\begin_inset CommandInset label
LatexCommand label
name "sub:Composition-Root"

\end_inset


\end_layout

\begin_layout Standard
In den letzten Abschnitten wurde verdeutlicht, dass Dependency Injection
 es verlangt, die Verantwortung über die Auflösung der Abhängigkeiten abzugeben.
 Es wurde jedoch nicht beschrieben, an wen diese Verantwortung übertragen
 werden soll.
 Die Antwort ergibt sich, wenn man Dependency Injection konsequent umsetzt:
 Abhängigkeiten werden in der Objekthierarchie nach oben gereicht, bis dies
 nicht mehr möglich ist.
 Die Auflösung der Abhängigkeiten sollte also so nah wie möglich beim Einstiegsp
unkt der Applikation geschehen.
 Soweit möglich sollte die Initialisierungslogik aller Objekte an diesem
 zentralen Ort umgesetzt werden.
 Dieser zentrale Ort wird als Composition Root bezeichnet (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 76-77"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
In einer Konsolenanwendung -- wie dem gezeigten Beispiel -- erfüllt die
 Main-Methode die Voraussetzungen für einen Composition Root: Sie ist der
 Einstiegspunkt in die Anwendung und zugleich der höchste Punkt in der Objekthie
rarchie.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CompositionRoot"

\end_inset

 zeigt den Composition Root der Beispielanwendung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Main(string[] args)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var localization = new GermanLocalization();
\end_layout

\begin_layout Plain Layout

		var renderer = new DamageRenderer(localization);
\end_layout

\begin_layout Plain Layout

		renderer.Render("Mario", 10);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Main-Methode erfüllt die Eigenschaften des Composition Roots in einer
 Konsolenanwendung
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Composition Root wird die Konfiguration der Anwendung vorgenommen.
 Es ist der einzige Ort, an dem die konkreten Instanzen von Objekten bekannt
 sein müssen.
 Er sollte unabhängig von dem Rest der Anwendung kompilierbar sein und sich
 deswegen in einem separaten Assembly befinden.
\end_layout

\begin_layout Subsection
Stable and volatile Dependencies
\end_layout

\begin_layout Standard
Nicht jede Abhängigkeit muss lose mit der Anwendung gekoppelt werden.
 Tatsächlich ist dies für bestimmte, feste Abhängigkeiten unnötig.
 Wichtig ist jedoch unterscheiden zu können, wann eine Abhängigkeit als
 fest (
\begin_inset Quotes gld
\end_inset

stable
\begin_inset Quotes grd
\end_inset

) und wann als unbeständig (
\begin_inset Quotes gld
\end_inset

volatile
\begin_inset Quotes grd
\end_inset

) angesehen werden sollte.
 
\end_layout

\begin_layout Standard
Kann davon ausgegangen werden, dass ein bereits existierendes Modul niemals
 ausgetauscht oder verändert wird, so kann es als eine feste Abhängigkeit
 angesehen werden.
 Ein Beispiel hierfür sind die meisten Module der Base Class Library, da
 sie fester Bestandteil des .NET Frameworks sind.
 Ob ein Modul als feste Abhängigkeit angesehen werden kann, lässt sich anhand
 der folgenden Kriterien beurteilen:
\end_layout

\begin_layout Itemize
Die Klasse oder das Modul existiert bereits.
\end_layout

\begin_layout Itemize
Es ist zu erwarten, dass neue Versionen der Abhängigkeit keine Änderungen
 enthalten werden, die Auswirkungen auf den Programmcode haben werden.
\end_layout

\begin_layout Itemize
Das Modul lediglich deterministische Algorithmen beinhaltet.
\end_layout

\begin_layout Itemize
Es ist nicht zu erwarten, dass das Modul jemals durch ein anderes ausgetauscht
 wird.
\end_layout

\begin_layout Standard
Den Gegensatz zu festen Abhängigkeiten bilden Klassen und Module, bei denen
 es absehbar ist, dass sie sich verändern werden.
 Ist eine Abhängigkeit unbeständig, sollte sie lose mit dem Rest der Anwendung
 gekoppelt werden, um ihre Austauschbarkeit zu ermöglichen.
 Eine Abhängigkeit wird als unbeständig angesehen, wenn eines der folgenden
 Kriterien auf sie zutrifft:
\end_layout

\begin_layout Itemize
Durch die Abhängigkeit wird eine bestimmte Laufzeitumgebung vorausgesetzt.
 
\end_layout

\begin_layout Itemize
Die Abhängigkeit existiert noch nicht.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nutzt eine Thrid-Party Library, die nicht auf allen Systemen
 vorhanden ist.
\end_layout

\begin_layout Itemize
Die Abhängigkeit weist nichtdeterministisches Verhalten auf (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 23-24"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
Ein Beispiel für eine in der Base Class Library vorhandene Klasse, die als
 unbeständige Abhängigkeit behandelt werden sollte, ist 
\shape italic
System.Random
\shape default
.
 Die Klasse weist nichtdeterministisches Verhalten auf, was sich besonders
 auf die Testbarkeit der Anwendung auswirkt.
\end_layout

\begin_layout Section
Resultierende Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten wurde ausführlich beschrieben, wie und warum
 lose Kopplung umzusetzen ist.
 Jedoch sind eventuell die Gründe für lose Kopplung, aufgrund des einfachen
 Beispiels, noch nicht ganz klar geworden.
 Besonders große und komplexe Softwareprojekte profitieren maßgeblich von
 loser Kopplung.
 Welche Faktoren genau beeinflusst werden, soll im Folgenden erläutert werden.
\end_layout

\begin_layout Subsection
Erweiterbarkeit
\end_layout

\begin_layout Standard
Während der Entwicklung einer Anwendung werden neue Anforderungen bekannt
 und existierende Anforderungen beginnen sich zu verändern.
 Trotzdem muss die Anwendung erweiterbar und wartbar bleiben.
 Erweiterbarkeit wird problematischer, je größer die Anwendung ist.
 In sehr großen Softwareprojekten ist es schwer abzusehen, welche Auswirkungen
 auch nur die kleinste Änderung hat.
 Aus diesem Grund ist es notwendig, Entitäten so autonom wie möglich zu
 halten.
 Dadurch, dass die Abhängigkeiten einer Entität auf Interfaces reduziert
 werden, haben Änderungen der konkreten Implementation keinen Einfluss auf
 sie.
\end_layout

\begin_layout Standard
Lose Kopplung setzt das Open/Closed Principle in die Tat um: Module sind
 offen für Erweiterung und geschlossen für Veränderung.
 Maßgeblich verantwortlich hierfür ist das Konzept der späten Bindung, welches
 durch 
\begin_inset Quotes gld
\end_inset

programming to an interface
\begin_inset Quotes grd
\end_inset

 konsequent umgesetzt wird.
 Die konkrete Implementation ist austauschbar und wird erst zur Laufzeit
 bekannt.
 Sie ist unabhängig vom Rest der Anwendung veränderbar.
\end_layout

\begin_layout Standard
Dependency Injection hilft dabei, Verantwortungen klarer aufzuteilen und
 zu definieren.
 Durch das Einhalten des Single Responcibility Principles wird es deutlicher
 an welchen Stellen Änderungen gemacht werden müssen.
 Oft genügt es eine konkrete Implementation durch eine andere auszutauschen,
 um ein gewünschtes Verhalten zu erzielen.
 Dependency Injection macht dies trivial.
\end_layout

\begin_layout Subsection
Wiederverwendbarkeit
\end_layout

\begin_layout Standard
Einzelne Softwaremodule sind wiederverwendbar, da diese lose zu ihren Abhängigke
iten gekoppelt sind.
 Die eigentliche Implementation dieser Abhängigkeiten ist für das Modul
 nicht relevant.
 Ist in einer anderen Umgebung eine andere konkrete Implementation notwendig,
 so kann sie einfach ausgetauscht werden.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern!}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelisierung
\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht die parallele Entwicklung einer Softwareanwendung,
 indem klare Schnittstellen zur Kommunikation definiert werden.
 Unter den kollaborierenden Entwicklern muss sich lediglich auf diese Schnittste
llen geeinigt werden.
 Die konkreten Implementationen sind nicht mehr relevant und können unabhängig
 voneinander im Parallelen umgesetzt werden.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern!}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbarkeit
\end_layout

\begin_layout Standard
Wie lose Kopplung die Testbarkeit einer Anwendung drastisch erleichtert,
 lässt sich am besten anhand eines Beispiels erläutern: Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Testability"

\end_inset

 zeigt die Implementation eines sehr simplen Spiels: Der Spieler soll das
 Resultat eines Würfelwurfs erraten.
 Mit der 
\shape italic
Roll
\shape default
-Methode der gezeigten 
\shape italic
GuessANumber
\shape default
-Klasse soll der Würfelwurf ausgeführt werden.
 Darauf folgend kann der Spieler -- durch den Aufruf der 
\shape italic
MakeGuess
\shape default
-Methode -- den Versuch vornehmen, das Ergebnis zu erraten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GuessANumber
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private IRandom random;
\end_layout

\begin_layout Plain Layout

	private int result;
\end_layout

\begin_layout Plain Layout

	private const int max = 6;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public GuessANumber(IRandom random)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.random = random;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GuessANumber Roll()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		result = random.Range(1, max);
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public bool MakeGuess(int guess)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return result == guess;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IRandom
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Range(int min, int max);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel einer durch Dependency Injection testbaren Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Testability"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die 
\shape italic
GuessANumber
\shape default
-Klasse hat eine unbeständige (
\begin_inset Quotes gld
\end_inset

volatile
\begin_inset Quotes grd
\end_inset

) Abhängigkeit zu 
\shape italic
IRandom
\shape default
.
 Diese Entscheidung wurde bewusst getroffen, da das Generieren einer Zufallsnumm
er nicht deterministisch ist.
 Die Abhängigkeit zu 
\shape italic
IRandom
\shape default
 wird über Constructor Injection aufgelöst.
 Eine Klasse, die das 
\shape italic
IRandom
\shape default
-Interface implementiert, könnte mithilfe von 
\shape italic
UnityEngine.Random 
\shape default
oder 
\shape italic
System.Random
\shape default
 umgesetzt werden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:GuessANumber-UnitTest"

\end_inset

 zeigt einen Unit-Test, der sicherstellen soll, dass die 
\shape italic
MakeGuess
\shape default
-Methode korrekt feststellen kann, ob richtig geraten wurde.
 Um die 
\shape italic
GuessANumber
\shape default
-Klasse durch einen Unit-Test auf korrekte Funktionalität prüfen zu können,
 muss das Resultat deterministisch sein.
 Hierzu wird anstatt einer echten Implementation einer 
\shape italic
Random
\shape default
-Klasse ein Stub des 
\shape italic
IRandom
\shape default
-Interfaces erzeugt.
 Das Erzeugen eines Stubs kann durch Verwendung des Isolation-Frameworks
 NSubstitute automatisiert werden: Durch Aufruf der Methode 
\shape italic
For<T>
\shape default
 der Klasse 
\shape italic
Substitute
\shape default
 wird ein dynamischer Stub für 
\shape italic
IRandom
\shape default
 erzeugt.
 Der Stub wird so konfiguriert, dass er für jeden Aufruf der 
\shape italic
Range
\shape default
-Methode -- unabhängig von beiden Parametern -- einen vorgegebenen Wert
 zurückgibt.
 Das Ergebnis eines Würfelwurfs durch die 
\shape italic
Roll
\shape default
-Methode wird somit diesem vorgegebenen Wert entsprechen.
 Damit ist zu erwarten, dass der Aufruf der 
\shape italic
MakeGuess
\shape default
-Methode mit dem vorgegebenen Wert 
\begin_inset Quotes gld
\end_inset

true
\begin_inset Quotes grd
\end_inset

 zurückgibt.
 Die tatsächliche Funktionalität der Methode kann nun durch ein Assert-Statement
 überprüft werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using NUnit.Framework;
\end_layout

\begin_layout Plain Layout

using NSubstitute;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[TestFixture]
\end_layout

\begin_layout Plain Layout

public class GuessANumberTests
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Test]
\end_layout

\begin_layout Plain Layout

	public void ShouldReturnTrueForRightGuess()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var expected = 6;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var randomStub = Substitute.For<IRandom>();
\end_layout

\begin_layout Plain Layout

		randomStub.Range(Arg.Any<int>(), Arg.Any<int>()).Returns(expected);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var guessANumber = new GuessANumber(randomStub);
\end_layout

\begin_layout Plain Layout

		guessANumber.Roll();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Assert.True(guessANumber.MakeGuess(expected));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Testen der GuessANumber Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:GuessANumber-UnitTest"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht, dass Module in Isolation betrachtet werden können.
 Durch Dependency Injection können zugrunde liegende Implementationen einer
 Abstraktion durch Fakes, Mocks und Stubs ausgetauscht werden.
 Es muss mit Bedacht auf die Testbarkeit einer Anwendung entschieden werden,
 ob eine Abhängigkeit fest oder unbeständig ist.
 Der sicherste Weg Testbarkeit zu gewährleisten, ist Test Driven Development
 in Kombination mit Dependency Injection zu praktizieren.
\end_layout

\begin_layout Chapter
Analyse der Architektur von Unity3D
\end_layout

\begin_layout Standard
In dem letzten Kapitel wurde beschrieben, was lose Kopplung ist und wie
 Inversion Of Control, und genauer Dependency Injection, dabei helfen, diese
 umzusetzen.
 Es wurde beschrieben, dass lose Kopplung maßgeblich zu der Qualität des
 Softwareproduktes beiträgt.
 Dependency Injection wurde beispielhaft in einer Konsolenanwendung angewendet.
 In diesem Kapitel sollen relevante Unterschiede zwischen der klassischen
 objektorientierten Programmierung bei der Entwicklung einer Konsolenanwendung
 und der komponentenbasierten Architektur von Unity beschrieben werden.
 Gute und schlechte Praktiken bei der Arbeit mit Unity sollen erläutert
 werden.
 Unity stellt von sich aus Mittel bereit, um die Kommunikation zwischen
 Klassen zu ermöglichen.
 Es soll untersucht werden, ob diese es bereits ermöglichen lose Kopplung
 umzusetzen.
\end_layout

\begin_layout Section
Komponentenbasierte Architektur von Unity3D
\end_layout

\begin_layout Standard
Jede Spieleengine implementiert eine Form eines Game Object Models.
 Ein Game Object Model beschreibt Hilfsmittel, die es ermöglichen Entitäten
 innerhalb der Spielwelt zu modellieren und zu simulieren 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 854"
before "vgl."
key "Gregory2014"

\end_inset

.
 Meistens bestehen diese Hilfsmittel aus zwei Teilen: einer visuellen Repräsenta
tion der Spielobjekte innerhalb des Editors der Engine und einer Laufzeitumgebun
g, die die Entwicklung neuer Spielobjekte ermöglicht.
 In jedem Fall wird ein Framework bereitgestellt, das die Konstruktion neuer
 Spielobjekte erlaubt 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 869"
before "vgl."
key "Gregory2014"

\end_inset

.
\end_layout

\begin_layout Standard
In klassischen objektorientierten Implementationen eines Game Object Models
 werden Spielobjekte von einer Vererbungshierarchie abgeleitet.
 Es handelt sich um eine monolithische Klassenhierarchie: Alle Objekte werden
 von einer gemeinsamen Basisklasse namens 
\shape italic
GameObject
\shape default
 abgeleitet.
 Diese Basisklasse enthält Funktionalität, die für alle Klassen notwendig
 ist.
 Ein Beispiel hierfür ist Serialisierung.
 Mit Wachstum des Projektes wächst auch die Hierarchie immer tiefer und
 weiter.
 Es folgt eine Reihe von Problemen: Klassen, die sich tief in der Vererbungshier
archie befinden, sind schwierig zu verstehen und zu verändern, da hierfür
 auch alle Basisklassen bekannt sein müssen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Grafik monolithische Klassenhierarchie vs komponentenbasierte Architektur}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es kann nur ein Merkmal als Basis für eine Vererbungshierarchie gewählt
 werden.
 Ein Merkmal kann beispielsweise die Beweglichkeit eines Objekts sein.
 Ein Anderes die Fähigkeit mit anderen Objekten zu kollidieren.
 Möchte man ein Objekt mit beiden Merkmalen haben, so stößt man schnell
 an die Grenzen einer solchen Architektur: Die benötigten Funktionalitäten
 müssen in der Hierarchie nach oben verschoben werden und bewirken so, dass
 sie eventuell in Klassen vorhanden sind in denen sie nicht gebraucht werden.
 Das Problem kann in einigen Sprachen auch durch Mehrfachvererbung gelöst
 werden, was aber zu einem Deadly Diamond führen kann: Ein Deadly Diamond
 entsteht indem eine Klasse von zwei Klassen erbt, die wiederum von der
 selben Basisklasse erben.
\end_layout

\begin_layout Standard
Um diesen Problemen vorzubeugen, implementiert Unity ein komponentenbasiertes
 Game Object Model.
 Das Grundprinzip dieses Models ist Komposition der Vererbung vorzuziehen.
 Anstatt Objekte mittels Vererbung und des 
\begin_inset Quotes gld
\end_inset

is a
\begin_inset Quotes grd
\end_inset

-Verhältnisses zu erweitern, erfolgt die Komposition eines Spielobjekts
 aus einzelnen Komponenten über das 
\begin_inset Quotes gld
\end_inset

has a
\begin_inset Quotes grd
\end_inset

-Verhältnis.
 In Unity werden Spielobjekte von der Klasse 
\shape italic
GameObject
\shape default
 abgebildet.
 Ein 
\shape italic
GameObject
\shape default
 fungiert als Knotenpunkt für eine variable Anzahl von Komponenten und hat
 kaum bis gar keine weitere Funktionalität 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 887"
before "vgl."
key "Gregory2014"

\end_inset

.
 Funktionalität wird erst durch das Anfügen von Komponenten hinzugefügt.
 Komponenten werden in Unity von der Klasse 
\shape italic
MonoBehaviour
\shape default
 abgeleitet.
 
\end_layout

\begin_layout Section
Programmierung und Konfiguration
\end_layout

\begin_layout Standard

\shape italic
MonoBehaviours
\shape default
 sind die Schnittstelle, die es Programmierern ermöglicht die Engine mit
 individuellem Verhalten zu erweitern, um ein Spiel umsetzen zu können.
 Unity verwendet die .NET-kompatible Laufzeitumgebung Mono um die plattformunabhä
ngige Entwicklung von Komponenten in C# und UnityScript zu ermöglichen.
 Dem Nutzer stehen folglich objektorientierte Sprachfeatures wie Polymorphismus
 und Vererbung innerhalb der Komponenten zur Verfügung.
 Komponenten können durch die Implementierung von einer Reihe von vordefinierten
 Eventfunktionen Einfluss auf das Spielgeschehen nehmen.
\end_layout

\begin_layout Standard
Der Rest -- also die Konfiguration und Komposition von Komponenten -- erfolgt
 in einem visuellen Editor.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Unity-Editor"

\end_inset

 zeigt das Benutzerinterface des Unity Editors.
 Der Editor erlaubt das Anlegen von Szenen, die den Lebensraum für Spielobjekte
 darstellen.
 Spielobjekte werden im sogenannten Hierarchiefenster erstellt und in einem
 Szenegraph angeordnet.
 Per Drag-and-Drop können Spielobjekten Komponenten hinzugefügt werden.
 Öffentliche Member einer Komponente können im Inspector konfiguriert werden.
 Wird eine Szene geladen, kümmert sich Unity, um die Instanziierung aller
 sich in der Szene befindlichen Spielobjekte und deren Komponenten.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Editor-Breakdown.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Das Benutzerinterface vom Unity Editor
\begin_inset CommandInset label
LatexCommand label
name "fig:Unity-Editor"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Quelle fuer Grafik einfuegen}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Betrachtet man die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Inversion-of-Control"

\end_inset

 gegebene Definition von Inversion Of Control, stellt man fest, dass diese
 auch auf Unity zutrifft.
 Die Kontrolle über die Komposition und Lebenszeit von Objekten ist bereits
 invertiert: Sie liegt in den Händen von Unity.
 Ein Indiz hierfür ist, dass Unity keine Konstruktoren in 
\shape italic
MonoBehaviours
\shape default
 zulässt.
 Es ist also nicht möglich, Komponenten über einen Konstruktor mit ihren
 Abhängigkeiten zu versorgen.
 Aus diesem Grund stellt Unity alternative Wege zur Referenzierung und Kommunika
tion mit anderen Komponenten bereit.
 Diese sollen im folgenden Abschnitt erläutert werden.
\end_layout

\begin_layout Section
Kommunikation und Abhängigkeiten
\end_layout

\begin_layout Standard
In Unity soll jede Komponente eine einzige Funktionalität kapseln und sie
 wiederverwendbar machen.
 Mit anderen Worten: Komposition anstelle von Vererbung soll es ermöglichen
 Funktionalitäten aus unterschiedlichen Bereichen in wiederverwendbare Komponent
en aufzuteilen, ohne sie dabei miteinander zu koppeln 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 213"
before "vgl."
key "Nystrom2014"

\end_inset

.
 In der Realität ist dies jedoch nur begrenzt möglich: Komponenten sind
 Teile eines größeren Ganzen und müssen somit kommunizieren und interagieren.
 Komponenten haben folglich Abhängigkeiten zueinander.
 
\end_layout

\begin_layout Standard
Oft beschränkt sich diese Kommunikation auf Komponenten desselben GameObjects.
 Es kommt jedoch auch vor, dass ein MonoBehaviour mit einem MonoBehaviour
 eines anderen GameObjects kommunizieren muss.
 Folglich wird zwischen zwei Arten der Kommunikation unterschieden:
\end_layout

\begin_layout Itemize
Die Intra-Objekt-Kommunikation erfolgt unter MonoBehaviours desselben GameObject
s oder Kindern von diesem.
\end_layout

\begin_layout Itemize
Die Inter-Objekt-Kommunikation beschreibt die Kommunikation zu anderen GameObjet
cts, die ansonsten in keiner Relation zueinanderstehen.
\end_layout

\begin_layout Standard
In beiden Fällen kann die Kommunikation direkt oder indirekt erfolgen.
 Bei direkter Kommunikation ist es notwendig, dass entweder Sender oder
 Empfänger einander kennen.
 Eines der Objekte hat also eine Abhängigkeit zu dem anderen.
 Kommunikation ist indirekt, wenn sie über ein drittes Objekt -- einem Vermittle
r -- erfolgt.
 In den meisten Fällen jedoch wird eine Referenz auf ein weiteres Objekt
 benötigt und es existiert somit eine Abhängigkeit zu diesem.
\end_layout

\begin_layout Standard
Im folgenden Abschnitt soll untersucht werden, ob Unitys integrierte Möglichkeit
en Abhängigkeiten aufzulösen es ermöglichen, lose Kopplung zwischen Komponenten
 umzusetzen.
\end_layout

\begin_layout Subsection
Referenzieren von anderen MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "sub:Referenzieren"

\end_inset


\end_layout

\begin_layout Standard
Unity bietet unterschiedliche Möglichkeiten, um Zugriff auf Spielobjekte
 und Komponenten zu erlangen.
 Es werden zahlreiche Game Object Queries für die Inter-Objekt-Kommunikation
 bereitgestellt.
 Um andere Komponenten referenzieren zu können, existieren sogenannte Component
 Queries.
 Des Weiteren ist auch eine Kommunikation über Events und Messages möglich.
 
\end_layout

\begin_layout Subsubsection
SerializeField
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
SerializeField
\shape default
 ist ein Attribut, das ermöglicht private Member einer Komponente zu serialisier
en und somit im Inspektor zu setzen.
 Setzbare Datentypen sind primitive Datentypen wie 
\shape italic
int
\shape default
, 
\shape italic
float
\shape default
, 
\shape italic
bool
\shape default
 und in Unity eingebaute Datentypen wie 
\shape italic
Vector
\shape default
, 
\shape italic
Quaternion
\shape default
 und 
\shape italic
Color
\shape default
, sowie Strings, Enums und Structs.
 Des Weiteren ist es möglich, Referenzen zu Klassen und Objekten durch Drag-and-
Drop im Editor zu setzen.
 Dabei ist zu beachten, dass diese Objekte vom Typ 
\shape italic
UnityEngine.Object
\shape default
 ableiten müssen.
 Es ist also nur möglich andere Komponenten oder Spielobjekte zu referenzieren.
 Aufgrund dieser Limitierung ist es nicht möglich, Interfaces im Editor
 zugänglich zu machen.
 Mit dem 
\shape italic
SerializeField
\shape default
-Attribut lässt sich somit keine lose Kopplung umsetzen.
 
\end_layout

\begin_layout Standard
Neben Variablen mit dem 
\shape italic
SerializeField
\shape default
-Attribut werden auch Variablen, die mit dem Zugriffsmodifizierer 
\shape italic
public
\shape default
 gekennzeichnet wurden im Editor zugänglich gemacht.
 Dies ist jedoch ausdrücklich nicht zu empfehlen, da so die Datenkapselung
 des Objektes gebrochen wird.
\end_layout

\begin_layout Standard
Ist bereits vor Ausführung des Spiels bekannt, welche Referenzen benötigt
 werden, sollten diese wenn möglich über 
\shape italic
SerializeField
\shape default
 aufgelöst werden.
 Um sicherzugehen, dass die Referenz im Editor aufgelöst wurde, ist es ratsam,
 einen Guard Clause in die 
\shape italic
OnValidate
\shape default
-Funktion der Komponente hinzuzufügen.
 Abb.
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SerializeField"

\end_inset

 verdeutlicht dies anhand eines einfachen Beispiels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.UI;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Assertions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SomeBehaviour : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[SerializeField]
\end_layout

\begin_layout Plain Layout

	private Image myImage;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnValidate()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Assert.IsNotNull(myImage);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SerializeField mit Guard Clause in OnValidate
\begin_inset CommandInset label
LatexCommand label
name "fig:SerializeField"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn erst zur Laufzeit bestimmt werden kann, welches das benötigte Objekt
 ist, zum Beispiel, wenn sich die Abhängigkeit außerhalb eines instanziierten
 Prefabs befindet, so muss auf eine andere Methode der Referenzierung zurückgegr
iffen werden.
\end_layout

\begin_layout Subsubsection*
GetComponent
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponent(Type type);
\end_layout

\begin_layout Plain Layout

public T GetComponent();
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
GetComponent
\shape default
 ermöglicht es, auf andere Komponenten desselben GameObjects zuzugreifen.
 Ist keine Komponente des gewünschten Typs vorhanden, wird 
\shape italic
null
\shape default
 zurückgegeben.
 Dies kann verhindert werden, indem man dem Script das Attribut 
\shape italic
RequireComponent
\shape default
 hinzufügt.
 
\shape italic
RequireComponent
\shape default
 bewirkt, dass die benötigte Komponente automatisch an das GameObject angefügt
 wird.
 Um auf Komponenten von anderen GameObjects in der über- und untergeordneten
 Hierarchieebene zugreifen zu können, werden zusätzlich folgende Methoden
 bereitgestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponentInChildren(Type t);
\end_layout

\begin_layout Plain Layout

public Component GetComponentInParent(Type t);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle 
\shape italic
GetComponent
\shape default
-Methoden spezifizieren einen Typparameter 
\shape italic
T
\shape default
 als Suchkriterium.
 Da 
\shape italic
T
\shape default
 nicht weiter -- zum Beispiel auf 
\shape italic
UnityEngine.Object
\shape default
 -- eingeschränkt wird, ist es möglich, anstatt konkreten Komponenten, auch
 Komponenten anhand eines Interfaces zu finden.
 Enge Kopplung zu einer konkreten Implementation einer Komponente entsteht
 so nicht.
 Dennoch ist 
\shape italic
GetComponent
\shape default
 keine optimale Lösung: Die Komponente selbst kümmert sich um die Auflösung
 ihrer Abhängigkeiten.
 
\shape italic
GetComponent
\shape default
 funktioniert entgegengesetzt zum Hollywood-Prinzip.
 Es ist von außen nicht sichtbar, dass die Komponente Abhängigkeiten hat.
 Ohne die Implementation der Komponente zu kennen, kann keine Aussage darüber
 getroffen werden, welche Abhängigkeiten notwendig sind, damit sie funktioniert.
 Die Komponente kann nur in Verbindung mit anderen Komponenten als GameObject
 getestet werden.
\end_layout

\begin_layout Standard
Beim Verwenden von 
\shape italic
GetComponent
\shape default
 wird implizit eine Anordnung in der Objekthierarchie festgelegt.
 Wird zum Beispiel eine benötigte Komponente in ein Child-GameObject verschoben,
 ist das Spiel ohne Änderung im Programmcode nicht mehr lauffähig.
 Aus diesem Grund sollte GetComponent nur in Ausnahmefällen, wenn beispielsweise
 eine Komponente zur Laufzeit hinzugefügt wird, verwendet werden.
 
\end_layout

\begin_layout Subsubsection*
String-Based Find Functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static GameObject Find(string name);
\end_layout

\begin_layout Plain Layout

public static GameObject FindWithTag(string tag);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unitys 
\shape italic
Find
\shape default
-Funktionen sind klassische Game Object Queries zur Inter-Objekt Kommunikation.
 Das gewünschte Spielobjekt wird auf Basis eines Strings als Suchkriterium
 zurückgegeben.
 Dieser String kann entweder der Name oder ein Tag sein.
 Nachdem das gesuchte Objekt gefunden wurde, muss die gewünschte Komponente
 mittels 
\shape italic
GetComponent
\shape default
 ausfindig gemacht werden.
 Die Funktionen unterscheiden sich im Verhalten, falls kein GameObject mit
 dem passenden Namen gefunden wird: Wird kein Objekt mit dem passenden Namen
 gefunden, gibt 
\shape italic
Find
\shape default
 
\shape italic
null
\shape default
 zurück.
 Wird kein Objekt mit dem passenden Tag gefunden, wirft 
\shape italic
FindWithTag
\shape default
 eine 
\shape italic
UnityException
\shape default
.
\end_layout

\begin_layout Standard
Generell ist von der Nutzung beider Funktionen abzuraten, da diese nicht
 gewährleisten, dass das gesuchte GameObject tatsächlich auffindbar ist.
 Es wird sich darauf verlassen, dass ein GameObject mit bestimmtem Namen
 oder Tag in der Szene existiert und bestimmte Komponenten an diesem vorhanden
 sind.
 Es gibt somit viel Raum für Fehlkonfiguration.
\end_layout

\begin_layout Subsubsection*
FindObjectOfType
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static Object FindObjectOfType(Type type);
\end_layout

\begin_layout Plain Layout

public static T FindObjectOfType<T>() where T : Object;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Gegensatz zu den anderen 
\shape italic
Find
\shape default
 Functions ist 
\shape italic
FindObjectOfType
\shape default
 typsicher.
 Es wird gewährt, dass eine in der Szene aktive Instanz eines bestimmten
 Typs erhalten wird.
 Anzumerken ist, dass der gewünschte Typ von 
\shape italic
UnityEngine.Object
\shape default
 abgeleitet sein muss.
 Somit funktioniert auch 
\shape italic
FindObjectOfType
\shape default
 nicht mit Interfaces.
 Die generische Variante von 
\shape italic
FindObjectOfType
\shape default
 ist anderen 
\shape italic
Find
\shape default
-Funktionen vorzuziehen, da sie direkt die Instanz der gesuchten Komponente
 vom Typ 
\shape italic
T
\shape default
 als Rückgabewert liefert.
 Es ist also nicht nötig 
\shape italic
GetComponent
\shape default
 zu nutzen.
\end_layout

\begin_layout Standard
In der Dokumentation der Funktion wird angemerkt, dass 
\shape italic
FindObjectOfType
\shape default
 sehr langsam ist.
 Sie sollte daher nicht jeden Frame genutzt werden.
 Als Alternative wird das Singleton Pattern vorgeschlagen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Quelle einfügen!}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Singleton und Statics
\end_layout

\begin_layout Standard
Singletons stellen sicher, dass es nur eine Instanz einer Klasse gibt, auf
 welche ein globaler Zugriffspunkt existiert.
 Singletons werden hier mit aufgeführt, weil sie in Unity alternativ zu
 
\shape italic
FindObjectOfType
\shape default
 genutzt werden können, mit der Beschränkung, dass sie auf eine Instanz
 limitiert sind.
 Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Singleton"

\end_inset

 zeigt eine mögliche Implementation eines Singletons, welches von 
\shape italic
MonoBehaviour
\shape default
 ableitet.
 Die Singletonkomponente muss lediglich einem Spielobjekt in der Szene hinzugefü
gt werden, um es global verfügbar zu machen.
 Der Zugriff auf die Singletonkomponente erfolgt über die statische Variable
 
\shape italic
Instance
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Singleton : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static Singleton Instance { get; private set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Awake ()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (Instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Instance = this;
\end_layout

\begin_layout Plain Layout

			DontDestroyOnLoad (this);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Destroy (gameObject);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Singleton Patterns in Form eines MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "fig:Singleton"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die abgebildete Implementation des Singletons erlaubt es, Funktionalitäten
 eines MonoBehaviours, wie dem Update Loop, zu nutzen.
 Sollten diese Funktionalitäten nicht notwendig sein, kann auch ein klassischer
 Singleton nach der Gang Of Four verwendet werden.
 Sollte gar keine Vererbung notwendig sein, gibt es oft jedoch gar keinen
 Grund ein Singleton zu implementieren.
 Stattdessen kann eine statische Klasse verwendet werden.
\end_layout

\begin_layout Standard
An dieser Stelle sei anzumerken, dass Singletons aus vielen Gründen als
 Anti-Pattern angesehen werden.
 Eine der Ursachen dafür ist, dass sie einen globalen Zustand einführen.
 Gleiches gilt für statische Klassen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Singleton als Anti-Pattern erläutern und Quellen angeben}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Events und Messages
\end_layout

\begin_layout Standard
Alternativ kann die Kommunikation zwischen Objekten auch über Events erfolgen.
 Events können im Unterschied zu Methodenaufrufen keinen oder mehrere Empfänger
 haben.
 Events sind eine Umsetzung des Observer Patterns.
 Die Klasse, die das Event auslöst, wird als Publisher und die Klassen,
 die das Ereignis behandeln als Subscriber, bezeichnet.
 Ein typischer Anwendungsfall für Events sind UI-Elemente wie Buttons, Slider
 und Toggles.
 Mit Events kann nichtsdestotrotz das gleiche Ergebnis wie mit Referenzierung
 und Methodenaufruf erzielt werden.
 Unity und C# bieten mehrere Möglichkeiten um die Kommunikation mittels
 Events umzusetzen.
 In dieser Arbeit wird davon abgesehen, darzustellen wie C# Events implementiert
 werden, da sie ohne Mediation oder Statics nicht das Problem der Referenzierung
 lösen.
 Wird ein gewöhnliches C# Event als Kommunikationskanal gewählt, so muss
 der Empfänger über einen der im letzten Abschnitt beschriebenen Wege Zugriff
 auf den Sender erhalten.
 Um diese Limitierung zu umgehen, bietet Unity ab der Version 4.6 eine eigene
 Implementierung von Events.
\end_layout

\begin_layout Subsubsection*
UnityEvent (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class UnityEvent<T,...,Tn>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents ermöglichen das Setzen von Callbacks über das Editorfenster.
 Auf diese Weise sind Sender und Empfänger komplett voneinander entkoppelt.
 Zudem bieten UnityEvents zusätzlich nahezu identische Funktionalität wie
 klassische C# Events.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEventCode"

\end_inset

 zeigt die Verwendung eines nicht generischen UnityEvents ohne Parameter.
 Die Publisher Komponente löst das Event in der 
\shape italic
Start
\shape default
-Methode aus.
 Ein Subscriber benötigt lediglich eine öffentliche Methode mit der passenden
 Signatur.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Events;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public UnityEvent myEvent;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (myEvent != null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			myEvent.Invoke();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Recieved");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Publishers und Subscribers unter Verwendung eines UnityEvents
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEventCode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist, dass bis jetzt noch keine Verbindung zwischen Publisher und
 Subscriber existiert.
 Diese kann im Editor gesetzt werden (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEvent"

\end_inset

).
 Somit wird es ohne weiteren Programmcode möglich, zu bestimmen wer auf
 ein Event reagieren soll.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/UnityEvent.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzufügen einer Callback-Methode für einen UnityEvent im Editor
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEvent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents bieten eine Möglichkeit, Sender von Empfänger komplett voneinander
 zu entkoppeln.
 Andererseits gibt es auch hier viel Raum zur Fehlkonfiguration.
 Es ist nicht im Programmcode ersichtlich, ob und wer die Subscriber eines
 Events sind.
 Genauso wenig ist ersichtlich, ob eine als öffentlich gekennzeichnete Methode
 als Callback genutzt wird oder nicht.
 Oft werden Methoden und Events, auf die keine Referenzen im Programmcode
 existieren, einfach gelöscht.
\end_layout

\begin_layout Standard
Events sind ein geeignetes Mittel, um optionale Abhängigkeiten aufzulösen.
 Ist eine Abhängigkeit jedoch zwingend erforderlich, sollte zu einer anderen
 Möglichkeit gegriffen werden.
\end_layout

\begin_layout Subsubsection*
Sending Messages
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void SendMessage(string methodName, object value = null, SendMessageOptio
ns options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void SendMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, object parameter = null,
 SendMessageOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, object value = null, SendMessa
geOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
MonoBehaviours bieten die Funktionalität, untereinander mittels Messages
 zu kommunizieren.
 
\shape italic
SendMessage
\shape default
 ermöglicht die Kommunikation zwischen Komponenten innerhalb eines Spielobjekts.
 
\shape italic
BroadcastMessage
\shape default
 sendet eine Message an das aufrufende Spielobjekt und dessen Children.
 
\shape italic
SendMessageUpwards
\shape default
 sendet die Nachricht an alle Spielobjekte, die sich dem Spielobjekt übergeordne
t in der Szene-Hierarchie befinden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SendMessage"

\end_inset

 zeigt die Verwendung von 
\shape italic
SendMessage
\shape default
 anhand von zwei Komponenten, die sich am gleichen Spielobjekt befinden.
 Der Publisher eines Events spezifiziert die Callbackmethode mittels eines
 Stringparameters.
 Dieser String repräsentiert den Namen der gesuchten Callbackmethode.
 Der Zugriffsmodifizierer der Callbackmethode ist dabei nicht relevant.
 Sie kann wie im Beispiel auch als 
\shape italic
private
\shape default
 deklariert werden.
 Durch den Aufzählungstyp 
\shape italic
SendMessageOptions
\shape default
 ist es möglich zu spezifizieren, ob ein Empfänger zwingend erforderlich
 ist.
 Wenn dieser als erforderlich gekennzeichnet wurde und dennoch kein Empfänger
 gefunden wird, wirft 
\shape italic
SendMessage
\shape default
 eine Ausnahme zur Laufzeit.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessagePublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		SendMessage("Receive");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessageSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendung von SendMessage
\begin_inset CommandInset label
LatexCommand label
name "fig:SendMessage"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
SendMessage
\shape default
 verwendet 
\begin_inset Quotes gld
\end_inset

magic strings
\begin_inset Quotes grd
\end_inset

 zur Identifikation der Callbackmethode.
 Refactorings der Methodennamen gefährden die Funktionalität der Anwendung.
 Auch hier ist es nicht ersichtlich, ob eine ansonsten nicht verwendete
 private Methode als Callback genutzt wird.
 Nach dem YAGNI-Prinzip werden nicht verwendete private Methoden einfach
 gelöscht.
 
\shape italic
SendMessage
\shape default
 legt implizit eine Anordnung in der Hierarchie fest, indem Aufrufe spezifisch
 an Parent- oder Childelemente erfolgen müssen.
\end_layout

\begin_layout Standard
Aus diesen Gründen ist der Nutzung von SendMessage generell abzuraten.
 Besonders, da mit Unity Version 4.6 ein neues Messaging System als Ersatz
 für SendMessage vorgestellt wurde.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/Manual/MessagingSystem.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
UnityEngine.EventSystems (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static bool Execute(GameObject target, EventSystems.BaseEventData
 eventData, EventFunction<T> functor);
\end_layout

\begin_layout Plain Layout

public static GameObject ExecuteHierarchy(GameObject root, EventSystems.BaseEvent
Data eventData, EventFunction<T> callbackFunction);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Eventsystem wurde in Verbindung mit uGUI in Unity 4.6 eingeführt.
 Es wird dazu verwendet, um Events bei Nutzereingaben zu senden.
 Man kann es jedoch auch für benutzerdefinierte Events verwenden.
 Anstelle eines Strings wird ein Interface verwendet, um eine Komponente
 zu kennzeichnen, die eine Callbackfunktion für ein bestimmtes Event implementie
ren.
 Events können mittels 
\shape italic
ExecuteHierarchy
\shape default
 in der Objekthierarchie nach oben, jedoch nicht nach unten, gesendet werden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EventSystems"

\end_inset

 zeigt ein Beispiel zur Verwendung des Eventsystems.
 Der Publisher löst ein Event durch den Aufruf der 
\shape italic
Execute
\shape default
-Methode der Klasse 
\shape italic
ExecuteEvents
\shape default
 in der 
\shape italic
Start
\shape default
-Methode aus.
 Die Angabe der Callbackmethode erfolgt als Parameter in Form einer Lambdafunkti
on.
  Es wird die 
\shape italic
Recieve
\shape default
-Methode des Subscribers aufgerufen.
 Hierzu muss der Subscriber das 
\shape italic
IEventTarget
\shape default
-Interface implementieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.EventSystems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.Execute<IEventTarget>(this.gameObject, null, (target, data)
 => target.Receive());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IEventTarget : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void Receive();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour, IEventTarget 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwenden von UnityEngine.EventSystems
\begin_inset CommandInset label
LatexCommand label
name "fig:EventSystems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Das neue Eventsystem ist ein typsicherer Ansatz Events an Komponenten in
 der Szenehierarchie zu senden.
 Publisher und Subscriber sind lose miteinander gekoppelt.
 Bei der Verwendung entsteht jedoch eine Abhängigkeit zu der statischen
 ExecuteEvents-Klasse.
 Testbarkeit ist somit nur innerhalb von Unity gewährleistet.
 Ohne das Spielobjekt der Empfängerkomponente zu kennen, kann jedoch nur
 an das eigene oder direkte Parent-Spielobjekte gesendet werden.
 
\end_layout

\begin_layout Section
Wertung und Konsequenzen
\end_layout

\begin_layout Standard
Unitys komponentenbasierte Architektur hilft dabei, Klassen mit lediglich
 einer Verantwortung zu erstellen.
 Spielobjekte lassen sich durch Komposition aus Komponenten in der Szenehierarch
ie arrangieren.
 Um koordinieren zu können, müssen Komponenten miteinander kommunizieren.
 Unity stellt dafür unterschiedliche Wege zur Kommunikation mit anderen
 Komponenten bereit.
 Durch Verwendung dieser Kommunikationsmittel entstehen Abhängigkeiten und
 damit eine Form von Kopplung.
 Einige Methoden ermöglichen zwar lose Kopplung, aber nicht durch Inversion
 Of Control.
 Eine Sache haben jedoch alle Kommunikationsmittel gemeinsam: Objekte müssen
 Komponenten oder Spielobjekte sein.
 Dies führt dazu, dass Objekte, um überhaupt kommunizieren zu können, von
 
\shape italic
MonoBehaviour
\shape default
 ableiten und an Spielobjekte angehängt werden.
\end_layout

\begin_layout Standard
Der Architektur von Unity fehlt ein Mittel zum Umgang mit geteilter Logik,
 die keinem einzelnen Spielobjekt zugeordnet werden kann.
 Es wird sich in der Regel auf einem von zwei Wegen Abhilfe geschaffen:
 
\end_layout

\begin_layout Itemize
Durch die Erstellung von sogenannten Manager- und Controllerobjekten, die
 an ansonsten 
\begin_inset Quotes gld
\end_inset

leere
\begin_inset Quotes grd
\end_inset

 Spielobjekte angehängt werden.
\end_layout

\begin_layout Itemize
Durch Singletons und statische Klassen, die globalen Zugriff ermöglichen.
\end_layout

\begin_layout Standard
Solche Klassen haben oft keine klar definierten Aufgaben.
 Sie wachsen mit der Zeit und werden somit zu Gottobjekten.
 Managerobjekte verletzen das Single-Responcibility Principle somit gleich
 auf mehreren Ebenen: Sie haben oft mehr als nur eine Aufgabe.
 Sie vermischen Darstellungs- mit Anwendungslogik, indem sie als Spielobjekte
 in der Szene existieren.
 Des Weiteren verletzen insbesondere Singletons das Single-Responcibility
 Principle, indem sie ihre Erstellung mit anderer Anwendungslogik mischen.
 
\end_layout

\begin_layout Standard
Durch die Referenzierung von Singletons, statischen Klassen oder Managern
 mittels 
\begin_inset Quotes gld
\end_inset

Find
\begin_inset Quotes grd
\end_inset

-Methoden wird der Rest der Anwendung eng mit diesen gekoppelt.
 Es wird unmöglich einzelne Komponenten zu testen und in anderen Projekten
 wiederzuverwenden.
 Es besteht folglich auch in Unity das Bedürfnis nach einer Alternative,
 die es ermöglicht lose Kopplung umzusetzen, ohne dabei die Kommunikation
 auf Komponenten oder Spielobjekte zu beschränken.
 Im nächsten Kapitel wird beschrieben, wie Dependency Injection in Unity
 umgesetzt werden kann, um diese Ansprüche zu erfüllen.
\end_layout

\begin_layout Chapter
Dependency Injection in Unity3D
\end_layout

\begin_layout Standard
Aus dem Fazit des letzten Kapitels geht hervor, dass keiner der in Unity
 zur Verfügung stehenden Kommunikationsmechanismen den gewünschten Ansprüchen
 entspricht.
 Das Ziel lose Kopplung in Unity umzusetzen, besteht weiterhin.
 Weiter wurde im letzten Kapitel festgestellt, dass Unity Programmierer
 in vieler Hinsicht einschränkt.
 Kommunikation ist auf die in der Szene existierenden Spielobjekte und deren
 Komponenten beschränkt.
 Es wurde festgestellt, dass die Kontrolle über die Komposition von Objekten
 bereits invertiert ist.
 In diesem Kapitel soll beschrieben werden, wie es dennoch ermöglicht wurde,
 Dependency Injection in Unity umzusetzen.
 
\end_layout

\begin_layout Section
Automating Dependency Injection
\end_layout

\begin_layout Standard
In Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Composition-Root"

\end_inset

 wurde veranschaulicht, wie Dependency Injection 
\begin_inset Quotes gld
\end_inset

per Hand
\begin_inset Quotes grd
\end_inset

 angewendet werden kann.
 Benötigte Instanzen werden manuell im Composition Root instanziiert.
 In dem gezeigten Beispiel war dies noch sehr überschaubar.
 In einer echten Anwendung entstehen jedoch schnell komplexe Abhängigkeitshierar
chien, die eine manuelle Dependency Injection unübersichtlich und fehleranfällig
 machen.
 Aus diesem Grund wird sich oft dazu entschlossen, die Auflösung von Abhängigkei
ten zu automatisieren.
 
\end_layout

\begin_layout Standard
In Unity ist diese Automatisierung zwangsläufig erforderlich.
 Die Kontrolle über die Erstellung von Komponenten liegt in den Händen von
 Unity.
 Es ist nicht möglich, Komponenten über den Konstruktor mit ihren Abhängigkeiten
 zu versorgen.
 Es existiert kein klarer Einstiegspunkt in die Anwendung, der es ermöglichen
 würde, Komponenten von außen mit ihren Abhängigkeiten zu versorgen.
 Beim Laden einer Szene werden alle sich in ihr befindlichen Spielobjekte
 instanziiert.
\end_layout

\begin_layout Standard
Die Kontrolle über die Komposition von Objekten soll an einen sogenannten
 Inversion Of Control Container abgegeben werden.
 Im Composition Root wird vom Nutzer lediglich die Konfiguration des Containers
 vorgenommen.
 Die zu instanziierenden Typen werden an diesem Ort beim Container registriert.
 Der Container kümmert sich um alles Weitere: Er versorgt alle Klassen mit
 ihren registrierten konkreten Abhängigkeiten und managt die Lebenszeit
 aller Objekte.
 Im Folgenden wird eine Möglichkeit der Implementation eines Inversion Of
 Control Containers in Unity beschrieben.
 Dabei soll besonders darauf eingegangen werden, wo aufgrund von Unitys
 Architektur Einschränkungen gemacht werden müssen.
\end_layout

\begin_layout Section
Umsetzung eines Inversion Of Control Containers für Unity
\end_layout

\begin_layout Standard
Der folgende Abschnitt beschreibt die Umsetzung eines Inversion Of Control
 Containers für Unity.
 Als Name für das Framework wurde der Einfachheit halber 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

 gewählt.
 Anhand der Implementation des Frameworks werden die mit Inversion Of Control
 Containern verbundenen Konzepte erläutert.
 Weiter sollen Hürden und Einschränkungen, die aus Unitys Architektur hervorgehe
n, beschrieben werden.
 Es werden Lösungen und Abhilfemaßnahmen für diese präsentiert.
 
\end_layout

\begin_layout Subsection
Definieren des Composition Roots
\begin_inset CommandInset label
LatexCommand label
name "sub:Definieren-des-Composition"

\end_inset


\end_layout

\begin_layout Standard
In Unity steht kein klarer Einstiegspunkt in die Anwendung zur Verfügung.
 Es existiert kein Zugriff auf eine 
\shape italic
Main
\shape default
-Methode, in der der Kontrollfluss der Anwendung beginnt.
 Der frühste Zeitpunkt, an dem der Nutzer Einfluss auf den Kontrollfluss
 der Anwendung nehmen kann, ist die 
\shape italic
Awake
\shape default
-Methode eines 
\shape italic
MonoBehaviours
\shape default
.
 Zu diesem Zeitpunkt wurden die alle in der Szene platzierten Spielobjekte
 mitsamt ihren Komponenten bereits instanziiert.
 Soweit nicht anders spezifiziert, erfolgt die Aufrufreihenfolge der 
\shape italic
Awake
\shape default
-Methoden der Komponenten zufällig, nach der Reihenfolge, in der sie geladen
 werden.
 Es ist jedoch möglich in den Script Execution Order Settings anzugeben,
 dass ein bestimmtes Script früher oder später geladen werden soll.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/Manual/class-ScriptExecution.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ExecutionOrderSettings.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Script Execution Order Settings mit Composition Root Komponente an oberster
 Stelle
\begin_inset CommandInset label
LatexCommand label
name "fig:Script-Execution-Order"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zur Definition des Composition Roots wird also zunächst ein einfaches MonoBehavi
our erstellt und einem leeren GameObject in der Szene hinzugefügt.
 Um sicherzustellen, dass dieses MonoBehaviour auch das erste Script ist,
 welches bei Anwendungsstart ausgeführt wird, sollte es in den Execution
 Order Settings an oberster Stelle stehen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Script-Execution-Order"

\end_inset

 zeigt die korrekte Konfiguration eines Composition Roots in den Script
 Execution Order Settings.
 Damit ist gewährleistet, dass der Composition Root Zugriff auf alle sich
 in der Szene befindlichen Komponenten hat, bevor diese ausgeführt werden.
 Im Composition Root kann nun die Konfiguration des Inversion Of Control
 Containers vorgenommen werden und Komponenten mit ihren Abhängigkeiten
 versorgt werden.
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:CompositionRoot-Klasse"

\end_inset

 zu sehen ist, wurde im 
\begin_inset Quotes gld
\end_inset

Containter
\begin_inset Quotes grd
\end_inset

-Framework der Composition Root als abstrakte Klasse definiert.
 Die Aufgabe der Klasse ist zunächst eine Instanz eines 
\shape italic
Containers
\shape default
 zu erstellen.
 Der 
\shape italic
Container
\shape default
 bildet das Herzstück des Frameworks.
 Durch ihn können abstrakte Basisklassen an ihre konkreten Instanzen 
\begin_inset Quotes gld
\end_inset

gebunden
\begin_inset Quotes grd
\end_inset

 werden.
 Diese Typregistrierung soll in der Methode 
\shape italic
SetupBindings
\shape default
 vorgenommen werden.
 Umgehend danach wird die 
\shape italic
Init
\shape default
-Methode aufgerufen.
 In ihr kann weitere Initialisierungslogik vorgenommen werden.
 Beide Methoden sind abstrakt, da die Typregistrierung für jede Applikation
 individuell erfolgen muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Container.Framework
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract class CompositionRoot : UnityEngine.MonoBehaviour
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		protected IContainer container;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		protected virtual void Awake()
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container = new Container();
\end_layout

\begin_layout Plain Layout

			SetupBindings();
\end_layout

\begin_layout Plain Layout

			Init();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void SetupBindings();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Klasse CompositionRoot.cs 
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot-Klasse"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die Umsetzung des Composition Roots abgeschlossen.
 Es fehlt jedoch noch die Implementation des Containers an sich.
 Im Folgenden soll beschrieben werden, wie dieser im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework umgesetzt wurde.
\end_layout

\begin_layout Subsection
Aufgaben eines Dependency Injection Containers
\end_layout

\begin_layout Standard
Bevor mit der Implementierung des Containers begonnen werden kann, müssen
 zunächst dessen grundlegende Aufgaben erläutert werden.
 Die Hauptaufgabe eines Dependency Injection Containers ist die Erstellung
 von Objekten.
 Hierfür muss dem Container bekannt sein, wie der Objekt Graph der Anwendung
 aufzulösen ist.
 Dem Nutzer des Containers muss es folglich ermöglicht werden, ihn zu konfigurie
ren: Er muss auswählen können, welche konkreten Implementationen einer Abstrakti
on 
\begin_inset Quotes gld
\end_inset

injiziert
\begin_inset Quotes grd
\end_inset

 werden sollen.
 Die 
\shape italic
Register
\shape default
-Methoden bilden diese Funktionalität ab.
\end_layout

\begin_layout Standard
Mit der Aufgabe der Erstellung von Objekten geht eine weitere Aufgabe einher:
 die Kontrolle über die Lebensdauer der Objekte.
 Der Container muss bestimmen, wann eine Instanz eines Objektes erstellt
 werden soll und wann diese nicht mehr gebraucht wird.
 Hierfür ist es für den Container wichtig den Sichtbarkeitsbereich (
\begin_inset Quotes gld
\end_inset

scope
\begin_inset Quotes grd
\end_inset

) eines Objektes zu kennen.
 Im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework wird zwischen zwei unterschiedlichen Sichtbarkeitsbereichen unterschi
eden: Transient und Singleton.
\end_layout

\begin_layout Subsubsection
Register Transient (Default-Scope)
\end_layout

\begin_layout Standard
Wird eine Klasse beim Container mit dem Sichtbarkeitsbereich Transient registrie
rt, so wird dieser bei jeder Anfrage zur Auflösung eine neue Instanz des
 Typs liefern.
 Instanzen können somit unabhängig voneinander Zustand halten.
 Aus diesem Grund ist Transient die sicherste Variante der Sichtbarkeitsbereiche.
 Sollte es beispielsweise Zweifel an der Threadsicherheit einer Klasse geben,
 kann diese als Transient registriert werden.
 Die Möglichkeit Klassen als Transient zu registrieren, soll vom Container
 durch die Methode 
\shape italic
RegisterTransient
\shape default
 implementiert werden.
\end_layout

\begin_layout Subsubsection
Register Singleton
\end_layout

\begin_layout Standard
Im Gegensatz zu Transient wird bei der Singleton Lebensdauer bei jeder Anfrage
 zur Auflösung eines Typs dieselbe Instanz geliefert.
 Zur Registrierung eines Objektes mit Singleton Lebensdauer soll die Methode
 
\shape italic
RegisterSingleton
\shape default
 dienen.
 Genauso wie beim Singleton Entwurfsmuster kann die Instanz entweder 
\begin_inset Quotes gld
\end_inset

eager
\begin_inset Quotes grd
\end_inset

 oder 
\begin_inset Quotes gld
\end_inset

lazy
\begin_inset Quotes grd
\end_inset

 instanziiert werden.
 Erfolgt die Instanziierung direkt bei der Registrierung, ist diese 
\begin_inset Quotes gld
\end_inset

eager
\begin_inset Quotes grd
\end_inset

, erfolgt sie erst bei Injektion, ist sie 
\begin_inset Quotes gld
\end_inset

lazy
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
Die Singleton Lebensdauer sollte nicht mit dem Singleton Entwurfsmuster
 verwechselt werden: Ein Container liefert immer die selbe Instanz eines
 Typs, jedoch verwendet er im Gegensatz zum Singleton Entwurfsmuster hierzu
 keine statische Membervariable.
 Der Sichtbarkeitsbereich eines als Singleton registrierten Typs ist der
 des Containers an dem er registriert wurde.
 Durch die Definition von mehr als einem Context, ist möglich mehrere Container
 zu verwenden.
 Somit ist es auch möglich, dass unterschiedliche Container eine unterschiedlich
e Instanz liefern.
\end_layout

\begin_layout Subsubsection
Resolve
\end_layout

\begin_layout Standard
Analog zu den 
\shape italic
Register
\shape default
-Methoden liefert die Methode 
\shape italic
Resolve
\shape default
 eine zuvor registrierte Instanz eines Typs.
 Mit dieser Instanz soll auch ihr gesamter Abhängigkeitsgraph instanziiert
 werden.
 In den meisten Fällen genügt ein einmaliger Aufruf der 
\shape italic
Resolve
\shape default
-Methode für das Root-Objekt des Object Graphs, um die komplette Anwendung
 zu initialisieren.
 
\end_layout

\begin_layout Subsubsection
Release
\end_layout

\begin_layout Standard
Üblicherweise gehört zu dem Management der Lebensdauer eines Objekts zu
 bestimmen, was mit Objekten geschieht, die sich außerhalb des Sichtbarkeitsbere
iches befinden.
 Mit dem Aufruf einer 
\shape italic
Release
\shape default
-Methode soll der Speicherbereich eines nicht mehr benötigten Objekts korrekt
 freigegeben werden.
 In .NET ist dies jedoch in den meisten Fällen nicht nötig, da ein Objekt,
 welches nicht mehr referenziert wird, vom Garbage-Collector aus dem Speicher
 entfernt wird.
 Aus diesem Grund wurde beim 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework auf die Implementierung einer 
\shape italic
Release
\shape default
-Methode verzichtet.
 
\end_layout

\begin_layout Subsubsection
Das Interface des DI Containers
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void RegisterTransient<TInter, TClass>() where TClass : class, TInter;
\end_layout

\begin_layout Plain Layout

	void RegisterSingleton<TInter, TClass>(TClass instance = null) where TClass
 : class, TInter;
\end_layout

\begin_layout Plain Layout

	T Resolve<T>();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Minimales IContainer Interface
\begin_inset CommandInset label
LatexCommand label
name "fig:Minimales-IBinder-Interface"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aus den beschriebenen Aufgaben ergibt sich das in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Minimales-IBinder-Interface"

\end_inset

 gezeigte Interface des zu implementierenden Dependency Injection Containers.
 Im nächsten Abschnitt wird die konkrete Implementation der Klasse 
\shape italic
Container
\shape default
 beschrieben.
\end_layout

\begin_layout Subsection
Implementation des Dependency Injection Containers
\end_layout

\begin_layout Standard
Die Implementation beginnt mit der Erstellung der Klasse 
\shape italic
Container
\shape default
, die das IContainer Interface implementiert.
 Um eine grundlegende Typregistrierung vornehmen zu können, müssen die Zuordnung
en abgespeichert werden.
\end_layout

\begin_layout Subsubsection
Registrieren und Speichern von Typzuordnungen
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Container : IContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, Type> transientMap = new Dictionary<Type,
 Type>();
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, object> singletonMap = new Dictionary<Type,
 object>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterTransient<TInter, TClass>() where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		transientMap[typeof(TInter)] = typeof(TClass);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterSingleton<TInter, TClass>(TClass instance = null) where
 TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//Eager instantiation of singleton objects
\end_layout

\begin_layout Plain Layout

		if (instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			instance = (TClass)Instantiate(typeof(TClass));
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		singletonMap[typeof(TInter)] = instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation der Register-Methoden in Container.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:RegisterMappings"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RegisterMappings"

\end_inset

 zeigt die Implementation der beiden 
\shape italic
Register
\shape default
-Methoden in 
\shape italic
Container.cs
\shape default
.
 Um die Registrierung abzuspeichern, werden zwei Dictionaries als Datenstrukture
n verwendet.
 Hierzu werden in beiden Methoden die Typen einer Abstraktion als Schlüssel
 verwendet.
 Der Unterschied zwischen Transient und Singleton besteht in der Speicherung
 der Datenwerte: Bei der Registrierung als Transient wird der Typ der konkreten
 Klasse als Wert in der 
\shape italic
transientMap
\shape default
 abgespeichert.
 Bei der Registrierung eines Singletons wird eine konkrete Instanz der Klasse
 gespeichert.
 Diese Instanz kann als Parameter übergeben werden.
 Wie zu sehen ist, ist es nicht zwingend notwendig eine Instanz bereitzustellen.
 Für diesen Fall wurde sich dazu entschieden, direkt eine 
\begin_inset Quotes gld
\end_inset

eager Instantiation
\begin_inset Quotes grd
\end_inset

 vorzunehmen.
 Die Implementation der 
\shape italic
Instantiate
\shape default
-Methode wird zu einem späteren Zeitpunkt in dieser Arbeit erklärt.
\end_layout

\begin_layout Subsubsection
Implementation der Resolve-Methode
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Resolve"

\end_inset

 zu sehen ist, delegiert die generische 
\shape italic
Resolve
\shape default
-Methode ihren Aufruf an eine nicht-generische Version.
 Diese prüft zunächst, ob eine Instanz in der Singleton-Registrierung vorliegt.
 Bei Vorhandensein wird diese zurückgegeben.
 Ist der Typ jedoch als Transient registriert, soll eine neue Instanz des
 in der transientMap registrierten, konkreten Typs erstellt und zurückgegeben
 werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public T Resolve<T>()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = typeof(T);
\end_layout

\begin_layout Plain Layout

	return (T)Resolve(type);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private object Resolve(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (singletonMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = singletonMap[type];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else if (transientMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = Instantiate(transientMap[type]);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		throw new Exception("Couldn't resolve binding for " + type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation der Resolve-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Resolve"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Instanziieren von Klassen basierend auf Typinformationen
\end_layout

\begin_layout Standard
Die tatsächliche Erstellung von Objekten übernimmt die in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Instantiate-Methode"

\end_inset

 gezeigte 
\shape italic
Instantiate
\shape default
-Methode der Klasse 
\shape italic
Container
\shape default
.
 Unter Vorgabe eines konkreten Typs soll eine Instanz dieses Typs geliefert
 werden.
 Die Methode delegiert diese Verantwortung an eine Methode namens 
\shape italic
CreateInstance
\shape default
 der Klasse 
\shape italic
Activator
\shape default
.
 Es sind hierfür jedoch noch weitere Informationen über die Klasse notwendig.
 Dies ist zum einen der zu verwendende Konstruktor der Klasse mitsamt seinen
 Parametern und zum Anderen Porperties, in die Abhängigkeiten injiziert
 werden sollen.
 Über die 
\shape italic
GetConstructor
\shape default
-Methode erhält der Containter Informationen über den Konstruktor, den er
 zur Erstellung des Objektes nutzen soll.
 Dieser kann vom Nutzer des Frameworks spezifiziert werden.
 Um zu beschreiben, wie genau dies abläuft, müssen zunächst die zwei Sprachfeatu
res von C# die diese Funktionalität ermöglichen, vorgestellt werden: Attributes
 und Reflection.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	var constructor = GetConstructor(type);
\end_layout

\begin_layout Plain Layout

	if (constructor != null)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var paramInfos = constructor.GetParameters();
\end_layout

\begin_layout Plain Layout

		var paramInstances = ResolveParameters(paramInfos);
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type, paramInstances);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//No constructor defined, use the default constructor
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	InjectProperties(instance);
\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Instantiate-Methode in Binder.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:Instantiate-Methode"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attributes
\end_layout

\begin_layout Standard
Mittels Attributes lassen sich Metadaten für Programmcodeelemente definieren.
 Diese Metadaten sind Informationen, die von der Anwendung zur Laufzeit
 ausgewertet werden können.
 Es können praktisch alle Elemente des Programmcodes mit Metadaten versehen
 werden: Assemblys, Klassen, Methoden, Eigenschaften usw.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://msdn.microsoft.com/de-de/library/z0w1kczw.aspx
\end_layout

\end_inset

 Ein Beispiel hierfür ist das bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Referenzieren"

\end_inset

 gezeigte 
\shape italic
SerializeField
\shape default
-Attribut.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendung-Attribute"

\end_inset

 zeigt eine Membervariable, der das 
\shape italic
SerializeField
\shape default
-Attribut zugewiesen wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\begin_layout Plain Layout

private Text sampleWithAttribute;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für die Verwendung eines Attributes
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendung-Attribute"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für den Dependency Injection Container sind im Grunde zwei Metadaten einer
 Klasse relevant: Ihm muss bekannt sein, welcher Konstruktor zur Instanziierung
 eines Objektes verwendet werden soll und in welche Properties Abhängigkeiten
 injiziert werden sollen.
 Es ist ausreichend ein einziges benutzerdefiniertes Attribut zu definieren,
 um beide Funktionalitäten abzubilden: Bei der späteren Auswertung des Attribute
s kann geprüft werden, ob sich dieses an einem Konstruktor oder einem Property
 befindet und dementsprechend gehandelt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Definition-des-Inject-Attributs"

\end_inset

 zeigt die Erstellung des hierfür vorgesehenen 
\shape italic
InjectAttribute
\shape default
-Attributes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Constructor)]
\end_layout

\begin_layout Plain Layout

public class InjectAttribute : Attribute
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Definition des Inject-Attributs
\begin_inset CommandInset label
LatexCommand label
name "fig:Definition-des-Inject-Attributs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird zunächst eine Klasse definiert, die von der Klasse 
\shape italic
Attribute
\shape default
 ableitet.
 Um die Gültigkeit des Attributes festzulegen, wird die Klasse selbst mit
 einem 
\shape italic
AttributeUsage
\shape default
-Attribut gekennzeichnet.
 Im Fall des 
\shape italic
Inject
\shape default
-Attributs wird die Gültigkeit auf Properties und Konstruktoren beschränkt.
 Bei der Verwendung entspricht der Attributname dem Klassennamen des Attributs.
 Die Endung Attribute kann weggelassen werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendungmöglichkeiten"

\end_inset

 zeigt die gültigen Verwendungsmöglichkeiten des 
\shape italic
InjectAttribute
\shape default
-Attributes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleClass
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//Alternativ [InjectAttribute]
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public ISomeProperty property { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleClass(ISomeDependency first, IAnotherDependency second)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendungsmöglichkeiten des Inject-Attributes
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendungmöglichkeiten"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reflection
\end_layout

\begin_layout Standard
Der Zugriff auf die mit dem Inject-Attribut gekennzeichneten Attribute erfolgt
 mittels Reflection.
 Reflection ermöglicht das Auslesen und Auswerten von Metadaten eines Assemblys
 oder Typs zur Laufzeit.
 Metadaten werden über die 
\shape italic
System.Type
\shape default
-Klasse abgebildet.
 Diese wurde bereits an einigen Stellen zur Implementation des Containers
 verwendet.
 Es wurde also genau genommen bereits Reflection eingesetzt.
 
\end_layout

\begin_layout Standard
Bei der Implementation des Containers wird an zwei Stellen intensiver Zugriff
 auf die Typinformationen des zu instanziierenden Objekts benötigt: Als
 Erstes muss mittels Reflection herausgefunden werden, welcher Konstruktor
 zur Instanziierung genutzt werden soll.
 Diese Funktionalität wird von der Methode 
\shape italic
GetConstructor
\shape default
 in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Zugriff-auf-Typinformationen"

\end_inset

 implementiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private ConstructorInfo GetConstructor(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var constructors = type.GetConstructors();
\end_layout

\begin_layout Plain Layout

	ConstructorInfo constructor;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (constructors.Length == 1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors[0];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors.Single(x => Attribute.IsDefined(x, typeof(InjectAttri
bute)));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return constructor;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zugriff auf Typinformationen mittels Reflektion in der Methode GetConstructor
\begin_inset CommandInset label
LatexCommand label
name "fig:Zugriff-auf-Typinformationen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methode 
\shape italic
GetConstructors
\shape default
 der Klasse 
\shape italic
Type
\shape default
 liefert Informationen zu allen definierten Konstruktoren einer Klasse.
 Um den gewünschten, mit dem 
\shape italic
Inject
\shape default
-Attribut gekennzeichneten Konstruktor zu erhalten, wird über die vorhandenen
 Konstruktoren iteriert und der gewünschte Konstruktor mithilfe der statischen
 Methode 
\shape italic
IsDefined
\shape default
 der Klasse 
\shape italic
Attribute
\shape default
 identifiziert.
 Existiert nur ein einziger Konstruktor für einen Typ, muss dieser nicht
 explizit mit dem 
\shape italic
Inject
\shape default
-Attribut gekennzeichnet werden, um vom Container zu Instanziierung genutzt
 zu werden.
\end_layout

\begin_layout Standard
Betrachtet man die 
\shape italic
Instantiate
\shape default
-Methode in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Instantiate-Methode"

\end_inset

 ein weiteres Mal, stellt man fest, dass bevor die tatsächliche Instanziierung
 über den Konstruktor vorgenommen wird, zunächst alle Parameter instanziiert
 werden müssen.
 Diese Aufgabe übernimmt die Methode 
\shape italic
ResolveParameters
\shape default
 aus Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Auflösen-Konstruktorparameter"

\end_inset

.
 Es wird über die Parameterinformationen des Konstruktors iteriert und alle
 Parameter der Reihe nach instanziiert.
 Dies geschieht über einen rekursiven Aufruf der 
\shape italic
Resolve
\shape default
-Methode.
 Somit ist es Voraussetzung, dass alle Typen der Konstruktorparameter zuvor
 bei dem Container registriert wurden.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object[] ResolveParameters(ParameterInfo[] parameterInfos)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var parameters = new object[parameterInfos.Length];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < parameters.Length; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var parameterInfo = parameterInfos[i];
\end_layout

\begin_layout Plain Layout

		parameters[i] = Resolve(parameterInfo.ParameterType);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return parameters;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen der Konstruktorparameter durch die ResolveParameters-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-Konstruktorparameter"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nach der Instanziierung eines Typs ist es notwendig, die Klasse mit Abhängigkeit
en, die in Form von Properties vorliegen, zu versorgen.
 Die Methode 
\shape italic
InjectProperties
\shape default
, gezeigt in der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Auflösen-von-Properties"

\end_inset

, bildet diese Funktionalität des Containers ab.
 In diesem Fall werden Informationen zu Properties mit dem 
\shape italic
Inject
\shape default
-Attribut über die Methode 
\shape italic
GetProperties
\shape default
 der Klasse Type geliefert.
 Im nächsten Schritt wird über die 
\shape italic
PropertyInfos
\shape default
 iteriert und mittels Aufruf der 
\shape italic
Resolve
\shape default
-Methode eine Instanz des Properties geholt.
 Diese Instanz wird danach dem Property des Objektes mithilfe 
\shape italic
SetValue
\shape default
-Methode zugewiesen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void InjectProperties(object instance)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = instance.GetType();
\end_layout

\begin_layout Plain Layout

	var propertyInfos = type.GetProperties().Where(prop => Attribute.IsDefined(prop,
 typeof(InjectAttribute))).GetEnumerator();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (propertyInfos.MoveNext())
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var propertyInfo = propertyInfos.Current;
\end_layout

\begin_layout Plain Layout

		var propertyInstance = Resolve(propertyInfo.PropertyType);
\end_layout

\begin_layout Plain Layout

		propertyInfo.SetValue(instance, propertyInstance, null);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen von Properties durch die InjectProperties-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-von-Properties"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die grundlegende Implementation des Containers abgeschlossen.
 Zur optimalen Zusammenarbeit mit Unity sollten jedoch noch einige Erweiterungen
 vorgenommen werden.
 Diese Erweiterungen sollen im folgenden Abschnitt beschrieben werden.
\end_layout

\begin_layout Subsection
Erweiterungen des Containers für die Zusammenarbeit mit Unity
\end_layout

\begin_layout Standard
Damit bessere Zusammenarbeit des Containers mit Unity gewährleistet werden
 kann, sollten noch ein paar Erweiterungen an diesem vorgenommen werden.
 Es gibt beispielsweise derzeit keine Möglichkeit Abhängigkeiten in MonoBehaviou
rs zu injizieren.
\end_layout

\begin_layout Subsubsection
Injecting into MonoBehaviours
\end_layout

\begin_layout Standard
Wie bereits in den vorigen Abschnitten festgestellt, übernimmt Unity selbst
 die Verantwortung über die Erstellung von MonoBehaviours.
 Es folglich keinen Konstruktor über den Abhängigkeiten aufgelöst werden
 können.
 Es muss sich auf Property-Injection beschränkt werden.
 Dabei ist zu berücksichtigen, dass MonoBehaviours bereits in der Szene
 existieren, bevor die Awake-Methode des Composition Roots aufgerufen wird.
 Desweiteren können Spielobjekte und MonoBehaviours auch zur Laufzeit instanziie
rt werden.
 In beiden Fällen muss es ermöglicht werden, dass diese ihre Abhängigkeiten
 erhalten.
 Im Folgenden sollen drei Ansätze hierfür erläutert werden: Das Verwenden
 des Containers als Service Locator, Factories und ExecuteEvents als MonoBehavio
ur-Extension.
\end_layout

\begin_layout Subsubsection
Service Locator
\end_layout

\begin_layout Standard
Eine mögliche Lösung für das Problem ist die Verwendung des Containers als
 Service Locator.
 Bei einem ServiceLocator handelt es sich um einen statischen Wrapper für
 den Container.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Service-Locator"

\end_inset

 zeigt eine mögliche Implementation des Service Locator Patterns unter Verwendun
g der Binder-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class ServiceLocator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private static readonly IBinder binder = new Binder();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterTransient<TInter, TClass>() where TClass : class,
 TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.RegisterTransient<TInter, TClass>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterInstance<TInter, TClass>(TClass instance = null)
 where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.RegisterInstance<TInter, TClass>(instance);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static T Resolve<T>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return binder.Resolve<T>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Service Locators
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Service-Locator"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Konfiguration des ServiceLocators würde, wie die des Containers, in
 der zuvor definierten CompositionRoot-Klasse stattfinden.
 Der Unterschied zwischen einem ServiceLocator und einem DI Container liegt
 nicht in der Implemenation sondern in der Verwendung.
 Die Verwendung der Resolve Methode des DI Containers beschränkt sich üblicherwe
ise auf einen einzigen Aufruf im Composition Root und setzt somit die rekursive
 Auflösung des gesamten Objektgraphs in Gang.
 Wird ein Service Locator verwendet, können Abhängigkeiten von überall im
 Programm durch Aufruf der Resolve-Methode angefordert werden.
 MonoBehaviours würden also in der Awake-Methode durch Anfrage beim ServiceLocat
or ihre Abhängigkeiten erhalten.
 
\end_layout

\begin_layout Standard
Auf den ersten Blick scheinen keine Vorteile bei der Verwendung des Service
 Locators verloren zu gehen: Abhängigkeiten sind lose gekoppelt, die Programmier
ung im parallelen ist gewährleistet und Testbarkeit ist durch Konfiguration
 des Service Locators in der Testumgebung möglich.
 Trotzdem wird der Service Locator oft als Anti-Pattern angesehen.
 Klassen haben eine unnötige konkrete Abhängigkeit an den Service Locator.
 Die Klasse wird explizit für eine Verwendung mit dem Service Locator implementi
ert.
 Von Aussen ist es nicht sichtbar, dass die Klasse andere Abhängigkeiten
 hat.
 Es kann keine Aussage darüber getroffen werden, welche Abhängigkeiten notwendig
 sind, damit eine Klasse funktioniert.
 
\end_layout

\begin_layout Standard
Jedoch ermöglicht der Service Locator die Auflösung von Abhängigkeiten eines
 MonoBehaviours.
 Die Verwendung des ServiceLocators kann auf MonoBehaviours reduziert werden
 und in diesem Fall als notwendig angesehen werden.
 Das Problem ist jedoch, dass der Service Locator, aufgrund der globalen
 Sichtbarkeit als statische Klasse, von unwissenden Programmierern auch
 in anderen Bereichen genutzt werden kann.
 Im folgenden sollen zwei weitere Möglichkeiten vergestellt werden, mit
 denen sich Abhängigkeiten eines MonoBehaviours lassen.
 Alle haben ihre Vor- und Nachteile.
 Der Service Locator ist die einfachste, aber zugleich auch die am wenigsten
 elegante Lösung des Problems.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes gld
\end_inset

Inject
\begin_inset Quotes grd
\end_inset

-Event als MonoBehaviour-Extension
\end_layout

\begin_layout Standard
Die Grundidee dieser Methode ist, dem Container über einen Event bescheid
 zu geben, dass ein MonoBehaviour in der Szene erstellt wurde und dessen
 Abhängigkeiten aufgelöst werden müssen.
 Hierzu wird die Klasse MonoBehaviour mit der in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Erweiterungsmethode"

\end_inset

 gezeigten Extension erweitert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class MonoInjectionExtension
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Inject(this MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.ExecuteHierarchy<IMonoInjectionHandler>
\end_layout

\begin_layout Plain Layout

			(script.gameObject, null, (target, data) => target.InjectDependencies(script));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Erweiterungsmethode für MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "fig:Erweiterungsmethode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mittels der ExecuteHierarchy-Methode der Klasse ExecuteEvents wird ein Event
 in der Hierarchie nach oben gesendet.
 Das Event soll vom Composition Root entegengenommen werden, damit dieser
 die Aufllösung der Abhängigkeiten an den Container delegieren kann.
 Dazu muss CompositionRoot das für diesen Fall erstellte IMonoInjectionHandler-I
nterface implementieren.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IMonoInjectionHandler"

\end_inset

 zeigt das Interface IMonoInjectionHandler und dessen Implementation vom
 Composition Root.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IMonoInjectionHandler : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void InjectDependencies(MonoBehaviour script);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public abstract class CompositionRoot : IMonoInjectionHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void InjectDependencies(MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation von IMonoInjectionHandler
\begin_inset CommandInset label
LatexCommand label
name "fig:IMonoInjectionHandler"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei dieser Methode is zu Beachten, dass alle Spielobjekte im Szenengraph
 Kindknoten des Composition Roots sein müssen.
 Jedes MonoBehaviour muss im Start-Event explizit die Inject-Erweiterungsmethode
 aufrufen, damit die Abhängigkeiten vom Container aufgelöst werden.
 Dies könnte bereits im Awake-Event geschehen, da durch das Festlegen der
 Script Execution Order in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definieren-des-Composition"

\end_inset

 gewährleistet wurde, dass der Composition-Root den Container bereits initialisi
ert hat.
 Instanziiert man jedoch ein Spielobjekt zur Laufzeit, so muss der Composition
 Root unmittelbar darauf als Elternelement festgelegt werden.
 Es ist nicht möglich ein Spielobjekt direkt als Kindelement eines anderen
 Spielobjekts zu instanziieren.
 Zum Aurufzeitpunkt der Awake-Methode hat noch kein Parenting stattgefunden,
 auch wenn dies unmittelbar nach Instanziierung geschieht.
 Demzufolge sollte die Inject-Methode im Start-Event des MonoBehaviours
 aufgerufen werden.
\end_layout

\begin_layout Standard
Bei Verwendung der beschriebenen Methode ist es nötig, dass der Nutzer des
 Containers sich strikt an die beschriebenen Anweisungen hält.
 Ein Aufruf der Inject-Methode muss im Start-Event erfolgen.
 Alle Spielobjekte müssen Kindobjekte des Composition Roots sein.
 Nachfolgend soll eine letzte Möglichkeit vorgestellt werden, die dem Nutzer
 weniger Verantwortung abverlangt.
\end_layout

\begin_layout Subsubsection
Auflösung des Szenegraphs und Factories
\end_layout

\begin_layout Standard
Bei dieser Methode wird die Auflösung von Abhängigkeiten von MonoBehaviours
 in zwei Teile unterteilt.
 Durch den ersten Teil werden bereits in der Szene existierende MonoBehaviours
 mit ihren Abhängigkeiten versorgt.
 Dies wird bewerkstelligt indem dem CompositionRoot die ResolveScene-Methode
 hinzugefügt wird.
 Diese Methode wird im Awake-Event unmittelbar nach der Konfiguration des
 Containers aufgerufen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ResolveScene"

\end_inset

 zeigt die Änderungen an der CompositionRoot-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container = new Binder();
\end_layout

\begin_layout Plain Layout

		SetupBindings();
\end_layout

\begin_layout Plain Layout

		ResolveScene();
\end_layout

\begin_layout Plain Layout

		Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void ResolveScene()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		foreach (var script in Object.FindObjectsOfType(typeof(MonoBehaviour)))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzugefügte ResolveScene-Methode in CompositionRoot.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:ResolveScene"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um die Abhängigkeiten der existierenden MonoBehaviours aufzulösen, wird
 über alle MonoBehaviours in der Szene iteriert und dem Container mitgeteilt
 alle Properties zu instanziieren.
 Durch das Festlegen der Script Execution Order in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

, wird gewährleistet, dass alle sich in der Szene befindenden MonoBehaviours
 ihre Abhängigkeiten bereits vor dem Aufruf der Awake-Methode erhalten haben.
\end_layout

\begin_layout Standard
Weiter muss der Fall berücksichtigt werden, dass Spielobjekte dynamisch
 zur Laufzeit instanziiert werden können.
 Unmittelbar nach der Instanziierung müssen die Abhängigkeiten aller MonoBehavio
urs des Spielobjektes vom Container aufgelöst werden.
 Damit dies sichergestellt wird und an einem zentralen Ort geschieht, soll
 hierfür eine Factory implementiert werden.
 Über diese Factory sollen alle Spielobjekte zur Laufzeit erstellt werden.
 Das heißt, dass es im Programmcode keine weiteren Aufrufe der Instantiate-Metho
de der Klasse Object geben darf.
 Der einzige Aufruf der Instantiate-Methode findet in der Create-Methode
 der GameObjectFactory-Klasse wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GameObjectFactory"

\end_inset

 dargestellt, statt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GameObjectFactory : IGameObjectFactory
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GameObject Create(GameObject original)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var instance = Object.Instantiate(original);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		foreach (var script in instance.GetComponents<MonoBehaviour>())
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			binder.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		return instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausschnitt GameObjectFactory.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:GameObjectFactory"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Direkt nach dem Instanziieren werden die Properties aller MonoBehaviours
 vom Container instanziiert.
 Es ist sichergestellt, dass MonoBehaviours zum Start-Event über alle Abhängigke
iten verfügen.
 Die GameObjectFactory bietet eine weitere Überladung der Create Methode.
 Aus Platzgründen wurde diese hier ausgelassen.
 Mit ihr lassen sich Prefabs anhand ihres Namens im Resource-Ordner instanziiere
n.
 Spielobjekte die aus dem Resource-Ordner geladen wurden, werden in einem
 Cache zwischengespeichert.
 
\end_layout

\begin_layout Standard
Bei Verwendung dieser Methode muss der Nutzer des Container Frameworks keine
 frameworkspezifischen Operationen innerhalb einer MonoBehaviour-Komponente
 vornehmen.
 Dem Nutzer muss lediglich bewusst sein, dass er die Klasse GameObjectFactory
 zur Instanziierung von Spielobjekten zu Laufzeit verwenden muss.
 Es ist nicht nötig, dass Spielobjekte Kindobjekte des Composition Roots
 sind, um ihre Abhängigkeiten zu erhalten.
 Aus diesem Grund ist aus Sicht des Autors, diese Methode den anderen vorzuziehe
n.
\end_layout

\begin_layout Subsubsection
Injecting MonoBehaviours
\end_layout

\begin_layout Standard
Alle bis jetzt gezeigten Methoden beschreiben wie Abhängigkeiten in MonoBehaviou
rs injektziert werden können.
 An dieser Stelle soll beschrieben werden, wie mit Abhängigkeiten zu anderen
 MonoBehaviours umgegangen werden soll.
 Zunächst sollte überprüft werden, ob es tatsächlich notwendig ist, dass
 die benötigte Klasse von MonoBehaviour erbt.
 Durch strike Trennung der Belange (Seperation Of Concerns) kann dies meist
 auf die Darstellungslogik reduziert werden.
 Die benötigten Komponenten sind meist Unity-eigene Klassen wie Button,
 Label oder RigidBody am selben Spielobjekt.
 In diesen Fällen können sie mithilfe des SerializeField-Attributs im Editor
 gesetzt werden.
 
\end_layout

\begin_layout Standard
Liegen dennoch Gründe vor, dass eine Abhängigkeit zu einem MonoBehaviour
 benötigt wird, könnte dieses theoretisch beim Container registriert werden.
 Vorrausgesetzt es implementiert ein Interface welches die benötigte Funktionali
tät abbildet.
 Das Spielobjekt des MonoBehaviours kann mittels Find-Methode vom Composition
 Root ausfindig gemacht und im Anschluss beim Container registriert werden.
 Die Registration ist somit jedoch auf eine einzige Instanz eines Typs beschränk
t.
 Hiervon wird jedoch ausdrücklich abgeraten.
 Anhand eines Beispiels soll im Folgenden ein alternativer Ansatz beschrieben
 werden.
\end_layout

\begin_layout Standard
Die Idee dieses Ansatzes ist, nicht ein MonoBehaviour, sondern einen Wrapper
 für dieses beim Container zu registrieren.
 Ein Feature eines MonoBehaviours welches auch ausserhalb von diesem benötigt
 werden könnte, ist das Ausführen von Coroutines.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html
\end_layout

\end_inset

 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 zeigt die Verwendung dieses Ansatzes bei der Umsetzung der beschriebenen
 Funktionalität.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunnerBehaviour : MonoBehaviour, ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		DontDestroyOnLoad(transform.gameObject);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunner : ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IGameObjectFactory gameObjectFactory;
\end_layout

\begin_layout Plain Layout

	private readonly ICoroutineRunner coroutineRunnerBehaviour;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public CoroutineRunner(IGameObjectFactory gameObjectFactory)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.gameObjectFactory = gameObjectFactory;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var go = this.gameObjectFactory.Create("CoroutineRunnerPrefab");
\end_layout

\begin_layout Plain Layout

		coroutineRunnerBehaviour = go.GetComponent<ICoroutineRunner>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return coroutineRunnerBehaviour.StartCoroutine(routine);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des CoroutineRunners
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-des-Coroutine"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die gewünschte Funktionalität wird zunächst durch die ICoroutineRunner-Schnittst
elle definiert.
 Die Implementation erfolgt von der Klasse CoroutineRunnerBehaviour indem
 sie von MonoBehaviour erbt.
 Weiter wird die Schnittstelle auch von der Klasse CoroutineRunner implementiert.
 Im Konstruktor erstellt sie, durch den Aufruf der Create-Methode der GameObject
Factory ein Prefab, welches die CoroutineRunnerBehaviour-Komponente besitzt.
 Den Aufruf der StartCoroutine-Methode delegiert die Klasse an diese CoroutineRu
nnerBehaviour-Komponente.
 Die Klasse CoroutineRunner kann ohne Weiteres im Composition Root beim
 Container registriert werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

container.RegisterTransient<ICoroutineRunner, CoroutineRunner>();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sie kann nun in alle anderen Module injekziert und genutzt werden.
 Damit ist eine grundlegende Zusammenarbeit zwischen Unity und dem Inversion
 Of Control-Container gewährleistet.
 Um die gezeigten Beispiele auf das Wesentliche zu reduzieren, wurde auf
 die Darstellung und Implementierung einiger Funktionalitäten verzichtet.
 Diese sollen jedoch im folgenden Abschnitt kurz Erwähnung finden.
\end_layout

\begin_layout Subsection
Weitere Ansatzpunkte zur Erweiterung
\end_layout

\begin_layout Standard
Bei dargestellten Implementierung des Inversion Of Control Containers handelt
 es sich um einen Proof Of Concept.
 Die Funktionsweise, sowie nötige Sprachfeatures sollten beschrieben und
 eine Zusammenarbeit mit Unity gewährleistet werden.
 Auf eine ausführliche Beschreibung aller Details wurde verzichtet.
 So wird beispielsweise das eager- und lazy-loading von Singletons der tatsächli
chen Implementierung 
\begin_inset Foot
status open

\begin_layout Plain Layout
Siehe Anhang!
\end_layout

\end_inset

 unterstützt.
\end_layout

\begin_layout Standard
Auch gibt es zahlreiche Ansatzpunkte zur Erweiterung des Frameworks:
\end_layout

\begin_layout Itemize
Die Verwendung von Reflection führt zu starken Performanceeinbußen.
 Obwohl sich die Aufrufe der Reflection-Bibliotheken zum Großteil auf den
 Programmstart beschränken, sollten diese reduziert werden.
 Die Ergebnisse der Reflection eines Typs sollten gecached und vom Container
 wiederverwendet werden.
\end_layout

\begin_layout Itemize
Das Verhalten bei zirkulären Abhhängigkeiten ist nicht bestimmt.
 Im besten Fall sollten diese gar nicht erst zugelassen werden.
 Es sollte eine Laufzeitexception geworfen werden.
\end_layout

\begin_layout Itemize
Die API zur Konfiguration/Registrierung des Containers kann verbessert und
 erweitert werden.
 Es können Fluent Interfaces zur Erstellung einer Domänenspezifischen Sprache
 verwendet werden.
 Eine weitere Konfigurationsmöglichkeit könnte über JSON oder XML geboten
 werden.
 Der Vorteil einer solchen externen Konfiguration ist, dass das Verhalten
 der Anwendung ohne erneuter Kompilierung geändert werden kann.
\end_layout

\begin_layout Itemize
Bis jetzt wurde die Verwendung des Containers auf eine einzige Szene beschränkt.
 Auf das Verhalten bei der Arbeit mit mehreren Szenen wurde nicht eingegangen.
 Jede Szene könnte einen eigenen Composition Root haben, welcher die nötigen
 Abhängigkeiten der Szenen individuell auflöst.
 Alternativ könnte ein einziger Container in der 
\begin_inset Quotes gld
\end_inset

Haupt
\begin_inset Quotes grd
\end_inset

-Szene die Abhängigkeiten in allen Szenen auflösen.
 Dies ist sinnvoll, wenn alle Szenen gleiche Abhängigkeiten haben.
 Werden Szenen additiv geladen, wäre auch die Erstellung einer Containerhierarch
ie eine Möglichkeit.
 Beim Root-Container werden Abhängigkeiten, die über mehrere Szenen hinweg
 benötigt werden registriert, während Childcontainer spezifische Abhängigkeiten
 der additiv geladenen Szene auflösen.
\end_layout

\begin_layout Itemize
Der Container sollte für eine ordnungsgemäße Entsorgung von Objekten sorgen.
 Im speziellen sollte sichergestellt werden, dass die Dispose-Methode von
 Klassen die IDisposable implementieren aufgerufen wird.
\end_layout

\begin_layout Itemize
Es ist derzeit nicht möglich Logik unmittelbar nach der Injection auszuführen.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 wird diese Beschränkung umgangen, weitere Logik im Konstruktor ausgeführt
 wird.
 Die Gefahr hierbei ist jedoch, dass Properties zu diesem Zeitpunkt noch
 nicht injected wurden.
 Desweiteren sollte das Single-Responcibility-Principle gewahrt werden indem
 im Konstruktor lediglich Initialisierungs-Logik ausgeführt wird.
 Aus diesem Grund sollte ein weiteres Attribut namens Postconstruct vorgestellt
 werden: Methoden die mit dem PostConstruct-Attribut versehen wurden, sollen
 unmittelbar nach dem Injection-Prozess vom Container aufgerufen werden.
\end_layout

\begin_layout Standard
Aus diesen Gründen wird von dem Autor dieser Arbeit davon abgeraten, den
 präsentierten Container zur Entwicklung eines Spiels zu verwenden.
 In dem folgenden Abschnitt sollen ausgereiftere Dependency Injection Container
 für Unity3D vorgestellt und auf ihre Tauglichkeit bei der Entwicklung von
 Spielen untersucht werden.
\end_layout

\begin_layout Section
Übersicht Dependency Injection Container für Unity3D
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten dieser Arbeit wurden Prinzipien, Praktiken
 und Funktionsweise von Dependency Injection und Inversion Of Control Containern
 beschrieben.
 Dieser Abschnitt soll eine Übersicht über die für Unity verfügbaren Inversion
 Of Control Container geben.
 Ihre Funktionsumfänge und Besonderheiten sollen beschrieben werden.
 Oft bieten diese Frameworks Funktionalitäten die weit über Automated Dependency
 Injection hinaus gehen.
\end_layout

\begin_layout Standard
Die vorzustellenden Container wurden speziell für die Verwendung mit Unity
 entwickelt.
 Ein Grund hierfür ist, dass - wie im vorherigen Abschnitt ausführlich beschrieb
en - einige Erweiterungen notwendig sind, um die Verwendung eines Containers
 in Unity zu ermöglichen.
 Ein weiterer Grund ist, dass Unity's Mono Laufzeitumgebung lediglich Kompabilit
ät zum .NET Framework 3.5 aufweist.
 Die meisten existierenden Inversion Of Control Container für .NET verwenden
 .NET 4.0 oder höher.
 
\end_layout

\begin_layout Standard
Das Grundkonzept für die Implementation eines Inversion Of Control Containers
 für Unity lieferte Sebastiano Mandalà im September 2012 in einer Serie
 von Blogeinträgen.
 Auf dieser Basis haben sich mit der Zeit eine Reihe von Frameworks entwickelt.
 Im Folgenden sollen die Frameworks Zenject, adic und StrangeIoC vorgestellt
 werden.
\end_layout

\begin_layout Subsubsection
Zenject
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/modesttree/Zenject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zenject ist ein Dependency Injection Container, der sich aus einem direkten
 Fork des Konzepts von Sebastiano Mandalà entwickelt hat.
 Zusätzlich zu den grundlegenden Funktionalitäten eines DI-Containers bietet
 das Framework eine Vielzahl von Registrierungsoptionen wie zum Beispiel
 die Registrierung von Prefabs und GameObjects oder Injection in spezifische
 Methoden und Getter.
 Darüber hinaus bietet das Framework eine Möglichkeit zur Validierung und
 Visualisierung des Object Graphs: Es kann überprüft werden, dass alle zu
 injizierenden Typen im Object Graph einer Szene beim Container registriert
 sind.
 Es ist möglich eine an UML angelegte graphische Darstellung des Object
 Graphs der Anwendung zu generieren.
\end_layout

\begin_layout Subsubsection
adic
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/intentor/adic
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adic ist ein weiterer Dependency Injection Container für Unity der sich
 vorallem durch seine Einfacheit in Umsetzung und Verwendung auszeichnet.
 Dennoch bietet er die vollständige Funktionalität eines Dependency Injection
 Containers und noch einige weitere Optionen.
 Diese sind unter Anderem: Conditional Bindings, die es ermöglichen eine
 Registrierung eines Typs unter bestimmten Bedingungen vorzunehmen.
 Eine mögliche Bedingung ist beispielsweise, dass Injection eines Typs nur
 über Konstruktoren oder in bestimmte Instanzen erfolgen soll.
 Zudem implementiert adic ein Command- und Eventsystem, das sehr ähnlich
 zu dem von StrangeIoC ist.
 Diese werden im folgenden Abschnitt genauer erläutert.
\end_layout

\begin_layout Subsubsection
StrangeIoC
\begin_inset Foot
status open

\begin_layout Plain Layout
http://strangeioc.github.io/strangeioc/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
StrangeIoC ist ein umfangreiches Inversion Of Control Framework, das weit
 mehr als nur einen Dependency Injection Container bietet.
 Das open-source Projekt verfügt über eine aktive Community, die bemüht
 ist, das Framework kontinuierlich zu verbessern und zu erweitern.
 StrangeIoC ist in großen Teilen von Robotlegs, einem Application Architecture
 Framework für ActionScript, beeinflusst.
 Aus diesem wurde auch das wohl augenscheinlichste Merkmal des Frameworks
 übernommen: Eine MVC(S)-Architektur, mit der sich ein breites Spektrum
 von Anwendungen umsetzen lassen soll.
 Die Architektur vereint eine umfangreiche Anzahl von Konzepten, welche
 in ihrer Gesamtheit eine saubere Trennung von Verantwortungen ermöglichen
 sollen.
 Diese Konzepte und ihr Zusammenwirken als MVC(S)-Architektur sollen im
 folgenden Abschnitt erläutert werden.
\end_layout

\begin_layout Section
MVC(S)-Architektur in Unity mithilfe von StrangeIoC
\end_layout

\begin_layout Standard
Model-View-Controller-Service, oder kurz MVCS, ist ein Architekturmuster,
 welches die Struktur einer Anwendung in vier eigenständige Module unterteilt:
 Model, View, Controller und Service.
 Es erweitert die klassische MVC-Architektur um eine Service-Schicht, unter
 welche der Zugriff auf externe Daten und Dienste, wie Web-Server, Datenbanksyst
eme oder Zugriffe auf das Dateisystem, fallen.
 
\end_layout

\begin_layout Standard
MVCS soll einen konsistenten Ansatz zur Strukturierung einer Anwendung liefern.
 Genauso wie bei der klassischen MVC-Architektur ist die Grundlage hierfür
 Präsentations- von Anwendungslogik zu trennen.
 Diese Trennung erfolgt durch die Definition folgender Schichten: Die Präsentati
onsschicht (View-Layer) ist für die Darstellung der Benutzeroberfläche und
 der Verarbeitung von Interaktionen mit dem Benutzer zuständig.
 Die Modellschicht (Model-Layer) speichert den aktuellen Zustand der Anwendung,
 der durch das Ausführen von Operationen durch den Nutzer und externer Quellen
 resultiert.
 Die Steuerungsschicht (Controller-Layer) stellt Mechanismen zur Interaktion
 und Koordination zwischen den anderen Schichten zur Verfügung.
 
\end_layout

\begin_layout Standard
Zusätzlich zu dem Vorteil der Strukturierung hilft die MVCS-Architektur
 von StrangeIoC die Kopplung zwischen den einzelnen Schichten zu minimieren.
 Damit sollen einzelne Programmabschnitte tesbar und die Austauschbarkeit
 der Darstellungs- und Service-Schicht gewährleistet werden.
 Abhängigkeiten zu externen APIs können in der Service-Schicht gekapselt
 und somit Austauschbar gemacht werden.
 Somit ist es beispielsweise ohne große Umstände möglich, den Zugriff auf
 Daten aus dem lokalen Dateisystem mit dem Remote-Zugriff auf eine Datenbank
 auszutauschen.
\end_layout

\begin_layout Standard
Die Umsetzung der MVC(S)-Architektur weicht stark von der des klassischen
 MVC-Entwurfsmusters ab.
 StrangeIoC verwendet eine Reihe von eigenen Konzepten und Mustern um die
 MVC(S)-Architektur umzusetzten.
\end_layout

\begin_layout Subsection
Umsetzung von MVC(S) in StrangeIoC
\end_layout

\begin_layout Standard
In diesem Abschnitt soll erklärt werden, wie die in StrangeIoC zur Verfügung
 stehenden Konzepte in der MVC(S)-Architektur zusammenspielen.
 Eine schlüssige Zusammenfassung der Architektur liefert ein Schaubild aus
 der Dokumentation (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MVCS-Context"

\end_inset

).
 Wie in der Grafik beschrieben, ist der Einstiegspunkt in die Anwendung
 der ContextView.
 Von ihm wird der eigentliche Context instanziiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Strange_Flow_Chart.png
	lyxscale 20
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild MVC(S) Context Architektur
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCS-Context"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Context und ContextView
\end_layout

\begin_layout Standard
Der Context ist ein von den restlichen Schichten der Architekur unabhängiges
 Modul.
 Grob gesagt handelt es sich um einen Composition Root wie in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

 definiert.
 Mit dem Unterschied, dass es möglich ist mehr als einen Context zu definieren.
 Jeder Context wird an einen ContextView, ein MonoBehaviour in einer bestimmten
 Scene, angehängt.
 Im Context wird wie im Composition Root die Registrierung von Typen beim
 Dependency Injection Container vorgenommen.
 Der Context definiert den Sichtbarkeitsbereich aller bei ihm registrierten
 Typen.
 Es jedoch auch möglich Registrierungen über mehrere Contexte hinweg vorzunehmen.
 StrangeIoC bezeichnet den Container als Binder und die Registrierung als
 Binding.
 Der Grund hierfür ist, dass nicht nur zu injekzierende Abhängigkeiten registrie
rt werden können.
 Es können auch, wie im später noch genauer erläutert wird, Commands an
 Signals und Views an Mediators gebunden werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleContext : MVCSContext
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void mapBindings()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.mapBindings();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IBoardLayoutModel>()
\end_layout

\begin_layout Plain Layout

			.To<BoardLayoutModel>().ToSingleton();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IMovementRules>().To<MovementRules>();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<FieldClickedSignal>().ToSingleton();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<StartSignal>().InSequence()
\end_layout

\begin_layout Plain Layout

			.To<LoadBoardLayoutCommand>()
\end_layout

\begin_layout Plain Layout

			.To<CreateBoardFieldViewsCommand>();
\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<FieldClickedSignal>()
\end_layout

\begin_layout Plain Layout

			.To<ToggleSelectionCommand>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		mediationBinder.Bind<FieldView>().To<FieldMediator>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override IContext Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.Start();
\end_layout

\begin_layout Plain Layout

		var startSignal = injectionBinder.GetInstance<StartSignal>();
\end_layout

\begin_layout Plain Layout

		startSignal.Dispatch();
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Contexts für ein Brettspiel
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Context"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-Context"

\end_inset

 zeigt ein Beispiel eines Contexts: In der mapBindings-Methode erfolgen
 die Typregistrierungen bei den jeweiligen Bindern.
 Abhängigkeiten werden beim InjectionBinder registriert, Commands werden
 über den CommandBinder an Signale gebunden und Views an Mediatoren durch
 den MediationBinder.
 Diese Registrierungen werden immer komplexer mit dem Wachstum der Anwendung.
 Aus diesem Grund können Sie auch in einzelne Klassen ausgelagert werden.
 Ist die Registrierung abgeschlossen, wird die Anwendung durch das Auslösen
 eines Signals in der Start-Methode gestartet.
 An dieses Startsignal wurden zuvor einige Commands gebunden, die nun ausgeführt
 werden.
\end_layout

\begin_layout Subsubsection
Signals
\end_layout

\begin_layout Standard
Signals stellen ein typsicheres Mittel zur Kommunikation zwischen den einzelen
 Architekturschichten dar.
 Signals können Commands auslösen, aber auch wie herkömmliche Events abonniert
 werden.
 Es handelt sich um eine Umsetzung des Observer-Musters, das intern Action-Deleg
aten anstatt Interfaces verwendet.
 Das Auslösen eines Signals erfolgt über die Dispatch-Methode.
 Wurde das Signal beim CommandBinder registriert, so fügt sich dieser als
 Listener hinzu.
 Beim Auslösen des Signals instanziiert der CommandBinder Instanzen der
 hinzugefügten Commands und führt diese aus.
 Damit sind Sender und Empfänger eines Signals komplett voneinander entkoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//Deklaration
\end_layout

\begin_layout Plain Layout

public class FieldClickedSignal : Signal<int>{};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Verwendung
\end_layout

\begin_layout Plain Layout

[Inject]
\end_layout

\begin_layout Plain Layout

public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clickSignal.Dispatch(12);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Deklaration und Verwendung eines Signals
\begin_inset CommandInset label
LatexCommand label
name "fig:Signals-Definition"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Signals-Definition"

\end_inset

 zeigt die Deklaration und Verwendung eines Signals.
 Signals können bis zu vier Parameter haben, dessen Typen als Generika bei
 der Deklaration des Signals definiert werden.
 Diese Parameter werden bei Aufruf in Properties des Commands injekziert.
 Signals sind Typsicher: Fehlerhaftes Aufrufen oder Abonnieren führt zu
 einer Ausnahme zur Laufzeit.
\end_layout

\begin_layout Subsubsection
Commands
\end_layout

\begin_layout Standard
Commands sind zustandslose Controller-Objekte, die ein einzelnes Verhalten
 kapseln.
 Commands werden von Signals ausgelöst: Ein Aufruf der Execute-Methode erfolgt
 automatisch.
 Im Normalfall haben sie eine sehr kurze Lebenszeit: Ein Signal löst die
 Instanziierung und Ausführung des Commands aus.
 Direkt danach erfolgt die Entsorgung.
 Commands bilden die Logik der Anwendung ab, indem sie Manipulationen an
 Models vornehmen, Spielobjekte instanziieren oder mit Services kommunizieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ToggleSelectionCommand : Command
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public int index { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IService service { get; set; } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void Execute()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Retain();
\end_layout

\begin_layout Plain Layout

		service.SendRequestToServer(response => {
\end_layout

\begin_layout Plain Layout

			//...
\end_layout

\begin_layout Plain Layout

			Release();
\end_layout

\begin_layout Plain Layout

		});
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für einen Command
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Command"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der an das Signal aus dem vorigen Beispiel gebundene Command, dargestellt.
 Der beim Auslösen des Signals übergebene Parameter wird bei Instanziierung
 des Commands in das Property 
\begin_inset Quotes gld
\end_inset

index
\begin_inset Quotes grd
\end_inset

 injekziert.
 Commands wird es durch Aufruf der Retain Methode ermöglicht, seine Zerstörung
 zu verzögern.
 Die Ausführung der Anwendung wird nicht eingeschränkt, da der Aufruf eines
 Commands asynchron erfolgt.
 Sehr nützlich ist Erhalten eines Commands beispielsweise bei der Client-Server-
Kommunikation: In dem gezeigten Beispiel in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der Command solange am Leben erhalten bis dieser eine Antwort vom
 Server erhält.
 Dies geschieht durch den Aufruf der Release-Methode im Callback der Anfrage.
\end_layout

\begin_layout Standard
Commands bieten eine sehr effiziente Möglichkeit Anwendungsschichten voneinander
 zu entkoppeln.
 Der Grund hierfür ist, dass sie sich nur durch Signale ausführen lassen:
 Es gibt für Models, Services und Mediatoren keinen Grund überhaupt von
 ihnen zu wissen.
 Models und Mediatoren brauchen lediglich Signale auszulösen um die Ausführung
 der Anwendung in Gang zu legen.
\end_layout

\begin_layout Subsubsection
Views
\end_layout

\begin_layout Standard
Wie bereits erwähnt sind Views oder View-Komponenten für die Darstellung
 der Benutzeroberfläche und der Verarbeitung von Interaktionen mit dem Benutzer
 verantwortlich.
 Dabei ist der Begriff 
\begin_inset Quotes gld
\end_inset

View
\begin_inset Quotes grd
\end_inset

 nicht unbedingt wörtlich zu nehmen: Sie übernehmen jegliche Ein- und Ausgabelog
ik, wie Rendering, Darstellungslogik von User Interfaces, Audioausgabe und
 eventuell Interaktion mit der Physikengine.
 Es sind Aufgaben, für die die Interaktion mit Unity notwendig ist.
 Aus diesem Grund sind Views MonoBehaviours.
 Sie beinhalten jedoch keinerlei Anwendungslogik und kommunizieren lediglich
 zu ihren Mediatoren über Events.
 Ansonsten sind sie komplett autonome Komponenten, die ausschließlich ihren
 eigenen Zustand manipulieren können.
 Aus diesem Grund sollten auch keine Injections in MonoBehaviours vorgenommen
 werden.
 Die Absicht hierbei ist, das Unity-Framework soweit wie möglich aus der
 Anwendungslogik rauszuhalten, um eine enge Kopplung zu diesem zu verhindern.
\end_layout

\begin_layout Subsubsection
Mediation
\end_layout

\begin_layout Standard
Das Mediator-Muster beschreibt einen Weg der Interaktion zwischen Objekten
 über einen Vermittler
\begin_inset CommandInset citation
LatexCommand citep
after "S. 273"
before "vgl."
key "Gamma1994"

\end_inset

.
 In StrangeIoC vermitteln Mediatoren zwischen View- und Anwendungslogik.
 Mediatoren interagieren im Auftrag ihres Views mit dem Rest des Frameworks
 und anders herum.
 Dies geschieht, indem der Mediator die Events seines Views abbonniert und
 daraufhin entsprechende Signals auslöst.
 Umgekehrt abonniert der Mediator auch die Events von Services oder Models
 und führt daraufin entsprechende Operationen an seinem View aus.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/strange_mediation.png
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild zur Verdeutlichung des Mediation-Prozesses
\begin_inset CommandInset label
LatexCommand label
name "fig:Schaubild-Mediation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Schaubild-Mediation"

\end_inset

 wird veranschaulicht wie der Mediation-Prozess in StrangeIoC vonstatten
 geht: Sobald ein View in eine Scene geladen wird, sendet dieser automatisch
 in der Awake-Methode eine Message an den ContextView.
 Dafür muss zwangsläufig jeder View ein Childobject des jeweiligen ContextViews
 sein.
 Über den Context des ContextViews wird der MediationBinder aufgerufen.
 Dieser instanziiert einen zuvor an den View gebundenen Mediator und versorgt
 ihn mit seinen Abhängigkeiten mithilfe des Injectors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleMediator : Mediator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleView view { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IBoardLayoutModel layout { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public override void OnRegister()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.AddListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.AddListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void OnRemove()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.RemoveListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.RemoveListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private void OnClick(Vector2 clickPosition)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var index = ClickPositionToFieldIndex(clickPosition);
\end_layout

\begin_layout Plain Layout

		clickSignal.Dispatch(index);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnLayoutChange()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.Refresh();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Implementation eines Mediators
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Mediator"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Mediator"

\end_inset

 wird ein Beispiel für eine mögliche Implementation eines Mediators gezeigt.
 Der Mediator reagiert auf das OnBoardClicked-Event des Views indem er die
 Klickposition in einen verwendbaren Index konvertiert und daraufhin ein
 FieldClickedSignal mit dem Index als Parameter auslöst.
 Weiter abonniert der Mediator das OnLayoutChanged-Event des IBoardLayoutModels.
 In Reaktion auf dieses Event ruft der Mediator die Refresh-Methode des
 von ihm vermittelten Views auf.
 Das An- und Abmelden an die Events erfolgt in den OnRegister- und OnRemove-Call
backs.
 OnRegister wird direkt nach der Injection von Abhängigkeiten aufgerufen.
 Der Aufruf von OnRemove erfolgt beim Zerstören des Views.
\end_layout

\begin_layout Standard
Wie im Beispiel deutlich wird, agieren Mediators lediglich als Brücke zwischen
 Darstellungs- und Anwendungslogik.
 Sie sollten somit leichtgewichtig sein und möglichst keine eigene Logik
 beinhalten.
 Sie dienen einzig dazu Anwendungslogik aus den Views herauszuhalten.
 Dafür gibt es zahlreiche Gründe: Darstellungslogik tendiert dazu mit der
 Zeit unüberschaubar zu werden, da an ihr oft Änderungen in letzter Minute
 vorgenommen werden.
 Weiter verwendet die Darstellungslogik eines Views die API von Unity, die
 durch statische Klassen und fehlendem Interfacesupport zu enger Kopplung
 und damit zu eingeschränkter Testbarkeit führt.
\end_layout

\begin_layout Subsubsection
Models und Services
\end_layout

\begin_layout Standard
Die Aufgaben eines Models in StrangeIoC unterscheiden sich nicht von denen
 eines Models in einer klassischen MVC-Architektur.
 Models kapseln Zustand und Daten der Anwendung und ermöglichen den Zugriff
 auf diese über wohldefinierte Schnittstellen.
 Andere Klassen können über diese Schnittstellen Anfragen an das Model senden.
 Models selber senden keine Anfragen: Wird ein Model geändert, lässt es
 dies den Rest der Anwendung wissen indem es einen Event auslöst.
\end_layout

\begin_layout Standard
Services stehen eng mit Models in Verbindung.
 Dennoch sollten sie getrennt voneinander existieren.
 Ein Service beschafft - oft durch die Kommunikation zur Außenwelt - Daten.
 Ein Model speichert diese Daten.
 Services kommunizieren mit externen Ressourcen einer Applikation.
 Beispiele für solche Resourcen sind unter anderem: Webserver und -Services,
 das Dateisystem und Datenbanken.
 Der Zugriff aus Services erfolgt über Commands, wie bereits in Abbildung
 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Beispiel-Command"

\end_inset

 gezeigt.
 
\end_layout

\begin_layout Subsection
Beispielanwendung
\end_layout

\begin_layout Standard
Die im letzten Abschnitt gezeigten Abbildungen wurden aus einer für diese
 Arbeit programmierten Beispielanwendung übernommen.
 Damit der Fokus auf die zu erläuternden Konzepte nicht verloren geht, wurden
 die Klassen für die Beispiele teilweise gekürzt und abgeändert.
 Die tatsächliche Implementation der Beispielanwendung ist auf der sich
 im Anhang dieser Arbeit befindlichen CD zu finden.
\end_layout

\begin_layout Standard
Es handelt sich um eine Implementation des Brettspiels Peg Solitaire.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern oder weglassen!}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Kritische Betrachtung & Fazit
\end_layout

\begin_layout Section
Fazit zur Kopplung in Unity
\end_layout

\begin_layout Section
Fazit zur Anwendbarkeit von Dependency Injection in Unity
\end_layout

\begin_layout Subsection
Fazit zu StrangeIoC
\end_layout

\begin_layout Section
Alternative Architekturen
\end_layout

\begin_layout Section
Aussicht
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ab hier folgt nun der Glossar.
 Manchmal ist das nicht nötig, dann muss es auch unter Dokumente --> Einstellung
en --> Latex-Vorspann deaktivieren.
 Übrigens werden Lyx-Notizen im späteren Dokument nicht angezeigt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout

% Die folgende Zeile sorgt dafuer, dass der Glossar im Inhaltsverzeichnis
 angezeigt wird.
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Glossar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Single Responsibility Principle"
description "Eine Klasse soll nur eine Verantowrtlichkeit haben."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Open Closed Principle"
description "Eine Klasse soll offen für Erweiterung, jedoch geschlossen für Modifikation sein."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Liskov Subsitituion Principle"
description "Abgeleite Klassen sollen sich so verhalten wie der Basistyp es von ihnen erwartet."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Interface Segregation Principle"
description "Interfaces sollen nur die Funktionalität wiederspiegeln die ihre Klienten erwarten."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Dependency Inversion Principle"
description "High-Level Klassen sollen nicht von Low-Level Klassen abhängig sein, sondern beide von Interfaces. Interfaces sollen nicht von Details abhängig sein sondern Details von Interfaces"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "auto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Begriffe Einfügen: Stub, Mock, Fake, }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier folgt nun das Literaturverzeichnis.
 Die benötigten Dateien liegen im Verzeichnis: bibtex-daten
\end_layout

\begin_layout Plain Layout
Dieses wird automatisch erstellt.
 Zum bearbeiten der 
\begin_inset Quotes gld
\end_inset

Literatur-Datenbank
\begin_inset Quotes grd
\end_inset

 verwende ich das Programm 
\begin_inset Quotes gld
\end_inset

JabRef
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex-daten/bachelorarbeit-info"
options "bibtotoc,natdin"

\end_inset


\end_layout

\end_body
\end_document
