#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\captionsetup[table]{skip=10pt}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
\usepackage{lmodern}
\usepackage[scaled=0.92]{helvet}
\usepackage{mathptmx}
\usepackage{courier}

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{roman}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
\addto\captionsngerman{ 
\renewcommand{\figurename}{Abb.}% 
\renewcommand{\tablename}{Tab.}% 
\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}

%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
\usepackage{color}
\usepackage{listings}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
%xleftmargin = 15pt,
%frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\footnotesize,
backgroundcolor = \color{background},
tabsize=4,
}
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
todonotes
\end_modules
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 92
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Inversion of Control in Unity3D"
\pdf_author "Ludwig Lauer"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/hs-harz-logo.eps
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size larger
Bachelorarbeit
\end_layout

\begin_layout Standard
\noindent
\align left

\size large
Inversion Of Control in Unity3D
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eingereicht von:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrikelnummer: m18711
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fachbereich Automatisierung und Informatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Studiengang Medieninformatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erstprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Daniel Ackermann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zweitprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Ph.
 D.
 Jürgen K.
 Singer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Eidesstattliche Erklärung
\end_layout

\begin_layout Standard
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst
 und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.
 Alle Ausführungen, die anderen veröffentlichten oder nicht veröffentlichten
 Schriften wörtlich oder sinngemäß entnommen wurden, habe ich kenntlich
 gemacht.
\end_layout

\begin_layout Standard
Die Arbeit hat in gleicher oder ähnlicher Fassung noch keiner anderen Prüfungsbe
hörde vorgelegen.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Sperrvermerk
\end_layout

\begin_layout Standard
Die vorliegende Bachelorarbeit enthält vertrauliche Informationen der Firma
 Wooga GmbH, die der Geheimhaltung unterliegen.
 Veröffentlichungen oder Vervielfältigungen der Bachelorarbeit - auch nur
 auszugsweise - sind ohne ausdrückliche Genehmigung der Firma Wooga GmbH
 nicht gestattet.
 Die Bachelorarbeit ist nur den Mitarbeitern des betreuenden Lehrstuhls
 sowie den Mitgliedern des Prüfungsausschusses zugänglich zu machen.
 Alle Rechte zum Erwerb und zur Anmeldung gewerblicher Schutzrechte, insbesonder
e zur Anmeldung von Patenten, Gebrauchsmustern und/oder Geschmacksmustern
 sind der Firma Wooga GmbH vorbehalten.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Exposé
\end_layout

\begin_layout Standard
Unity3D hat sich in den letzten Jahren als Spieleengine etabliert.
 Immer größere und ambitioniertere Projekte werden mit der Engine umgesetzt.
 Da Unity als Rapid Prototyping Tool für unabhängige Spieleentwickler konzipiert
 wurde, fällt die parallele Entwicklung in mittleren bis großen Teams schwer.
 Eine der Ursachen dieses Problems ist die enge Kopplung von Abhängigkeiten
 zwischen Objekten.
 Die Folgen sind Starrheit und Zerbrechlichkeit bei Veränderung des Programmcode
s.
\end_layout

\begin_layout Standard
In der objektorientierten Programmierung gilt Inversion Of Control als Maßnahme
 um lose Kopplung zu erzielen.
 In dieser Arbeit soll untersucht werden, ob sich das Paradigma auch in
 der komponentenbasierten Architektur von Unity3D anwenden lässt.
 Dafür soll das Framework StrangeIoC herangezogen und genauer betrachtet
 werden.
 Mit Features wie Automated Dependency Injection, eigenem Eventsystem und
 einer MVC(S) Architektur sollen die Qualität, Testbarkeit, Skalierbarkeit
 und Wartbarkeit der Anwendung erhöht werden.
\end_layout

\begin_layout Standard
Ziel der Bachelorarbeit ist folglich das Erstellen einer lose gekoppelten
 Beispielanwendung in Unity3D unter Verwendung von StrangeIoC.
 Zudem soll untersucht werden, welche Praktiken die Ursache von enger Kopplung
 in Unity3D sind, welche Folgen diese haben und wie diese mit Inversion
 Of Control, Dependency Injection und StrangeIoC im speziellen, vermeidbar
 sind.
\end_layout

\begin_layout Standard
Die Bachelorarbeit beinhaltet folgende Teilaufgaben:
\end_layout

\begin_layout Itemize
Analyse von Ursachen und Folgen enger Kopplung zwischen Objekten in Unity3D
\end_layout

\begin_layout Itemize
Auseinandersetzung mit den Paradigmen Inversion Of Control und Dependency
 Injection
\end_layout

\begin_layout Itemize
Entwicklung einer Beispielanwendung mit StrangeIoC mit dem Ziel lose Kopplung
 unter Objekten umzusetzen
\end_layout

\begin_layout Itemize
Kritische Betrachtung von Entwicklungsaufwand, Qualität, Testbarkeit, Skalierbar
keit und Wartbarkeit im Vergleich mit anderen Architekturansätzen 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ACHTUNG: Hier am Ende noch die richtige Seite einstellen! Sonst passt die
 Nummerierung nicht!
\end_layout

\begin_layout Plain Layout
!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Unity hat sich in den letzten Jahren zur einer der führenden Spieleengines
 entwickelt.
 Mit über 45% des globalen Marktanteils unter Spieleengines
\begin_inset Foot
status open

\begin_layout Plain Layout
http://unity3d.com/public-relations
\end_layout

\end_inset

 trägt Unity maßgeblich an dem Independent Videogame Boom der letzten Jahre
 bei.
 Unity ermöglicht die plattformunabhägige Erstellung von 2D und 3D Spielen.
 Dies hat besonders auf dem fragmentierten Markt der mobilen Spieleindustrie
 Anklang gefunden.
 Mit sich fortlaufend verbessernder Performance und Rendertechniken sind
 immer ambitioniertere Projekte möglich.
 Dies bewegt nicht nur Indieentwickler und kleine Teams dazu, sich die Vorteile
 der Engine zunutze zu machen: Unity findet immer mehr Einzug in professionelle
 Spieleprojekte mit mittleren und großen Teams.
 Hier sind Tätigkeitsbereiche spezialisiert und klar definiert.
 Die Anforderungen an die Spieleengine beginnen sich zu wandeln: Parallele
 Entwicklung muss gewährleistet werden.
 Der Programmcode muss modular, skalierbar und wiederverwendbar sein.
 Es darf keinen Raum für Fehlkonfigurationen geben.
 Neue Geschäftsmodelle wie Free-to-Play bewirken, dass Spiele immer mehr
 zur Dienstleistung werden.
 Sie müssen über mehrere Jahre hinweg wartbar und erweiterbar bleiben.
\end_layout

\begin_layout Standard
Schaut man sich auf den zahlreichen Websites, Blogs und Foren über Unity
 um, scheinen diese Anforderungen Unity's Schwachstelle zu sein: Frustration
 und Beschwerden über entstehenden Spaghetti-Code
\begin_inset Foot
status open

\begin_layout Plain Layout
https://np.reddit.com/r/gamedev/comments/3hr8al/coming_from_a_net_programming_back
ground_unitys/
\end_layout

\end_inset

, Kritik an der Komponentenbasierten Architektur
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.unityninjas.com/code-architecture/unity3d-game-code-architecture/
\end_layout

\end_inset

, Fehlende Testbarkeit
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.mikecann.co.uk/games/taming-unity/
\end_layout

\end_inset

 und Aussagen, dass Unity nur als Rapid Prototyping Tool tauglich ist und
 Kollaboration in großen Teams kaum möglich ist.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.namekdev.net/2014/06/why-i-hate-unity3d-popularity/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oft sollen die Ursachen gerade die Dinge sein, die unerfahrenen Programmierern
 den einfachen Umgang mit Unity ermöglichen.
 Unter diesen Ursachen ist eine Sache so gut wie immer vertreten: Die Auflösung
 von Abhängigkeiten und Kommunikation zwischen Objekten.
 Enge Kopplung von Abhängigkeiten zwischen Objekten führt zu Starrheit und
 Zerbrechlichkeit bei Veränderung des Programmcodes.
 In der objektorientierten Programmierung ist dieses Problem seit langem
 bekannt.
 Es existieren zahlreiche Lösungen für die unterschiedlichsten Situationen
 und Entwicklungsumgebungen.
 Oft sind diese Lösungen Frameworks, die eng mit den Begriffen Inversion
 Of Control und Dependency Injection in Verbindung stehen.
\end_layout

\begin_layout Standard
Nun implementiert Unity keine klassische objektorientierte Hierarchie, sondern
 eine komponentenbasierte Architektur.
 Trotzdem haben auch für Unity eine Handvoll Inversion of Control Frameworks
 das Licht der Welt erblickt.
 
\end_layout

\begin_layout Section
Zielsetzung
\end_layout

\begin_layout Standard
In dieser Arbeit wird sich auf ein Problem beschränkt: Die Kopplung von
 Abhängigkeiten zwischen Modulen in Unity.
 Ziel dieser Arbeit ist es die Umsetzung von Spielen in Unity zu ermöglichen,
 ohne dessen Module eng miteinander zu koppeln.
\end_layout

\begin_layout Standard
Zunächst soll die Problematik der Kopplung beschrieben werden.
 Vorraussetzung dafür ist, zu erläutern, was Abhängigkeiten sind und warum
 Sie entstehen.
 Weiter sollen auch die Folgen von enger Kopplung erläutert werden.
 Dabei soll klar werden, dass Kopplung direkten Einfluss auf die Erweiterbarkeit
 des Programmcodes hat.
 
\end_layout

\begin_layout Standard
Weiter soll anhand eines Beispiels erklärt werden, wie lose Kopplung mittels
 Dependency Injection umzusetzen ist.
 In diesem Zusammenhang sollen auch zugrunde liegende Prinzipien erläutert
 werden.
\end_layout

\begin_layout Standard
Infolgedessen soll der Schritt zu Unity getätigt werden.
 Es soll untersucht werden inwiefern Unity von einer herkömmlichten objektorient
ierten Hierarchie abweicht und ob dies hinderlich dabei ist, lose Kopplung
 umzusetzen.
 Es sollen häufig verwendete Praktiken wie das Singleton-Pattern und Managerobje
kte untersucht werden.
 Wie später im Detail erklärt wird, entstehen Abhängigkeiten unter anderem
 dadurch, dass Objekte miteinander kommunizieren müssen.
 Unity stellt unterschiedliche Wege der Kommunikation bereit.
 Es soll untersucht werden, ob diese Wege es bereits ermöglichen lose Kopplung
 umzusetzen.
 Auf Basis dieser Erkenntnisse soll ein Zwischenfazit gezogen werden, um
 die Notwendigkeit eines Inversion Of Control Frameworks für Unity zu verdeutlic
hen.
\end_layout

\begin_layout Standard
Im nächsten Teil dieser Arbeit soll ein Inversion Of Control Container für
 Unity implementiert werden.
 Dieser Container soll Dependency Injection in MonoBehaviours automatisieren
 und somit die lose Kopplung von Komponenten ermöglichen.
 Die technische Umsetzung soll erläutert werden.
 Mit Unity in Verbinung stehende Hürden bei der Umsetzung sollen überwunden
 und beschrieben werden.
 Weiter soll ein Überblick über die vorhandenen Inversion Of Control Frameworks
 für Unity geliefert werden.
 Besonderheiten, Funktionsweise und -Umfang sollen beschrieben werden.
 Besondere Betrachtung soll StrangeIoC finden: Die Frameworkeigene MVC(S)-Archit
ektur und die damit verbundenen Muster und Praktiken sollen anhand von Beispiele
n beschrieben werden.
\end_layout

\begin_layout Standard
Auf Basis dieser Analysen soll eine Aussage über die Tauglichkeit von Inversion
 Of Control Frameworks in der komponentenbasierten Architektur von Unity
 getroffen werden.
 Im Speziellen soll ein Fazit über die MVC(S)-Architektur von StrangeIoC
 zur Entwicklung von Spielen in Unity gezogen werden.
 Es soll entschieden werden, für welche Anwendungsgebiete die Architektur
 besonders geeignet ist und für welche nicht.
 Für diese Anwendungsgebiete sollen alternative Architekturansätze in Aussicht
 gestellt werden.
 
\end_layout

\begin_layout Section
Aufbau der Arbeit
\end_layout

\begin_layout Standard
Brauche ich das hier?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Stichpunkte Ausformulieren!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Teil 1
\end_layout

\begin_layout Itemize
Grundlagen: Abhängigkeiten, Kopplung, Kohäsion, Dependency Injection, SOLID
\end_layout

\begin_layout Itemize
Beispielhafte Umsetzung DI
\end_layout

\begin_layout Itemize
Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
Teil 2
\end_layout

\begin_layout Itemize
Analyse von Unity
\end_layout

\begin_layout Itemize
Architektur und Kommunikationsmittel
\end_layout

\begin_layout Itemize
Wertung: Notwendigkeit von DI
\end_layout

\begin_layout Standard
Teil 3
\end_layout

\begin_layout Itemize
Implementation Inversion Of Control Container für Unity
\end_layout

\begin_layout Itemize
Existierende Inversion Of Control Frameworks in Unity
\end_layout

\begin_layout Itemize
MVC(S) in StrangeIoC
\end_layout

\begin_layout Standard
Teil 5 
\end_layout

\begin_layout Itemize
Kritische Betrachtung DI
\end_layout

\begin_layout Itemize
Anwendungsgebiete MVC(S) von StrangeIoC
\end_layout

\begin_layout Itemize
Alternative Architekturansätze
\end_layout

\begin_layout Itemize
Fazit
\end_layout

\begin_layout Chapter
Grundlagen
\end_layout

\begin_layout Standard
Geringe Kopplung unter Softwareentitäten (Modulen, Klassen, Methoden) wird
 als Indiz für gute Softwarearchitektur angesehen.
 Inversion Of Control und genauer Dependency Injection sind Werkzeuge, die
 dabei helfen sollen, lose Kopplung umzusetzen.
 In diesem Teil der Arbeit soll zunächst erläutert werden, was Kopplung
 zwischen Entitäten ist und wie diese Zustande kommt.
 Es soll klar werden, warum hohe Kohäsion unter minimaler Kopplung anzustreben
 ist.
 Die Vorteile loser Kopplung sollen deutlich gemacht werden.
 Inversion Of Control, Dependency Injection und die eng mit diesen Begriffen
 SOLID-Prinzipien sollen beschrieben werden.
 Zum besseren Verständnis der vorgestellten Prinzipien, Muster und Praktiken
 soll lose Kopplung anhand eines Beispiels in einer Konsolenanwendung umgesetzt
 werden.
\end_layout

\begin_layout Section
Kopplung und Kohäsion
\end_layout

\begin_layout Standard
Kopplung ist ein Maß, das die Anzahl und Stärke von Abhängigkeiten unter
 Softwareentitäten einer Anwendung beschreibt.
\begin_inset CommandInset citation
LatexCommand cite
after "S. 2-3"
key "Society2014"

\end_inset

 Ist eine Softwareentität direkt von der Implementation einer anderen Entität
 abhängig, so sind diese eng miteinander gekoppelt.
 Ziel ist es, die Anzahl und Stärke von Abhängigkeiten zu minimieren und
 so lose Kopplung umzusetzen.
 Martin Fowler beschreibt in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2001"

\end_inset

 Kopplung wie folgt:
\end_layout

\begin_layout Verse
\begin_inset Quotes gld
\end_inset

If changing one module in a program requires changing another module, then
 coupling exists.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Eine Abhänigigkeit zwischen Entitäten entsteht, sobald eine Entität von
 der anderen wissen muss um zu funktionieren.
 Abhängigkeiten können unterschiedliche Stärken und Ausprägungen haben.
 Je größer das Wissen über eine andere Entität ist, desto stärker ist die
 Abhängigkeit zu ihr.
 Muss also eine Entität von der konkreten Implementation einer anderen Entität
 wissen, so existiert eine starke Abhängigkeit und folglich eine enge Kopplung.
 Wird sich hingegen auf eine Schnittstelle zur Kommunikation geeinigt, existiert
 lediglich eine Abhängigkeit zu eben dieser Schnittstelle.
 Die Entitäten selbst sind lose miteinander gekoppelt.
\end_layout

\begin_layout Standard
Kopplung steht im Kontrast zu dem Begriff der Kohäsion.
 Kohäsion beschreibt ein Maß für den inneren Zusammenhalt einer Softwareentität.
 Hohe Kohäsion liegt dann vor, wenn eine Entität nur Funktionalitäten aufweist,
 die einer einzelnen, wohldefinierten Aufgabe dienen.
 In anderen Worten: Eine Entität weist eine hohe Kohäsion auf, wenn ihre
 Elemente in einem engen Zusammenhang stehen.
\end_layout

\begin_layout Standard
Kohäsion beschreibt wie gut Entitäten aufgeteilt wurden.
 Kopplung beschreibt wie gut die Verbindungen zwischen Entitäten sind.
 Ein qualitativ hochwertiges Softwaredesign weist also hohe Kohäsion unter
 minimaler Kopplung auf.
 Im nächsten Abschnitt soll Inversion Of Control als Maßnahme präsentiert
 werden um lose Kopplung umzusetzen.
\end_layout

\begin_layout Section
Inversion of Control
\begin_inset CommandInset label
LatexCommand label
name "sec:Inversion-of-Control"

\end_inset


\end_layout

\begin_layout Standard
Im ursprünglichen Sinne beschreibt Inversion Of Control nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson1988"

\end_inset

 lediglich die Charakteristik eines Frameworks: 
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

[...] methods defined by the user to tailor the framework will often be called
 from within the framework itself, rather than from the user's application
 code.
 The framework often plays the role of the main program in coordinating
 and sequencing application activity.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Frameworks diktieren die Architektur und den Kontrollfluss einer Anwendung.
 Sie definieren einen wiederverwendbaren Teil eines Softwaredesigns.
 Der vom Nutzer des Frameworks geschriebene, anwendungsspeziefische Code
 wird vom Framework aufgerufen.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 27"
key "Gamma1994"

\end_inset

) Der Nutzer gibt also die Kontrolle über den Fluss der Anwendung an das
 Framework.
 Die Kontrolle über den Anwendungsfluss ist somit invertiert: Es ist nicht
 der Nutzer der das Framework aufruft sondern das Framework den Code des
 Nutzers.
 Diese Tatsache wird oft als Hollywood-Prinzip bezeichnet: "Don't call us,
 we'll call you".
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2005"

\end_inset

)
\end_layout

\begin_layout Standard
Inversion Of Control ist eines der zentralen Merkmale welches Frameworks
 von Bibliotheken unterscheidet.
 Allein Inversion Of Control ermöglicht die Definition einer wiederverwendbaren
 Softwarearchitektur ohne die konkrete Implementation zu kennen.
 Das Framework ist lose mit der Implementation der eigentlichen Anwendung
 gekoppelt.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Wege und Entwurfsmuster um Inversion Of Control in unterschie
dlichen Aspekten einer Anwendung umzusetzen.
 In dieser Arbeit soll der Fokus auf der Umkehr der Kontrolle über Abhängikeiten
 liegen, mit dem Ziel lose Kopplung zu ermöglichen.
 Um diese spezielle Art von Inversion Of Control besser abzugrenzen, verwendet
 Fowler in seinem Artikel 
\begin_inset Quotes gld
\end_inset

Inversion of Control Containers and the Dependency Injection pattern
\begin_inset Quotes grd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2004"

\end_inset

 den Begriff Dependency Injection.
\end_layout

\begin_layout Section
Dependency Injection
\end_layout

\begin_layout Standard
Seemann gibt in 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 4"
key "Seemann2011"

\end_inset

 eine sehr vage Definitition des Begriffs Dependency Injection:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency Injection is a set of software design principles and patterns
 that enable us to develop loosely coupled code.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Wobei alles an dieser Aussage stimmt, lässt sich der Kern von Dependency
 Injection auf eine einzige Praktik reduzieren.
 James Shore beschreibt diese in 
\begin_inset CommandInset citation
LatexCommand cite
key "Shore2006"

\end_inset

 wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency injection means giving an object its instance variables.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Anstatt, dass sich das Objekt selbst um die Erstellung seiner Abhängigkeiten
 - seiner Intanzvariablen - kümmert, wird diese Aufgabe an einen Dritten
 übergeben.
 Die Verwendung des benötigten Objekts ist von der Konfiguration des Objekts
 getrennt.
 
\end_layout

\begin_layout Standard
Doch dies allein genügt noch nicht: Um lose Kopplung mittels Dependency
 Injection zu ermöglichen, müssen zudem eine Reihe von Prinzipien gewahrt
 werden.
 Diese wurden von Robert C.
 Martin geprägt und sind im allgemeinen als SOLID-Prinzipien bekannt.
\end_layout

\begin_layout Section
SOLID
\end_layout

\begin_layout Standard
SOLID ist ein Akronym, welches für die folgenden Prinzipien steht: Das Single-Re
sponsibility Prinzip, das Open/Closed Prinzip, das Liskov Substitution Prinzip,
 das Interface Segregation Prinzip und das Dependency-Inversion Prinzip.
 Es handelt sich um eine Sammlung von Richtlinien, die eine saubere Softwarearch
itektur ermöglichen sollen.
 An dieser Stelle wird auf eine ausführliche Beschreibung aller Prinzipien
 verzichtet.
 Es soll jedoch eine kurze Vorstellung der Prinzipien stattfinden und auf
 ihre Relevanz bei der Umsetzung von Dependency Injection eingegangen werden.
\end_layout

\begin_layout Subsection
Single-Responsibility Prinzip
\end_layout

\begin_layout Standard
Das Single-Responsibility Prinzip besagt, dass es niemals mehr als einen
 Grund geben sollte um eine Klasse zu ändern.
 Darauf Folgend wird eine Verantwortung in dem Zusammenhang als ein 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 definiert.
 Jedoch wurde 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 bewusst gewählt, da es auch legitim ist mehrere Verantwortlichkeiten in
 einer Klasse unterzubringen, wenn diese sich mit hoher Wahrscheinlichkeit
 gemeinsam ändern.
\end_layout

\begin_layout Standard
Wird das Single-Responsibility Prinzip gewahrt, so ist davon auszugehen,
 dass Klassen hohe Kohäsion aufweisen.
 Hohe Kohäsion ist jedoch nicht immer auf das Single-Responsibility Prinzip
 zurückzuführen.
 So kann eine Klasse hohe Kohäsion aufweisen, aber trotzdem mehrere Verantwortun
gen haben.
\end_layout

\begin_layout Standard
Dependency Injection wendet das Single-Responsibility Prinzip an, indem
 Klassen die Verantwortung über die Erstellung von Instanzen ihrer Abhängigkeite
n entzieht.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 24"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Open/Closed Prinzip
\end_layout

\begin_layout Standard
Software-Einheiten (Klassen, Methoden, Funktionen) sollen offen für Erweiterung
 aber geschlossen für Modifikation sein.
 
\begin_inset Quotes gld
\end_inset

Offen für Erweiterung
\begin_inset Quotes grd
\end_inset

 meint, dass es möglich sein soll, das Modul in seinem Umfang und Verhalten
 zu erweitern.
 
\begin_inset Quotes gld
\end_inset

Geschlossen für Modifikation
\begin_inset Quotes grd
\end_inset

 zum anderen bedeutet, dass zur Erweiterung keine Änderungen an dem Modul
 notwendig sind.
\end_layout

\begin_layout Standard
Abstraktion ermöglicht die Umsetzung des Open/Closed Prinzips.
 Wird von einer abstrakten Basisklasse geerbt, so ist es möglich das Verhalten
 der Abstraktion zu ändern, ohne die Abstraktion selbst zu manipulieren.
 Die Entwurfsmuster Strategy und Template Method sind Beispiele für das
 Open/Closed Prinzip.
\end_layout

\begin_layout Standard
Auch Dependency Injection setzt das Open/Closed Prinzip um, indem Abhängigkeiten
 lediglich in Form von Abstraktionen existieren.
 Dieses Prinzip ist eine Grundlage für lose Kopplung.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 106"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Liskov Substitution Prinzip
\end_layout

\begin_layout Standard
Das Liskov Substitution Prinzip beschreibt einer grundlegende Anforderung
 beim Einsatz von Vererbung: Untertypen einer Basisklasse sollen untereinander
 ersetzbar sein, ohne dabei die Verhalten des Programms selbst zu verändern.
 Das Programm selbst darf zu keinem Zeitpunkt einen Untertyp anders als
 ein anderen behandelt.
\end_layout

\begin_layout Standard
Dependency Injection ermöglicht es, dass Abhängigkeiten beliebig austauschbar
 sind, solange sie die nötige Abstraktion implementieren.
 Dies ist jedoch nur möglich, wenn das Liskov Substitution Prinzip gewahrt
 wird.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 9-10"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
Dieses Prinzip kommt besonders beim Unit-Testing zum Vorschein: Abhängigkeiten
 eines System Under Test können durch Test Doubles ersetzt werden, ohne
 das Verhalten des Systems selbst zu verändern.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S.19"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Interface Segregation Prinzip
\end_layout

\begin_layout Standard
Anstatt große (
\begin_inset Quotes gld
\end_inset

fat
\begin_inset Quotes grd
\end_inset

) Interfaces zu nutzen, sollten diese in mehrere schlanke Interfaces aufgeteilt
 werden.
 Die Aufteilung soll nach Methodengruppen erfolgen, entsprechend wie sie
 von Modulen, die das Interface nutzen gebraucht werden.
 So wird gewährleistet, dass andere Module nur von Abstraktionen mit hoher
 Interfacekohäsion abhängig sind.
 Auch wenn diese Abstraktionen von einem einzigen nicht-kohäsiven Modul
 implementiert werden.
\end_layout

\begin_layout Standard
Das Interface Segregation Prinzip scheint zunächst nicht mit Dependency
 Injection im Zusammenhang zu stehen.
 Es ist eher eine Richtlinie die bei der Anwendung von Dependency Injection
 gewahrt werden sollte.
 Wird eine Abhängigkeit von einem einzigen großen Interface repräsentiert,
 lenkt dieses Interface in die Richtung einer konkreten Implementation.
 Die Folge ist, dass Abhängigkeiten schwieriger auszutauschen sind und Interface
methoden implementieren, die sie eigentlich gar nicht benötigen um die Abhängigk
eit zu erfüllen.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 284"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Dependency-Inversion Prinzip
\end_layout

\begin_layout Standard
Das Dependency-Inversion Prinzip besteht aus zwei Teilen:
\end_layout

\begin_layout Itemize
High-Level Module sollen nicht von Low-Level Modulen abhängig sein.
 Beide sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Itemize
Abstraktionen sollten nicht von Details abhängen.
 Details sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Standard
Zum einen beschreibt das Dependency-Inversion Prinzip, dass die Architektur
 einer Anwendung in Schichten erfolgen sollte.
 Dabei soll die abstraktere, höher liegende Schicht ihre Abhängigkeiten
 in Form von Interfaces deklarieren.
 Die ihr untergeordnete Schicht wird basierend auf diesen Interfaces realisiert.
 Folglich sind die übergeordnete Schichten nicht von untergeordneten Schichten
 abhängig.
 Stattdessen sind untergeordnete Schichten von den abstrakten Interfaces
 in den übergeordneten Schichten abhängig.
 
\end_layout

\begin_layout Standard
Zum anderen beschreibt Martin eine weitere, allgemeinere Interpretation
 des Dependency-Inversion Prinzips:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Depend on abstractions.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
So sollen Klassen keine Referenzen zu anderen konkreten Klassen halten,
 von ihnen ableiten oder Methoden ihrer Basisklasse überschreiben.
 Diese Praxis wurde bereits von der Gang of Four in 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 17-18"
key "Gamma1994"

\end_inset

 mit folgenden Worten beschrieben:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Program to an interface, not an implementation.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Die Deklaration von Abhängigkeiten in Form von Abstraktionen ist die Grundlage
 um Inversion Of Control mittels Dependency Injection umzusetzen.
 Späte Bindung ermöglicht es, dass die konkrete Implementation auf diesem
 Wege erst zur Laufzeit bekannt sein muss.
\end_layout

\begin_layout Section
Umsetzung von Dependency Injection
\end_layout

\begin_layout Standard
Um zu erläutern wie die in den vorherigen Abschnitten erklärten Prinzipien
 bei der Umsetzung von Inversion of Control mittels Dependency Injection
 zusammenspielen, soll ein Beispiel herangezogen werden.
 Anhand dieses Beispiels sollen Patterns die im direkten Zusammenhang zu
 Dependency Injection stehen, beschrieben werden.
 Um das Beispiel so einfach wie möglich zu halten, wird hierfür eine Konsolenanw
endung in C# gewählt.
\end_layout

\begin_layout Subsection
Ausgangssituation
\end_layout

\begin_layout Standard
Eine gewünschte Funktionalität eines zu entwickelnden Spiels ist auszugeben,
 dass eine verwundbare Entität schaden genommen hat.
 Die in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Ausgangssituation"

\end_inset

 dargestellte Klasse DamageRenderer setzt diese Funktionalität um.
 Zunächst scheint alles zu stimmen: Die Klasse beschränkt ihre Verantwortung
 auf eine einzige Funktionalität, formatiert die Information in ein lesbares
 Format und gibt diese in der Konsole aus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format("{0} was attacked and took {1} damage.", target,
 damage);         		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausgangssituation des Beispiels
\begin_inset CommandInset label
LatexCommand label
name "fig:Ausgangssituation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Neue Anforderungen
\end_layout

\begin_layout Standard
Im Verlauf der Entwicklung des Spieles wird klar, dass das Spiel in verschiedene
n Sprachen veröffentlicht werden soll.
 Lokalisierung ist eine gängige Anforderung für jegliche Art von Software.
 Es wird mit dem Refactoring begonnen und die Klasse EnglishLocalization
 extrahiert.
 Abbildung
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Extraction"

\end_inset

 zeigt das Resultat.
 Die Verantwortung für die Lokalisierung wurde in eine allein dafür vorgesehene
 Klasse verschoben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly EnglishLocalization localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Extraction der englischen Lokalisierung aus der existierenden Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:Extraction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Klasse DamageRenderer funktioniert immernoch wie im vorherigen Beispiel.
 Der Unterschied ist, dass DamageRenderer nun eine Abhängigkeit zu EnglishLocali
zation besitzt.
 Wie kann es nun ermöglicht werden, die englische Lokalisierung mit der
 Deutschen in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Deutsche-Lokalisierung"

\end_inset

 auszutauchen? Das Problem hierbei ist, dass DamageRenderer eine konkrete
 Abhängigkeit zu EnglishLocalization hat.
 Mit anderen Worten, sie sind eng miteinander gekoppelt.
 Die Folge ist, dass EnglishLocalization nicht ohne DamageRenderer zu ändern
 durch GermanLocalization ausgetauscht werden kann.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GermanLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Deutsche Lokalisierung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Deutsche-Lokalisierung"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Programming to an Interface
\end_layout

\begin_layout Standard
Um lose Kopplung umzusetzen darf keine Abhängigkeit zu einer konkreten Implement
ation existieren.
 Stattdessen muss sich auf eine Abstraktion als Abhängigkeit verlassen werden.
 In dem Beispiel in Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Depend-Abstractions"

\end_inset

 wird dies umgesetzt indem English- und GermanLocalization das Interface
 ILocalizationService implementieren.
 Dadurch, dass DamageRenderer nur noch eine Variable des Interfaces ILocalizatio
nService hält, lässt sich die konkrete Implementation austauschen.
 Dies ist jedoch immernoch nur möglich wenn DamageRenderer geändert wird.
 Der Grund dafür ist, dass EnglishLocalization im Konstruktor von DamageRenderer
 instanziiert wird.
 Somit ist DamageRenderer immernoch eng mit EnglishLocalization gekoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	string GetText();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class GermanLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von 
\begin_inset Quotes gld
\end_inset

Depend on abstractions
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:Depend-Abstractions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Injecting Dependencies
\end_layout

\begin_layout Standard
Anstatt, dass sich eine Klasse selbst um die Auflösung ihrer Abhängigkeiten
 kümmert, sollte sie von Aussen mit diesen versorgt werden.
 Die Verantwortung über die Auflösung der Abhängigkeiten wird abgegeben.
 Die Klasse selbst macht lediglich deutlich, dass Sie ein Objekt benötigt,
 welches die abstrakten Bedürfnisse eines Interfaces umsetzt.
 In diesem Fall, die eines ILocalizationService.
 Die Klassen sind durch Dependency Injection lose miteinander gekoppelt.
 Dependency Injection lässt sich auf unterschiedlichen Wegen umsetzten.
 Die gebräuchlichsten sind Constructor Injection und Property Injection.
\end_layout

\begin_layout Subsubsection
Constructor Injection
\end_layout

\begin_layout Standard
Die Abhängigkeit wird über den Konstruktor bei der Instanziierung des Objektes
 bereitgestellt.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Constructor"

\end_inset

 wird Constructor Injection in der DamageRenderer angewandt.
 Eine Instanz von ILocalizationService muss bei Aufruf des Konstruktors
 bereitgestellt werden.
\end_layout

\begin_layout Standard
Constructor Injection stellt sicher, dass die nötige Abhängigkeit auch tatsächli
ch verfügbar ist, indem eine Instanziierung des Objektes (ein Konstruktoraufruf)
 ohne sie nicht möglich ist.
 Damit wird erzwungen, dass der gesamte Abhängigkeitsgraph aufgebaut wird,
 bevor die Klasse genutzt werden kann.
 Eine Guard Clause stellt sicher, dass nicht null als Argument übergeben
 wird.
 Constructor Injection sollte in den meisten Fällen angewand werden, denn
 in den meisten Fällen ist die benötigte Abhängigkeit zwingend notwendig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer(ILocalizationService localization)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		this.localization = localization;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Constructor Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Constructor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Property Injection
\end_layout

\begin_layout Standard
Ist eine Abhängigkeit optional, kann die Klasse über ein Property mit einer
 Instanz dieser Abhängigkeit versorgt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Property"

\end_inset

 zeigt die Umsetzung von Property Injection anhand des gewählten Beispiels.
 Die Klasse stellt ein öffentlich setzbares Property vom Typ der Abhängigkeit
 bereit.
 In dem gezeigten Beispiel ist Property Injection wenig angebracht, da die
 Abhängigkeit notwendig ist.
 Man könnte jedoch, falls kein LocalizationService bereitgestellt wird,
 beispielsweise im Getter eine Instanz von EnglishLocalization erstellen
 und diese so als Local Default verwenden.
\end_layout

\begin_layout Standard
Mit Properties lässt sich so das Open-Closed Principle umsetzen: Sie bieten
 eine optionale Abhängigkeit zur Erweiterung der Funktionalität einer Klasse
 ohne dabei die Klasse selbst zu modifizieren.
\end_layout

\begin_layout Standard
Ein Nachteil ist, dass andere Klassen zu jeder Zeit Veränderungen an dem
 Property vornehmen können.
 Aus diesem Grund wird Property Injection in manchen Kreisen kritisiert,
 da es die Datenkapselung bricht.
\end_layout

\begin_layout Standard
Oft hindert auch die Verwendung eines Frameworks die Verwendung von Constructor
 Injection, zum Beispiel, wenn dieses Framework vorscheibt, dass Klassen
 einen Default Constructor haben.
 In diesem Fall kann auch auf Property Injection zurückgegriffen werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer : IDamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ILocalizationService Localization { private get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var output = string.Format(Localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Property Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Property"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Composition Root
\begin_inset CommandInset label
LatexCommand label
name "sub:Composition-Root"

\end_inset


\end_layout

\begin_layout Standard
In den letzten Abschnitten wurde verdeutlicht, dass Dependency Injection
 es verlangt, die Verantwortung über die Auflösung der Abhängigkeiten abzugeben.
 Es wurde jedoch nicht beschrieben, an wen diese Verantwortung übertragen
 werden soll.
 Die Antwort ergibt sich, wenn man Dependency Injection konsequent umsetzt:
 Abhängigkeiten werden in der Objekthierarchie nach oben gereicht, bis dies
 nicht mehr möglich ist.
 Die Auflösung der Abhängigkeiten sollte also so nah wie möglich beim Einstiegsp
unkt der Applikation geschehen.
 Soweit möglich sollte die Initialisierungslogik aller Objekte an diesem
 zentralen Ort umgesetzt werden.
 Dieser zentrale Ort wird als Composition Root bezeichnet.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 76-77"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
In einer Konsolenapplikation, wie dem gezeigten Beispiel, erfüllt die Main-Metho
de die Vorraussetzungen für einen Composition Root: Sie ist der Einstiegspunkt
 in die Anwendung und zugleich der höchste Punkt in der Objekthierarchie.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CompositionRoot"

\end_inset

 zeigt den Composition Root des gewählten Beispiels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Main(string[] args)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var localization = new GermanLocalization();
\end_layout

\begin_layout Plain Layout

		var renderer = new DamageRenderer(localization);
\end_layout

\begin_layout Plain Layout

		renderer.Render("Mario", 10);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Main-Methode erfüllt die Eigenschaften des Composition Roots in einer
 Konsolenanwendung
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Composition Root wird die Konfiguration der Anwendung vorgenommen.
 Es ist der einzige Ort an dem die konkreten Instanzen von Objekten bekannt
 sein müssen.
 Er sollte unabhängig von dem Rest der Anwendung kompilierbar sein und sich
 deswegen in einem seperaten Assembly befinden.
\end_layout

\begin_layout Subsection
Stable and volatile Dependencies
\end_layout

\begin_layout Standard
Nicht jede Abhängigkeit muss lose mit der Anwendung gekoppelt werden.
 Tatsächlich ist dies für bestimmte, feste Abhängigkeiten unnötig.
 Wichtig ist jedoch unterscheiden zu können, wann eine Abhängigkeit als
 fest (stable) und wann als unbeständig (volatile) angesehen werden sollte.
 
\end_layout

\begin_layout Standard
Kann davon ausgegangen werden, dass ein bereits existierendes Modul niemals
 ausgetauscht oder verändert wird, so kann es als eine feste Abängigkeit
 angesehen werden.
 Ein Beispiel hierfür sind die meisten Module der Base Class Library, da
 sie fester Bestandteil des .NET Frameworks sind.
 Ob ein Modul als feste Abhängigkeit angesehen werden kann, lässt sich anhand
 der folgenden Kriterien beurteilen:
\end_layout

\begin_layout Itemize
Die Klasse oder das Modul existiert bereits.
\end_layout

\begin_layout Itemize
Es ist zu erwarten ist, dass neue Versionen keine Änderungen enthalten werden
 die Auswirkungen auf den Programmcode haben werden.
\end_layout

\begin_layout Itemize
Das Modul lediglich deterministische Algorithmen beinhaltet.
\end_layout

\begin_layout Itemize
Es nicht zu erwarten ist, dass das Modul jemals durch ein anderes ausgetauscht
 wird.
\end_layout

\begin_layout Standard
Den Gegensatz zu festen Abhängigkeiten bilden Klassen und Module bei denen
 es absehbar ist, dass sie sich verändern werden.
 Ist eine Abhängigkeit unbeständig, sollte sie lose mit dem Rest der Anwendung
 gekoppelt werden, um ihre Austauschbarkeit zu ermöglichen.
 Eine Abhängigkeit wird als unbeständig angesehen, wenn eines der folgenden
 Kriterien auf sie zutrifft:
\end_layout

\begin_layout Itemize
Durch die Abhängigkeit wird eine bestimmte Laufzeitumgebung vorrausgesetzt.
 
\end_layout

\begin_layout Itemize
Die Abhängigkeit existiert noch nicht.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nutzt eine thrid-party Library, die nicht auf allen Systemen
 vorhanden ist.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nichtdeterministisches Verhalten aufweist.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 23-24"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
Ein Beispiel für eine in der Base Class Library vorhandene Klasse die als
 unbeständige Abhängigkeit behandelt werden sollte, ist System.Random.
 Die Klasse weist nichtdeterministisches Verhalten auf, was sich besonders
 auf die Testbarkeit der Anwendung auswirkt.
\end_layout

\begin_layout Section
Resultierende Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten wurde ausführlich beschrieben wie lose Kopplung
 umzusetzen ist.
 Jedoch sind eventuell die Gründe für lose Kopplung aufgrund des einfachen
 Beispiels noch nicht ganz klar geworden.
 Lose Kopplung trägt maßgeblich zu der Qualität eines Softwareproduktes
 bei.
 Welche Faktoren genau beeinflusst werden, soll im Folgenden erläutert werden.
\end_layout

\begin_layout Subsection
Erweiterbarkeit
\end_layout

\begin_layout Standard
Während der Entwicklung einer Anwendung werden neue Anforderungen bekannt
 und existierende Anforderungen beginnen sich zu verändern.
 Trotzdem muss die Anwendung erweiterbar und wartbar bleiben.
 Erweiterbarkeit wird problematischer je größer die Anwendung ist.
 In sehr großen Softwaresystemen ist es schwer abzusehen welche Auswirkungen
 auch nur die kleinste Änderung hat.
 Aus diesem Grund ist es notwendig Module so autonom wie möglich zu halten.
 Dadurch, dass die Abhängigkeiten eines Modules auf Interfaces reduziert
 werden, haben Änderungen der konkreten Implementation keinen Einfluss auf
 sie.
\end_layout

\begin_layout Standard
Lose Kopplung setzt das Open/Closed Principle in die Tat um: Module sind
 offen für Erweiterung und geschlossen für Veränderung.
 Maßgeblich verantwortlich hierfür ist das Konzept der späten Bindung, welches
 durch programming to an interface konsequent umgesetzt wird.
 Die konkrete Implementation ist austauschbar und wird erst zur Laufzeit
 bekannt.
 Sie ist unabhängig vom Rest der Anwendung veränderbar.
\end_layout

\begin_layout Standard
Dependency Injection hilft dabei, Verantwortungen klarer aufzuteilen und
 zu definieren.
 Durch das Einhalten des Single Responcibility Principles wird es deutlicher
 wo Änderungen gemacht werden müssen.
 Oft genügt es eine konkrete Implementation durch eine andere auszutauschen
 um ein gewünschtes Verhalten zu erzielen.
 Dependency Injection macht dies trivial.
\end_layout

\begin_layout Subsection
Wiederverwendbarkeit
\end_layout

\begin_layout Standard
Einzelne Softwaremodule sind wiederverwendbar, da sie lose mit ihren Abhängigkei
ten gekoppelt sind.
 Die eigentliche Implementation dieser Abhängigkeiten ist für das Modul
 nicht relevant.
 Ist in einer anderen Umgebung eine andere konkrete Implementation notwendig
 so kann sie einfach ausgetauscht werden.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern!}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallelisierung
\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht die parallele Entwicklung einer Softwareanwendung
 indem klare Schnittstellen zur Kommunikation definiert werden.
 Unter den kollaborierenden Entwicklern muss sich lediglich auf diese Schnittste
llen geeinigt werden.
 Die konkreten Implementationen sind nicht mehr relevant und können unabhängig
 voneinander im Parallelen umgesetzt werden.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern!}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testbarkeit
\end_layout

\begin_layout Standard
Wie lose Kopplung die Testbarkeit einer Anwendung drastisch erleichtert,
 lässt sich am besten Anhand eines Beispiels erläutern.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Testability"

\end_inset

 zeigt die Implementation eines sehr simplen Spiels: Der Spieler soll das
 Resultat eines Würfelwurfs erraten.
 Mit der Roll-Methode der gezeigten GuessANumber-Klasse soll der Würfelwurf
 ausgeführt werden.
 Darauf folgend kann der Spieler durch den Aufruf der MakeGuess-Methode
 den Versuch vornehmen das Ergebnis zu erraten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GuessANumber
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private IRandom random;
\end_layout

\begin_layout Plain Layout

	private int result;
\end_layout

\begin_layout Plain Layout

	private const int max = 6;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public GuessANumber(IRandom random)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.random = random;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GuessANumber Roll()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		result = random.Range(1, max);
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public bool MakeGuess(int guess)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return result == guess;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IRandom
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Range(int min, int max);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel einer durch Dependency Injection testbaren Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Testability"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die GuessANumber-Klasse hat eine volatile Abhängigkeit zu IRandom.
 Diese Entscheidung wurde bewusst getroffen, da das Generieren einer Zufallsnumm
er nicht deterministisch ist.
 Die Abhängigkeit zu IRandom wird über Constructor Injection aufgelöst.
 Eine Klasse die das IRandom-Interface implementiert, könnte mithilfe von
 UnityEngine.Random oder System.Random umgesetzt werden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GuessANumber-UnitTest"

\end_inset

 zeigt einen Unit-Test der sicherstellen soll, dass die MakeGuess-Methode
 korrekt feststellen kann, ob richtig geraten wurde.
 Um die GuessANumber-Klasse durch einen Unit-Test auf korrekte Funktionalität
 prüfen zu können, muss das Resultat deterministisch sein.
 Hierzu wird anstatt einer echten Implementation einer Random-Klasse ein
 Stub des IRandom-Interfaces erzeugt.
 Das Erzeugen eines Stubs kann durch Verwendung des Isolation-Frameworks
 NSubstitute automatisiert werden: Durch Aufruf der Methode For<T> der Klasse
 Substitute wird ein dynamischer Stub für IRandom erzeugt.
 Der Stub wird so konfiguriert, dass er für jeden Aufruf der Range-Methode
 - unabhängig von beiden Parametern - einen vorgegebenen Wert zurückgibt.
 Das Ergebnis eines Würfelwurfs durch die Roll-Methode wird somit diesem
 vorgegebenen Wert entsprechen.
 Damit zu erwarten, dass der Aufruf der MakeGuess-Methode mit dem vorgegebenen
 Wert true zurückgibt.
 Die tatsächliche Funktionalität kann nun durch ein Assert-Statement überprüft
 werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using NUnit.Framework;
\end_layout

\begin_layout Plain Layout

using NSubstitute;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[TestFixture]
\end_layout

\begin_layout Plain Layout

public class GuessANumberTests
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Test]
\end_layout

\begin_layout Plain Layout

	public void ShouldReturnTrueForRightGuess()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var expected = 6;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var randomStub = Substitute.For<IRandom>();
\end_layout

\begin_layout Plain Layout

		randomStub.Range(Arg.Any<int>(), Arg.Any<int>()).Returns(expected);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var guessANumber = new GuessANumber(randomStub);
\end_layout

\begin_layout Plain Layout

		guessANumber.Roll();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Assert.True(guessANumber.MakeGuess(expected));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Testen der GuessANumber Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:GuessANumber-UnitTest"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht, dass Module in Isolation betrachtet werden können.
 Durch Dependency Injection können zugrundeliegende Implementationen einer
 Abstraktion durch Fakes, Mocks und Stubs ausgetauscht werden.
 Es muss mit Bedacht auf die Testbarkeit einer Anwendung entschieden werden,
 ob eine Abhängigkeit volatile oder stable ist.
 Der sicherste Weg Testbarkeit zu gewährleisten, ist Test Driven Development
 in Kombination mit Dependency Injection zu praktizieren.
\end_layout

\begin_layout Chapter
Analyse der Architektur von Unity3D
\end_layout

\begin_layout Standard
In dem letzten Kapitel wurde beschrieben, was lose Kopplung ist und wie
 Inversion of Control und genauer Dependency Injection, dabei hilft diese
 umzusetzen.
 Es wurde beschrieben, dass lose Kopplung maßgeblich zu der Qualität des
 Softwareproduktes beiträgt.
 Dependency Injection wurde beispielhaft in einer Konsolenapplikation angewendet.
 In diesem Kapitel sollen relevante Unterschiede zwischen der klassischen
 objektorientierten Programmierung bei der Entwicklung einer Konsolenapplikation
 und der komponentenbasierten Architektur von Unity beschrieben werden.
 Gute und schlechte Praktiken bei der Arbeit mit Unity sollen erläutert
 werden.
 Unity stellt von sich aus Wege bereit um die Kommunikation zwischen Klassen
 zu ermöglichen.
 Es soll untersucht werden, ob diese es bereits ermöglichen lose Kopplung
 umzusetzen.
\end_layout

\begin_layout Section
Komponentenbasierte Architektur von Unity3D
\end_layout

\begin_layout Standard
Jede Spieleengine implementiert eine Form eines Game Object Models.
 Ein Game Object Model beschreibt Hilfsmittel, die es ermöglichen Entitäten
 innerhalb der Spielwelt zu modellieren und zu simulieren.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 854"
key "Gregory2014"

\end_inset

 Meistens bestehen diese Hilfsmittel aus zwei Teilen: Einer visuellen Repräsenta
tion der Spielobjekte innerhalb des Editors der Engine und einer Laufzeitumgebun
g, die die Entwicklung neuer Spielobjekte ermöglicht.
 In jedem Fall wird ein Framework bereitgestellt, das die Konstruktion neuer
 Spielobjekte erlaubt.
\begin_inset CommandInset citation
LatexCommand cite
after "S. 869"
key "Gregory2014"

\end_inset


\end_layout

\begin_layout Standard
In klassischen objektorientierten Implementationen eines Game Object Models
 werden Spielobjekte von einer Vererbungshierarchie abgeleitet.
 Es handelt sich um eine monolitische Klassenhierarchie: Alle Objekte werden
 von einer gemeinsamen Basisklasse namens GameObject abgeleitet.
 Diese Basisklasse enthält Funktionalität, die für alle Klassen notwendig
 ist.
 Ein Beispiel hierfür ist Serialisierung.
 Mit dem Wachstum des Projektes wächst auch die Hierarchie immer tiefer
 und weiter.
 Es folgt eine Reihe von Problemen: Klassen die sich tief in der Vererbungshiera
rchie befinden, sind schwierig zu verstehen und zu verändern, da hierfür
 auch alle Basisklassen bekannt sein müssen.
\end_layout

\begin_layout Standard
Es kann nur ein Merkmal als Basis für eine Vererbungshierarchie gewählt
 werden.
 Ein Merkmal kann beispielsweise die Beweglichkeit eines Objekts sein.
 Ein Anderes die Fähigkeit mit anderen Objekten zu kollidieren.
 Möchte man ein Objekt mit beiden Merkmalen haben, so stößt man schnell
 an die Grenzen einer solchen Architektur: Die benötigten Funktionalitäten
 müssen in der Hierarchie nach oben verschoben werden und bewirken so, dass
 sie eventuell in Klassen vorhanden sind in denen sie nicht gebraucht werden.
 Das Problem kann in einigen Sprachen auch durch multiple Vererbung gelöst
 werden, was aber zu einem Deadly Diamond führen kann.
 Klassen von denen geerbt wird haben die selbe Basisklasse.
\end_layout

\begin_layout Standard
Um diesen Problemen vorzubeugen implementiert Unity ein komponentenbasiertes
 Game Object Model.
 Das Grundprinzip dieses Models ist Komposition der Vererbung vorzuziehen.
 Anstatt Objekte mittels Vererbung und des 
\begin_inset Quotes gld
\end_inset

is a
\begin_inset Quotes grd
\end_inset

 Verhältnisses zu erweiteren, erfolgt die Komposition eines Spielobjekts
 aus einzelnen Komponenten über das 
\begin_inset Quotes gld
\end_inset

has a
\begin_inset Quotes grd
\end_inset

 Verhältnis.
 In Unity werden Spielobjekte von der Klasse GameObject abgebildet.
 Ein GameObject fungiert als Knotenpunkt für eine variable Anzahl von Komponente
n und hat kaum bis gar keine weitere Funktionalität.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 887"
key "Gregory2014"

\end_inset

 Funktionalität wird erst durch das Anfügen von Komponenten hinzugefügt.
 Komponenten werden in Unity von der Klasse MonoBehaviour abgeleitet.
 
\end_layout

\begin_layout Section
Programmierung und Konfiguration
\end_layout

\begin_layout Standard
MonoBehaviours sind die Schnittstelle, die es Programmierern ermöglicht
 die Engine mit individuellem Verhalten zu erweitern um ein Spiel umzusetzen.
 Unity verwendet die .NET-kompatible und Laufzeitumgebung Mono um die plattformun
abhängige Entwicklung von Komponenten in C# und UnityScript zu ermöglichen.
 Dem Nutzer stehen folglich alle gängigen Sprachfeatures wie Polymorphismus
 und Vererbung innerhalb der Komponenten zur Verfügung.
 Komponenten können durch die Implementierung von einer Reihe von vordefinierten
 Eventfunktionen Einfluss auf das Spielgeschehen nehmen.
\end_layout

\begin_layout Standard
Der Rest, also die Konfiguration und Komposition von Komponenten erfolgt
 in einem visuellen Editor.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Unity-Editor"

\end_inset

 zeigt das Benutzerinterface des Unity Editors.
 Der Editor erlaubt das Anlegen von Szenen, die den Lebensraum für Spielobjekte
 darstellen.
 Spielobjekte werden im sogenannten Hierarchiefenster erstellt und in einem
 Szenegraph angeordnert.
 Per Drag-and-Drop können Spielobjekten Komponenten hinzugefügt werden.
 Öffentliche Member einer Komponente können im Inspector konfiguriert werden.
 Wird eine Szene geladen, kümmert sich Unity um die Instanziierung aller
 sich in ihr befindlichen Spielobjekte und deren Komponenten.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Editor-Breakdown.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Das Benutzerinterface vom Unity Editor
\begin_inset CommandInset label
LatexCommand label
name "fig:Unity-Editor"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Betrachtet man die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Inversion-of-Control"

\end_inset

 gegebene Definition von Inversion Of Control, stellt man fest, dass diese
 auch auf Unity zutrifft.
 Die Kontrolle über die Komposition und Lebenszeit von Objekten ist bereits
 invertiert, sie liegt in den Händen von Unity.
 Ein Indiz hierfür ist, dass Unity keine Konstruktoren in MonoBehaviours
 zulässt.
 Es ist also nicht möglich Komponenten über einen Konstruktor mit ihren
 Abhängigkeiten zu versorgen.
 Aus diesem Grund stellt Unity alternative Wege zur Kommunikation mit anderen
 Komponenten bereit.
 Diese sollen im folgenden Abschnitt erläutert werden.
\end_layout

\begin_layout Section
Kommunikation und Abhängigkeiten
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Abschnitt überarbeiten!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jede Komponente soll eine einzige Funktionalität kapseln und sie wiederverwendba
r machen.
 Mit anderen Worten: Komposition anstelle von Vererbung soll es ermöglichen
 Funktionalitäten aus unterscheidlichen Bereichen in wiederverwendbare Komponent
en aufzuteilen ohne sie miteinander zu koppeln.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 213"
key "Nystrom2014"

\end_inset

 In der Realität ist dies jedoch nur begrenzt möglich: Komponenten sind
 Teile eines größeren Ganzen und müssen somit kommunizieren und interagieren.
 Komponenten haben folglich Abhängigkeiten zueinander.
 
\end_layout

\begin_layout Standard
Oft beschränkt sich diese Kommunikation auf Komponenten des selben GameObjects.
 Es kommt jedoch auch vor, dass ein MonoBehaviour mit einem MonoBehaviour
 eines anderen GameObjects kommunizieren muss.
 Folglich wird zwischen zwei Arten der Kommunikation unterschieden:
\end_layout

\begin_layout Itemize
Die Intra-Objekt-Kommunikation erfolgt unter MonoBehaviours des selben GameObjec
ts oder Kindern von diesem.
\end_layout

\begin_layout Itemize
Die Inter-Objekt-Kommunikation beschreibt die Kommunikation zu anderen GameObjet
cts die ansonsten in keiner Relation zueinander stehen.
\end_layout

\begin_layout Standard
In beiden Fällen kann die Kommunikation direkt oder indirekt erfolgen.
 Bei direkter Kommunikation ist es notwendig, dass entweder Sender oder
 Empfänger einander kennen.
 Eines der Objekte muss also eine Referenz zu dem anderen halten.
 Kommunikation erfolgt indirekt, wenn Sie über ein drittes Objekt \SpecialChar \nobreakdash-
 einem
 Vermittler \SpecialChar \nobreakdash-
 stattfindet.
 In jedem Fall wird eine Referenz auf ein weiteres Objekt benötigt.
\end_layout

\begin_layout Standard
Im folgenden Abschnitt soll untersucht werden, ob Unity's integrierte Möglichkei
ten Abhängigkeiten aufzulösen es ermöglichen lose Kopplung zwischen Komponenten
 umzusetzen.
\end_layout

\begin_layout Subsection
Referenzieren von anderen MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "sub:Referenzieren"

\end_inset


\end_layout

\begin_layout Standard
Unity bietet unterschiedliche Möglichkeiten um Zugriff auf unterschiedliche
 Objekte zu erlangen.
 So werden zahlreiche Game Object Queries für die Inter-Objekt-Kommunikation
 bereit gestellt.
 Um andere Komponenten referenzieren zu können, gibt es Component Queries.
 Desweiteren gibt es auch komponentenunabhängige Kommunikation über Events.
\end_layout

\begin_layout Subsubsection
SerializeField
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SerializeField ist ein Attribut, das ermöglicht private Member einer Komponente
 zu serialisieren und somit im Inspektor zu setzen.
 Setzbare Datentypen sind primitive Datentypen wie int, float, bool und
 in Unity eingebaute Datentypen wie Vector, Quaternion und Color, sowie
 Strings, Enums und Structs.
 Desweiteren ist es möglich Referenzen zu Klassen und Objekten durch drag-and-dr
op im Editor zu setzen.
 Dabei ist zu beachten, dass diese Objekte vom Typ UnityEngine.Object ableiten
 müssen.
 Es ist also möglich andere Komponenten oder Spielobjekte zu referenzieren.
 Jedoch ist es aufgrund dieser Limitierung nicht möglich, Interfaces im
 Editor zugänglich zu machen.
 Neben Variablen mit dem SerializeField-Attribut werden Variablen, die mit
 dem Zugriffsmodifizierer public gekennzeichnet wurden im Editor zugänglich
 gemacht.
 Dies ist jedoch ausdrücklich nicht zu empfehlen, da so die Datenkapselung
 des Objektes gebrochen wird.
\end_layout

\begin_layout Standard
Ist bereits vor Ausführung des Spiels bekannt welche Referenzen benötigt
 werden, sollten diese wenn möglich über ein SerializeField aufgelöst werden.
 Um sicherzugehen, dass die Referenz im Editor aufgelöst wurde, ist es ratsam
 einen Guard Clause in die OnValidate-Funktion der Komponente hinzuzufügen.
 Abb.
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SerializeField"

\end_inset

 verdeutlicht dies anhand eines einfachen Beispiels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.UI;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Assertions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SomeBehaviour : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[SerializeField]
\end_layout

\begin_layout Plain Layout

	private Image myImage;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnValidate()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Assert.IsNotNull(myImage);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SerializeField mit Guard Clause in OnValidate
\begin_inset CommandInset label
LatexCommand label
name "fig:SerializeField"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn erst zur Laufzeit bestimmt werden kann welches das benötigte Objekt
 ist, zum Beispiel wenn sich die Abhängigkeit ausserhalb eines instanziierten
 Prefab befindet, so muss auf eine andere Methode der Referenzierung zurückgegri
ffen werden.
\end_layout

\begin_layout Subsubsection*
GetComponent
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponent(Type type);
\end_layout

\begin_layout Plain Layout

public T GetComponent();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
GetComponent ermöglicht es, auf andere Komponenten des selben GameObjects
 zuzugreifen.
 Ist keine Komponente des gewünschten Typs vorhanden, wird null zurückgegeben.
 Dies kann verhindert werden, indem man dem Script das Attribut RequireComponent
 hinzufügt.
 RequireComponent bewirkt, dass die benötigte Komponente automatisch an
 das GameObject angefügt wird.
 Um auf Komponenten von anderen GameObjects in der über- und untergeordneten
 Hierarchieebene zugreifen zu können, werden zusätzlich folgende Methoden
 bereit gestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponentInChildren(Type t);
\end_layout

\begin_layout Plain Layout

public Component GetComponentInParent(Type t);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle GetComponent-Methoden spezifizieren einen Typparameter T als Suchkriterium.
 Da T nicht weiter \SpecialChar \nobreakdash-
 zum Beispiel auf UnityEngine.Object \SpecialChar \nobreakdash-
 eingeschränkt wird,
 ist es Möglich, anstatt konkreten Komponenten auch Komponenten anhand eines
 Interfaces zu finden.
\end_layout

\begin_layout Standard
Beim Verwenden von GetComponent wird implizit eine Anordnung in der Objekthierar
chie festgelegt.
 Wird zum Beispiel eine benötigte Komponente in ein Child-GameObject verschoben,
 ist das Spiel ohne Änderung im Programmcode nicht mehr lauffähig.
 Aus diesem Grund sollte GetComponent nur in Ausnahmefällen, wenn Beispielsweise
 eine Komponete zur Laufzeit hinzugefügt wird, verwendet werden.
 
\end_layout

\begin_layout Subsubsection*
String-Based Find Functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static GameObject Find(string name);
\end_layout

\begin_layout Plain Layout

public static GameObject FindWithTag(string tag);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unity's Find Functions sind klassische Game Object Queries zur Inter-Objekt
 Kommunikation.
 Das gewünschte Spielobjekt wird auf Basis eines Strings als Suchkriterium
 zurückgegeben.
 Dieser String kann entweder der Name oder ein Tag sein.
 Die Funktionen unterscheiden sich im Verhalten, falls kein GameObject mit
 dem passenden Namen gefunden wird: Wird kein Objekt mit dem passenden Namen
 gefunden, gibt Find null zurück.
 Wird kein Objekt mit dem passenden Tag gefunden, wirft FindWithTag eine
 UnityException.
 Nachdem das gesuchte Objekt gefunden wurde, muss die gewünschte Komponente
 mittels GetComponent ausfindig gemacht werden.
\end_layout

\begin_layout Standard
Generell ist von der Nutzung beider Funktionen abzuraten, da sie nicht gewährlei
sten, dass das gesuchte GameObject tatsächlich auffindbar ist.
 Es wird sich darauf verlassen, dass ein GameObject mit bestimmten Namen/Tag
 in der Szene existiert und bestimmte Komponenten an diesem vorhanden sind.
 Es gibt somit viel Raum für Fehlkonfiguration.
\end_layout

\begin_layout Subsubsection*
FindObjectOfType
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static Object FindObjectOfType(Type type);
\end_layout

\begin_layout Plain Layout

public static T FindObjectOfType<T>() where T : Object;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Gegensatz zu den anderen Find Functions ist FindObjectOfType typsicher.
 Es wird gewährt, dass eine in der Szene aktive Instanz eines bestimmten
 Typs erhalten wird.
 Anzumerken ist, dass der gewünschte Typ von UnityEngine.Object abgeleitet
 sein muss.
 Somit funktioniert auch FindObjectOfType nicht mit Interfaces.
 Die generische Variante von FindObjectOfType ist anderen Find Funktionen
 vorzuziehen, da sie direkt die Instanz der gesuchten Komponente vom Typ
 T als Rückgabewert liefert.
 Es ist also nicht nötig GetComponent zu nutzen.
\end_layout

\begin_layout Standard
In der Dokumentation der Funktion wird angemerkt, dass FindObjectOfType
 sehr langsam ist.
 Sie sollte daher nicht jeden Frame genutzt werden.
 Als Alternative wird das Singleton Pattern vorgeschlagen.
\end_layout

\begin_layout Subsubsection*
Singleton und Statics
\end_layout

\begin_layout Standard
Singletons stellen sicher, dass nur eine Instanz einer Klasse gibt, auf
 welche ein globaler Zugriffspunkt existiert.
 Hier mit aufgeführt, weil sie in Unitz alternativ zu FindObjectOfType genutzt
 werden können, mit der Beschränkung, dass sie auf eine Instanz limitiert
 sind.
 Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Singleton"

\end_inset

 zeigt eine mögliche Implementation eines Singletons welches von MonoBehaviour
 ableitet.
 Die Singletonkomponente muss lediglich einem Spielobjekt in der Szene hinzugefü
gt werden um es global verfügbar zu machen.
 Der Zugriff auf die Singleton-Komponente erfolgt über die statische Variable
 Instance.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Singleton : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static Singleton Instance { get; private set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Awake ()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (Instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Instance = this;
\end_layout

\begin_layout Plain Layout

			DontDestroyOnLoad (this);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Destroy (gameObject);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Singleton Patterns in Form eines MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "fig:Singleton"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Form des Singletons erlaubt dem Objekt die Funktionalitäten eines
 MonoBehaviours - wie dem Update Loop - zu nutzen.
 Sollten diese Funktionalitäten nicht notwendig sein, oder soll der Singleton
 Lazy intitalisiert werden, kann auch ein klassischer Singleton nach GoF
 verwendet werden.
 Sollte gar keine Vererbung notwendig sein, gibt es oft jedoch gar keinen
 Grund ein Singleton zu implementierten.
 Stattdessen kann eine statische Klasse verwendet werden.
\end_layout

\begin_layout Standard
An dieser Stelle sei bereits anzumerken, dass Singletons aus vielen Gründen
 als Anti-Pattern angesehen werden.
 Eine der Ursachen dafür ist, dass sie einen Globalen Zustand einführen.
 Gleiches gilt für statische Klassen.
\end_layout

\begin_layout Subsection
Events und Messages
\end_layout

\begin_layout Standard
Alternativ kann die Kommunikation zwischen Objekten auch über Events erfolgen.
 Events können im Unterschied zu Methodenaufrufen keinen oder mehrere Empfänger
 haben.
 Events sind eine Umsetzung des Observer Patterns.
 Die Klasse die den Event auslöst wird als Publisher und die Klassen, die
 das Ereignis behandeln als Subscriber bezeichnet.
 Ein typischer Anwendungsfall für Events sind UI-Elemente wie Buttons, Slider
 und Toggles.
 Mit Events kann nichtsdestotrotz das gleiche Ergebnis wie mit Referenzierung
 und Methodenaufruf erzielt werden.
 Unity und C# bieten mehrere Möglichkeiten um die Kommunikation mittels
 Events umzusetzen.
 In dieser Arbeit wird davon abgesehen, darzustellen wie C# Events implementiert
 werden, da Sie ohne Mediation oder Statics nicht das Problem der Referenzierung
 lösen.
 Wird ein gewöhnlicher C# Event als Kommunikationskanal gewählt, so muss
 der Empfänger über einen der im letzten Abschnitt beschriebenen Wege Zugriff
 auf den Sender erhalten.
 Um diese Limitierung zu umgehen bietet Unity ab der Version 4.6 eine eigene
 Implementierung von Events.
\end_layout

\begin_layout Subsubsection*
UnityEvent (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class UnityEvent<T,...,Tn>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents ermöglichen das Setzen von Callbacks über das Editorfenster.
 Auf diese Weise sind Sender und Empfänger komplett voneinander entkoppelt.
 Zudem bieten sie zusätzlich nahezu identische Funktionalität wie klassische
 C# Events.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEventCode"

\end_inset

 zeigt die Verwendung eines nicht generischen UnityEvents ohne Parameter.
 Die Publisher Komponente löst den Event in der Start-Methode aus.
 Ein Subscriber benötigt lediglich eine öffentliche Methode mit der passenden
 Signatur.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Events;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public UnityEvent myEvent;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (myEvent != null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			myEvent.Invoke();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Recieved");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Publishers und Subscribers unter Verwendung eines UnityEvents
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEventCode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist, dass bis jetzt noch keine Verbindung zwischen Publisher und
 Subscriber existiert.
 Diese kann im Editor gesetzt werden (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEvent"

\end_inset

).
 Somit wird es ohne weiteren Programmcode möglich zu bestimmen wer auf ein
 Event reagieren soll.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/UnityEvent.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzufügen einer Callback-Methode für einen UnityEvent im Editor
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEvent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents bieten somit eine Möglichkeit Sender von Empfänger komplett
 zu entkoppeln.
 Andererseits gibt es auch hier viel Raum zur Fehlkonfiguration.
 Es ist nicht im Programmcode ersichtlich ob und wer die Subscriber eines
 Events sind.
 Genauso wenig ist ersichtlich ob eine als öffentlich gekennzeichnete Methode
 als Callback genutzt wird oder nicht.
 Oft werden Methoden und Events auf die keine Referenzen im Programmcode
 existieren einfach gelöscht.
\end_layout

\begin_layout Standard
Events sind ein geeignetes Mittel um optionale Abhängigkeiten aufzulösen.
 Ist eine Abhängigkeit jedoch zwingend erforderlich, sollte zu einer anderen
 Möglichkeit gegriffen werden.
\end_layout

\begin_layout Subsubsection*
Sending Messages
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void SendMessage(string methodName, object value = null, SendMessageOptio
ns options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void SendMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, object parameter = null,
 SendMessageOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, object value = null, SendMessa
geOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
MonoBehaviours bieten die Funktionalität untereinander mittels Messages
 zu kommunizieren.
 SendMessage ermöglicht die Kommunikation zwischen Komponenten innerhalb
 eines Spielobjekts.
 BroadcastMessage sendet eine Message an das gewählte Spielobjekt und dessen
 Children.
 SendMessageUpwards sendet die Nachricht an alle Spielobjekte die sich dem
 gewählten Spielobjekt übergeordnet in der Szene-Hierarchie befinden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SendMessage"

\end_inset

 zeigt die Verwendung von SendMessage anhand von zwei Komponenten, die sich
 am gleichen Spielobjekt befinden.
 Der Publisher eines Events spezifiziert die Callback-Methode mittels eines
 Strings.
 Dieser String repräsentiert den Namen der gesuchten Callback-Methode.
 Der Zugriffsmodifizierer der Callback-Methode ist dabei nicht relevant.
 Sie kann wie im Beispiel auch als private deklariert werden.
 Durch den Aufzählungstyp SendMessageOptions ist es möglich zu spezifizeren,
 ob ein Empfänger zwingend erforderlich ist.
 Wenn dieser als erforderlich gekennzeichnet wurde und dennoch kein Empfänger
 gefunden wird, wirft SendMessage eine Exception zur Laufzeit.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessagePublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		SendMessage("Receive");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessageSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendung von SendMessage
\begin_inset CommandInset label
LatexCommand label
name "fig:SendMessage"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
SendMessage verwendet 
\begin_inset Quotes gld
\end_inset

Magic Strings
\begin_inset Quotes grd
\end_inset

 zur Identifikation der Callback-Methode.
 Refactorings der Methodennamen haben keinen Einfluss.
 Auch hier ist es nicht ersichtlich, dass die private Methode als Callback
 genutzt wird.
 Nach dem YAGNI Prinzip werden nicht verwendete private Methode einfach
 gelöscht.
 SendMessage legt implitzit eine Anordnung in der Hierarchie fest.
\end_layout

\begin_layout Standard
Aus diesen Gründen ist der Nutzung von SendMessage generell abzuraten.
 Besonders, da mit der Unity Version 4.6 ein neues Messaging System als Ersatz
 für SendMessage vorgestellt wurde.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/Manual/MessagingSystem.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
UnityEngine.EventSystems (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static bool Execute(GameObject target, EventSystems.BaseEventData
 eventData, EventFunction<T> functor);
\end_layout

\begin_layout Plain Layout

public static GameObject ExecuteHierarchy(GameObject root, EventSystems.BaseEvent
Data eventData, EventFunction<T> callbackFunction);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Event System wurde in Verbindung mit uGUI in Unity 4.6 eingeführt.
 Es wird dazu verwendet um Events bei Nutzereingaben zu senden.
 Man kann es jedoch auch für benutzerdefinierte Events verwenden.
 Anstelle eines Strings wird ein Interface verwendet um eine Komponente
 zu kennzeichnen, die eine Callback-Funktion für ein bestimmtes Event implementi
eren.
 Events können mittels ExecuteHierarchy in der Objekthierarchie nach oben,
 jedoch nicht nach unten, gesendet werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.EventSystems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.Execute<IEventTarget>(this.gameObject, null, (target, data)
 => target.Receive());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IEventTarget : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void Receive();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour, IEventTarget 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwenden von UnityEngine.EventSystems
\end_layout

\end_inset


\end_layout

\end_inset

Das neue EventSystem ist ein typsicherer Ansatz Events an Komponenten in
 der Szenehierarchie zu senden.
 Ohne das Spielobjekt der Empfängerkomponente zu kennen, kann jedoch nur
 an das eigene oder direkte parent Spielobjekte gesendet werden.
 
\end_layout

\begin_layout Section
Wertung und Konsequenzen
\end_layout

\begin_layout Standard
Unitys Komponentenbasierte Architektur hilft dabei Klassen mit nur einer
 Verantwortung zu erstellen.
 Spielobjekte lassen sich durch Komposition aus Komponenten in der Szenehierarch
ie arrangieren.
 Sobald Komponenten jedoch Kommunizieren müssen oder Abhängigkeiten zu anderen
 Objekten haben, muss sich für ein Kommunikationsmittel entschieden werden.
 Unity stellt unterschiedliche Wege zur Kommunikation mit anderen Komponenten
 bereit.
 Eine Sache haben jedoch alle Methoden miteinander gemeinsam: Das andere
 Objekt muss eine Komponente sein.
 Dies führt dazu, dass Objekte nur aus dem Grund der Kommunikation von MonoBehav
iour ableiten.
 
\end_layout

\begin_layout Itemize
Scripts about never affect just one object.
 Sometimes they do not affect an object at all
\end_layout

\begin_layout Itemize
other objects can only be created within components
\end_layout

\begin_layout Itemize
unless they are a singleton
\end_layout

\begin_layout Itemize
No way to keep state (data) independent of a game object
\end_layout

\begin_layout Itemize
This forces Developers to Create “Manager” GameObjects
\end_layout

\begin_layout Itemize
Polymorphismus kann trotzdem genutzt werden
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Stichpunkte Entfernen!}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Dependency Injection in Unity3D
\end_layout

\begin_layout Standard
Aus dem Fazit des letzten Kapitels geht hervor, dass keine der in Unity
 zur Verfügung stehenden Kommunikationsmechanismen den gewünschten Ansprüchen
 entsprechen.
 Das Ziel lose Kopplung in Unity umzusetzen, besteht weiterhin.
 Weiter wurde im letzten Kapitel festgestellt, das Unity Programmierer in
 vieler Hinsicht einschränkt.
 Unter Anderem ist die Kontrolle über die Komposition von Objekten bereits
 invertiert.
 In diesem Kapitel soll beschrieben werden, wie es dennoch ermöglich wurde
 Dependency Injection in Unity umzusetzen.
 
\end_layout

\begin_layout Section
Automating Dependency Injection
\end_layout

\begin_layout Standard
In Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Composition-Root"

\end_inset

 wurde verdeutlicht, wie Dependency Injection 
\begin_inset Quotes gld
\end_inset

per Hand
\begin_inset Quotes grd
\end_inset

 angewendet werden kann.
 Benötigte Instanzen werden manuell im Composition Root instanziiert.
 In dem gezeigten Beispiel war dies noch sehr überschaubar.
 In einer echten Anwendung entstehen jedoch schnell komplexe Abhängigkeitshierar
chien, die eine Dependency Injection von Hand unübersichtlich und fehleranfällig
 machen.
 Aus diesem Grund wird sich oft dazu entschlossen, die Auflösung von Abhängigkei
ten zu automatisieren.
 
\end_layout

\begin_layout Standard
In Unity ist diese Automatisierung sogar notwendig.
 Die Kontrolle über die Erstellung von Komponenten liegt in den Händen von
 Unity.
 Es ist nicht möglich Komponenten über den Konstruktor mit ihren Abhängigkeiten
 zu versorgen.
 Es existiert kein klarer Einstiegspunkt in die Anwendung der es ermöglichen
 würde Komponenten von aussen mit ihren Abhängigkeiten zu versorgen.
 Beim laden einer Szene werden alle sich in ihr befindlichen Spielobjekte
 instanziiert.
\end_layout

\begin_layout Standard
Die Kontrolle über die Komposition von Objekten soll an einen sogenannten
 Inversion Of Control Container abgegeben werden.
 Im Composition Root wird vom Nutzer lediglich die Konfiguration des Containers
 vorgenommen.
 Die zu instanziierenden Typen werden registriert.
 Der Container kümmert sich um alles weitere: Er versorgt alle Klassen mit
 ihren registrierten konkreten Abhängigkeiten und managt die Lebenszeit
 aller Objekte.
 Im Folgenden wird eine Möglichkeit der Implementation eines Inversion Of
 Control Containers in Unity beschrieben.
 Dabei soll besonders darauf eingegangen werden, wo aufgrund von Unitys
 Architektur einschränkungen gemacht werden müssen.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Stichpunkte entfernen!}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Die Kontrolle über die Komposition von Objekten ist bereits invertiert,
 Sie liegt in den Händen von Unity
\end_layout

\begin_layout Itemize
Es gibt keine Konstruktoren
\end_layout

\begin_layout Itemize
Die Instanziierung und Ausführung von Spielobjekten und Komponenten wird
 von Unity übernommen
\end_layout

\begin_layout Itemize
Soweit nicht anders spezifiziert, erfolgt die Aufrufreihenfolge von Scripten
 zufällig nach der Reihenfolge in der sie geladen werden
\end_layout

\begin_layout Itemize
Es ist möglich, eine Reihenfolge in den Script Execution Order settings
 anzugeben
\end_layout

\begin_layout Itemize
Aufgrund der fehlender Main und Constructors ist es nicht möglich Scripte
 von aussen mit ihren Abhängigkeiten zu versorgen
\end_layout

\begin_layout Itemize
Aus diesem Grund stellt unity wege bereit, wie das Script seine Abhängigkeiten
 auflösen kann
\end_layout

\begin_layout Section
Umsetzung eines Inversion Of Control Containers für Unity
\end_layout

\begin_layout Standard
Der folgende Abschnitt beschreibt die Umsetzung eines Inversion Of Control
 Containers für Unity.
 Als Name für das Framework wurde der Einfachheit halber 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

 gewählt.
 Anhand der Implementierung des Frameworks sollen die mit Inversion Of Control
 Containern verbundenen Konzepte erläutert werden.
 Weiter sollen Hürden und Einschränkungen, die aus Unity‘s Architektur hervorgeh
en, beschrieben werden.
 Es sollen Lösungen für diese präsentiert werden.
 
\end_layout

\begin_layout Subsection
Definieren des Composition Roots
\begin_inset CommandInset label
LatexCommand label
name "sub:Definieren-des-Composition"

\end_inset


\end_layout

\begin_layout Standard
In Unity steht kein klarer Einstiegspunkt in die Anwendung zur Verfügung.
 Es existiert kein Zugriff auf eine Main-Methode in der der Kontrollfluss
 der Anwendung beginnt.
 Der frühste Zeitpunkt an dem der Nutzer Einfluss auf den Kontrollfluss
 der Anwendung nehmen kann, ist die Awake-Methode einer Komponente.
 Zu diesem Zeitpunkt wurden die alle in der Szene plazierten Spielobjekte
 mitsamt ihren Komponenten bereits instanziiert.
 Soweit nicht anders spezifiziert erfolg die Aufrufreihenfolge der Awake-Methode
n der Komponenten zufällig nach der Reihenfolge in der sie geladen werden.
 Es ist jedoch möglich in den Script Execution Order Settings anzugeben,
 dass ein bestimmtes Script früher oder später geladen werden soll.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/Manual/class-ScriptExecution.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ExecutionOrderSettings.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Script Execution Order Settings mit Composition Root Komponente an oberster
 Stelle
\begin_inset CommandInset label
LatexCommand label
name "fig:Script-Execution-Order"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zur Definition des Composition Roots wird also zunächst ein einfaches MonoBehavi
our erstellt und einem leeren GameObject in der Szene hinzugefügt.
 Um sicherzustellen, dass dieses MonoBehaviour auch das erste Script ist
 welches bei Anwendungsstart ausgeführt wird, sollte es in den Execution
 Order Settings an oberster Stelle stehen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Script-Execution-Order"

\end_inset

 zeigt die korrekte Konfiguration eines CompositionRoots in den Script Execution
 Order Settings.
 Damit ist gewährleistet, dass der Composition Root Zugriff auf alle sich
 in der Szene befindlichen Komponenten hat, bevor diese ausgeführt werden.
 Im Composition Root kann nun die Konfiguration des IoC Containers vorgenommen
 werden und Komponenten mit ihren Abhängigkeiten versorgt werden.
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:CompositionRoot-Klasse"

\end_inset

 zu sehen ist, wurde im 
\begin_inset Quotes gld
\end_inset

Containter
\begin_inset Quotes grd
\end_inset

-Framework der Composition Root als abstrakte Klasse definiert.
 Die Aufgabe der Klasse ist zunächst eine Instanz eines Binders zu erstellen.
 Der Binder bildet das Herzstück des Frameworks.
 Durch ihn können abstrakte Basisklassen an ihre konkreten Instanzen 
\begin_inset Quotes gld
\end_inset

gebunden
\begin_inset Quotes grd
\end_inset

 werden.
 Diese Typregistrierung soll in der Methode SetupBindings vorgenommen werden.
 Umgehend danach wird die Init-Methode aufgerufen.
 In ihr kann weitere Initialisierungslogik vorgenommen werden.
 Beide Methoden sind abstrakt, da die Typregistrierung für jede Applikation
 individuell erfolgen muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Container.Framework
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract class CompositionRoot : UnityEngine.MonoBehaviour
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		protected IBinder container;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		protected virtual void Awake()
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container = new Binder();
\end_layout

\begin_layout Plain Layout

			SetupBindings();
\end_layout

\begin_layout Plain Layout

			Init();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void SetupBindings();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Klasse CompositionRoot.cs 
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot-Klasse"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die Umsetzung des Composition Roots abgeschlossen.
 Es fehlt jedoch noch die Implementation des Binders/Containers an sich.
 Im Folgenden soll beschrieben werden, wie dieser im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework umgesetzt wurde.
\end_layout

\begin_layout Subsection
Aufgaben eines Dependency Injection Containers
\end_layout

\begin_layout Standard
Bevor mit der Implementierung des Binders begonnen werden kann, müssen zunächst
 dessen grundlegenden Aufgaben erläutert werden.
 Die Hauptaufgabe eines Dependency Injection Containers ist die Erstellung
 von Objekten.
 Hierfür muss dem Container bekannt sein, wie der Objekt Graph der Anwendung
 aufzulösen ist.
 Dem Nutzer des Containers muss es folglich ermöglicht werden, ihn zu Konfigurie
ren: Er muss auswählen können, welche konkreten Implementationen einer Abstrakti
on injektziert werden sollen.
 Die Register-Methoden bilden diese Funktionalität ab.
\end_layout

\begin_layout Standard
Mit der Aufgabe der Erstellung von Objekten, geht eine weitere Aufgabe einher:
 Die Kontrolle über die Lebensdauer der Objekte.
 Der Container muss bestimmen wann eine Instanz eines Objektes erstellt
 werden soll und wann diese nicht mehr gebraucht wird.
 Hierfür ist es für den Container wichtig den Sichtbarkeitsbereich (Scope)
 eines Objektes zu kennen.
 Der Sichtbarkeitsbereich beschreibt Im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework soll sich auf zwei Arten des Sichtbarkeitsbereiches beschränkt
 werden: Transient und Singleton.
\end_layout

\begin_layout Subsubsection
Register Transient (Default-Scope)
\end_layout

\begin_layout Standard
Wird eine Klasse beim Container mit der Lebensdauer Transient registriert,
 so wird dieser bei jeder Anfrage zur Auflösung eine neue Instanz des Typs
 liefern.
 Instanzen können unabhängig voneinander Zustand halten.
 Aus diesem Grund ist Transient die sicherste Variante der Sichtbarkeitsbereiche.
 Sollte es beispielsweise Zweifel an der Threadsicherheit einer Klasse geben,
 sollte diese als Transient registriert werden.
 Die Möglichkeit Klassen als Transient zu registrieren, soll vom Container
 in der Methode RegisterTransient implementiert werden.
\end_layout

\begin_layout Subsubsection
Register Singleton
\end_layout

\begin_layout Standard
Im Gegensatz zu Transient wird bei der Singleton Lebensdauer bei jeder Anfrage
 zur Auflösung eines Typs die selbe Instanz geliefert.
 Zur Registrierung eines Objektes mit Singleton Lebensdauer soll die Methode
 RegisterInstance dienen.
 Genauso wie beim Singleton Entwurfsmuster kann die Instanz entweder Eager
 oder Lazy instanziiert werden.
 
\end_layout

\begin_layout Standard
Die Singleton Lebensdauer sollte nicht mit dem Singleton Entwurfsmuster
 verwechselt werden: Ein Container liefert immer die selbe Instanz eines
 Typs, jedoch verwendet er im Gegensatz zum Singleton Entwurfsmuster hierzu
 keine statische Membervariable.
 Der Sichtbarkeitsbereich eines als Singleton registrierten Typs ist der
 des Containers an dem er registriert wurde.
 Durch die Definition von mehr als einem Context, ist möglich mehrere Container
 zu verwenden.
 Somit ist es auch möglich, dass unterschiedliche Container eine unterschiedlich
e Instanz liefern.
\end_layout

\begin_layout Subsubsection
Resolve
\end_layout

\begin_layout Standard
Analog zu den Register-Methoden liefert die Methode Resolve eine zuvor registrie
rte Instanz eines Typs.
 Mit dieser Instanz soll auch ihr gesamter Abhängigkeitsgraph instanziiert
 werden.
 In den meisen Fällen genügt ein einmaliger Aufruf der Resolve-Methode für
 das Root-Objekt des Object Graphs.
 
\end_layout

\begin_layout Subsubsection
Release
\end_layout

\begin_layout Standard
Üblicherweise gehört zu dem Management der Lebensdauer eines Objektes, zu
 bestimmen was mit Objekten geschieht die sich ausserhalb des Sichtbarkeitsberei
ches befinden.
 Mit dem Aufruf einer Release-Methode soll der Speicherbereich eines nicht
 mehr benötigten Objekts korrekt freigegeben werden.
 In .NET ist dies jedoch in den meisten Fällen nicht nötig da ein Objekt,
 welches nicht mehr referenziert wird, vom Garbage-Collector entfernt wird.
 Aus diesem Grund wurde beim 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework wurde auf die Implementierung einer Release-Methode verzichtet.
 
\end_layout

\begin_layout Subsubsection
Das Interface des DI Containers
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IBinder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void RegisterTransient<TInter, TClass>() where TClass : class, TInter;
\end_layout

\begin_layout Plain Layout

	void RegisterInstance<TInter, TClass>(TClass instance = null) where TClass
 : class, TInter;
\end_layout

\begin_layout Plain Layout

	T Resolve<T>();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Minimales IBinder Interface
\begin_inset CommandInset label
LatexCommand label
name "fig:Minimales-IBinder-Interface"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aus den beschriebenen Aufgaben ergibt sich das in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Minimales-IBinder-Interface"

\end_inset

 gezeigte Interface des zu implementierenden DI Containers.
 Im nächsten Abschnitt wird die konkrete Implementation der Klasse Binder
 beschrieben.
\end_layout

\begin_layout Subsection
Implementation des Dependency Injection Containers
\end_layout

\begin_layout Standard
Die Implementation beginnt mit der Erstellung der Klasse Binder, die das
 IBinder Interface implementiert.
 Um eine grundlegende Typregistrierung vornehmen zukönnen, müssen die Zuordnunge
n abgespeichert werden.
\end_layout

\begin_layout Subsubsection
Registrieren und Speichern von Typzuordnungen
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Binder : IBinder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, Type> transientMap = new Dictionary<Type,
 Type>();
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, object> singletonMap = new Dictionary<Type,
 object>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterTransient<TInter, TClass>() where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		transientMap[typeof(TInter)] = typeof(TClass);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterInstance<TInter, TClass>(TClass instance = null) where
 TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//Eager instantiation of Singleton Objects
\end_layout

\begin_layout Plain Layout

		if (instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			instance = (TClass)Instantiate(typeof(TClass));
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		singletonMap[typeof(TInter)] = instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RegisterMappings in Binder.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:RegisterMappings"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RegisterMappings"

\end_inset

 zeigt die Implementation der beiden Register-Methoden in Binder.cs.
 Um die Registrierung abzuspeichern werden zwei Dictionaries als Datenstruktur
 verwendet.
 Dabei werden in beiden Methoden die Abstraktionen als Schlüssel verwendet.
 Der Unterschied zwischen Transient und Singleton besteht in der Speicherung
 der Datenwerte: Bei der Registrierung als Transient wird der Typ der konkreten
 Klasse als Wert in der transientMap abgespeichert.
 Bei der Registrierung eines Singletons wird eine konkrete Instanz der Klasse
 gespeichert.
 Diese Instanz kann als Parameter übergeben werden.
 Wie man sehen kann ist es nicht zwingend notwendig eine Instanz bereitzustellen.
 Für diesen Fall wurde sich dazu entschieden, direkt eine eager Intantiation
 vorzunehmen.
 Die Implementation der Instantiate-Methode wird zu einem späteren Zeitpunkt
 in dieser Arbeit erklärt.
\end_layout

\begin_layout Subsubsection
Implementation der Resolve-Methode
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Resolve"

\end_inset

 zu sehen ist, delegiert die generische Resolve-Methode ihren Aufruf an
 eine nicht-generische Version.
 Diese prüft zunächst ob eine Instanz in der Singleton-Registrierung vorliegt
 und gibt diese zurück.
 Ist der Typ jedoch als Transient registriert, so soll eine Instanz des
 in der transientMap registrierten konkreten Typs erstellt werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public T Resolve<T>()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = typeof(T);
\end_layout

\begin_layout Plain Layout

	return (T)Resolve(type);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private object Resolve(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (singletonMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = singletonMap[type];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else if (transientMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = Instantiate(transientMap[type]);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		throw new Exception("Couldn't resolve binding for " + type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation der Resolve-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Resolve"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Instanziieren von Klassen basierend auf Typinformationen
\end_layout

\begin_layout Standard
Die tatsächliche Erstellung von Objekten übernimmt die Instantiate-Methode
 in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Instantiate-Methode"

\end_inset

 der Klasse Binder.
 Unter Vorgabe eines konkreten Typs eine Instanz dieses Typs gelierfert
 werden.
 Die Methode nutzt eine Methode namens CreateInstance der Systemklasse Activator.
 Es sind jedoch noch weitere Informationen über die Klasse notwendig.
 Dies ist zum einen der zu verwendende Konstruktor der Klasse mitsamt seinen
 Parametern und zum Anderen Porperties in die Abhängigkeiten injektziert
 werden sollen.
 Über die GetConstructor-Methode erhält der Containter Informationen über
 den Konstruktor den er zur Erstellung des Objektes nutzen soll.
 Dieser kann vom Nutzer des Containers spezifiziert werden.
 Um zu beschreiben, wie dies genau von statten geht, müssen zunächst die
 zwei Sprachfeatures von C# die diese Funkionalität ermöglichen, vorgestellt
 werden: Attributes und Reflection.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	var constructor = GetConstructor(type);
\end_layout

\begin_layout Plain Layout

	if (constructor != null)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var paramInfos = constructor.GetParameters();
\end_layout

\begin_layout Plain Layout

		var paramInstances = ResolveParameters(paramInfos);
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type, paramInstances);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//No constructor defined, use the default constructor
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	InjectProperties(instance);
\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Instantiate-Methode in Binder.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:Instantiate-Methode"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attribute
\end_layout

\begin_layout Standard
Mittels Attributen lassen sich Metadaten für Programmcodeelemente definieren.
 Diese Metadaten sind Informationen, die von der Anwendung zur Laufzeit
 ausgewertet werden können.
 Es können praktisch alle Elemente des Programmcodes mit Metadaten versehen
 werden: Assemblys, Klassen, Methoden, Eigenschaften usw.
\begin_inset Foot
status open

\begin_layout Plain Layout
https://msdn.microsoft.com/de-de/library/z0w1kczw.aspx
\end_layout

\end_inset

 Ein Beispiel ist das bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Referenzieren"

\end_inset

 gezeigte SerializeField-Attribut.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendung-Attribute"

\end_inset

 zeigt eine Membervariable, der das SerializeField-Attribut zugewiesen wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\begin_layout Plain Layout

private Text sampleWithAttribute;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für die Verwendung eines Attributes
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendung-Attribute"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für den DI Container sind im Grunde zwei Metadaten einer Klasse relevant:
 Ihm muss bekannt sein welcher Konstruktor zur Instanziierung eines Objektes
 verwendet werden soll und in welche Properties Abhängigkeiten injektziert
 werden sollen.
 Es ist ausreichend ein einziges benutzerdefiniertes Attribut zu definieren,
 um beide Funktionalitäten abzubilden.
 Bei der späteren Auswertung des Attributes kann geprüft werden, ob sich
 dieses an einem Konstruktor oder einem Property befindet und dementsprechend
 gehandelt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Definition-des-Inject-Attributs"

\end_inset

 zeigt die Erstellung des InjectAttribute-Attributes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Constructor)]
\end_layout

\begin_layout Plain Layout

public class InjectAttribute : Attribute
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Definition des Inject-Attributs
\begin_inset CommandInset label
LatexCommand label
name "fig:Definition-des-Inject-Attributs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird zunächst eine Klasse definiert, die von der Klasse Attribute ableitet.
 Um die Gültigkeit des Attributes festzulegen, wird die Klasse selbst mit
 einem AttributeUsage-Attribut gekennzeichnet.
 Im Fall des Inject-Attributs wird die Gültigigkeit auf Properties und Konstrukt
oren beschränkt.
 Bei der Verwenung entspricht der Attributname dem Klassennamen des Attributs.
 Die Endung Attribute kann weggelassen werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendungmöglichkeiten"

\end_inset

 zeigt die gültigen Verwendungmöglichkeiten des Inject-Attributes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleClass
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//Alternativ [InjectAttribute]
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public ISomeProperty property { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleClass(ISomeDependency first, IAnotherDependency second)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendungmöglichkeiten des Inject-Attributes
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendungmöglichkeiten"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reflektion
\end_layout

\begin_layout Standard
Der Zugriff auf die mit dem Inject-Attribut gekennzeichneten Attribute erfolgt
 mittels Reflektion.
 Reflektion ermöglicht das Auslesen und Auswerten von Metadaten eines Assemblys
 oder Typs zur Laufzeit.
 Metadaten werden über die System.Type-Klasse abgebildet.
 Diese wurde bereits an einigen Stellen zur Implementation des Containers
 verwendet.
 Es wurde also genaugenommen bereits Reflektion eingesetzt.
 
\end_layout

\begin_layout Standard
Bei der Implementation des Containers wird an zwei Stellen intensiver Zugriff
 auf die Typinformationen des zu instanziierenden Objekts benötigt.
 Als erstes muss mittels Reflektion herausgefunden werden, welcher Konstruktor
 zur Instanziierung genutzt werden soll.
 Diese Funktionalität wird von der Methode GetConstructor in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Zugriff-auf-Typinformationen"

\end_inset

 implmentiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private ConstructorInfo GetConstructor(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var constructors = type.GetConstructors();
\end_layout

\begin_layout Plain Layout

	ConstructorInfo constructor;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (constructors.Length == 1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors[0];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors.Single(x => Attribute.IsDefined(x, typeof(InjectAttri
bute)));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return constructor;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zugriff auf Typinformationen mittels Reflektion in der Methode GetConstructor
\begin_inset CommandInset label
LatexCommand label
name "fig:Zugriff-auf-Typinformationen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methode GetConstructors der Klasse Type liefert Informationen zu allen
 definierten Konstruktoren einer Klasse.
 Um den gewünschten, mit dem Inject-Attribut gekennzeichneten Konstruktor
 zu erhalten, wird über die vorhandenen Konstruktoren iteriert und der gewünscht
e Konstruktor mithilfe der statischen Methode IsDefined der Klasse Attribute
 identifiziert.
 Existiert nur ein einziger Konstruktor für einen Typ, muss dieser nicht
 explizit mit dem Inject-Attribut gekennzeichnet werden, um vom Container
 zu Instanziierung genutzt zu werden.
\end_layout

\begin_layout Standard
Betrachtet man die Instantitate-Methode in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Instantiate-Methode"

\end_inset

 ein weiteres Mal, stellt man fest, dass bevor die tatsächliche Instanziierung
 über den Konstruktor vorgenommen wird, zunächst alle Parameter instanziiert
 werden müssen.
 Diese Aufgabe übernimmt die Methode ResolveParameters aus Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Auflösen-Konstruktorparameter"

\end_inset

.
 Es wird über die Parameterinformationen des Konstruktors iterriert und
 alle Parameter der Reihe nach instanziiert.
 Dies geschieht über einen rekursiven Aufruf der Resolve-Methode.
 Somit ist es Vorraussetzung, dass alle Typen der Konstruktorparameter zuvor
 bei dem Container registriert wurden.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object[] ResolveParameters(ParameterInfo[] parameterInfos)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var parameters = new object[parameterInfos.Length];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < parameters.Length; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var parameterInfo = parameterInfos[i];
\end_layout

\begin_layout Plain Layout

		parameters[i] = Resolve(parameterInfo.ParameterType);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return parameters;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen der Konstruktorparameter durch die ResolveParameters-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-Konstruktorparameter"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nach der Instanziierung eines Typs, ist es notwendig die Klasse mit Abhängigkeit
en die in Form von Properties vorliegen zu versorgen.
 Die Methode InjectProperties, gezeigt in der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Auflösen-von-Properties"

\end_inset

, bildet diese Funktionalität des Containers ab.
 In diesem Fall werden Informationen zu Properties mit dem Inject-Attribut
 über die Methode GetProperties der Klasse Type geliefert.
 Im nächsten Schritt wird über die PropertyInfos iteriert und mittels Aufruf
 der Resolve-Methode eine Instanz des Properties geholt.
 Diese Instanz wird danach dem Property des Objektes mittels SetValue-Methode
 zugewiesen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void InjectProperties(object instance)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = instance.GetType();
\end_layout

\begin_layout Plain Layout

	var propertyInfos = type.GetProperties().Where(prop => Attribute.IsDefined(prop,
 typeof(InjectAttribute))).GetEnumerator();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (propertyInfos.MoveNext())
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var propertyInfo = propertyInfos.Current;
\end_layout

\begin_layout Plain Layout

		var propertyInstance = Resolve(propertyInfo.PropertyType);
\end_layout

\begin_layout Plain Layout

		propertyInfo.SetValue(instance, propertyInstance, null);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen von Properties durch die InjectProperties-Methode
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-von-Properties"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die grundlegende Implementation des Containers abgeschlossen.
 Zur optimalen Zusammenarbeit mit Unity sollten jedoch noch einige Erweiterungen
 vorgenommen werden.
 Diese Erweiterungen sollen im folgenden Abschnitt beschrieben werden.
\end_layout

\begin_layout Subsection
Erweiterungen des Containers für die Zusammenarbeit mit Unity
\end_layout

\begin_layout Standard
Damit bessere Zusammenarbeit des Containers mit Unity gewährleistet werden
 kann, sollten noch ein paar Erweiterungen an diesem vorgenommen werden.
 Es gibt beispielsweise derzeit keine Möglichkeit Abhängigkeiten in MonoBehaviou
rs zu injekzieren.
\end_layout

\begin_layout Subsubsection
Injecting into MonoBehaviours
\end_layout

\begin_layout Standard
Wie bereits in den vorigen Abschnitten festgestellt, übernimmt Unity selbst
 die Verantwortung über die Erstellung von MonoBehaviours.
 Es folglich keinen Konstruktor über den Abhängigkeiten aufgelöst werden
 können.
 Es muss sich auf Property-Injection beschränkt werden.
 Dabei ist zu berücksichtigen, dass MonoBehaviours bereits in der Szene
 existieren, bevor die Awake-Methode des Composition Roots aufgerufen wird.
 Desweiteren können Spielobjekte und MonoBehaviours auch zur Laufzeit instanziie
rt werden.
 In beiden Fällen muss es ermöglicht werden, dass diese ihre Abhängigkeiten
 erhalten.
 Im Folgenden sollen drei Ansätze hierfür erläutert werden: Das Verwenden
 des Containers als Service Locator, Factories und ExecuteEvents als MonoBehavio
ur-Extension.
\end_layout

\begin_layout Subsubsection
Service Locator
\end_layout

\begin_layout Standard
Eine mögliche Lösung für das Problem ist die Verwendung des Containers als
 Service Locator.
 Bei einem ServiceLocator handelt es sich um einen statischen Wrapper für
 den Container.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Service-Locator"

\end_inset

 zeigt eine mögliche Implementation des Service Locator Patterns unter Verwendun
g der Binder-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class ServiceLocator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private static readonly IBinder binder = new Binder();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterTransient<TInter, TClass>() where TClass : class,
 TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.RegisterTransient<TInter, TClass>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterInstance<TInter, TClass>(TClass instance = null)
 where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.RegisterInstance<TInter, TClass>(instance);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static T Resolve<T>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return binder.Resolve<T>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Service Locators
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Service-Locator"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Konfiguration des ServiceLocators würde, wie die des Containers, in
 der zuvor definierten CompositionRoot-Klasse stattfinden.
 Der Unterschied zwischen einem ServiceLocator und einem DI Container liegt
 nicht in der Implemenation sondern in der Verwendung.
 Die Verwendung der Resolve Methode des DI Containers beschränkt sich üblicherwe
ise auf einen einzigen Aufruf im Composition Root und setzt somit die rekursive
 Auflösung des gesamten Objektgraphs in Gang.
 Wird ein Service Locator verwendet, können Abhängigkeiten von überall im
 Programm durch Aufruf der Resolve-Methode angefordert werden.
 MonoBehaviours würden also in der Awake-Methode durch Anfrage beim ServiceLocat
or ihre Abhängigkeiten erhalten.
 
\end_layout

\begin_layout Standard
Auf den ersten Blick scheinen keine Vorteile bei der Verwendung des Service
 Locators verloren zu gehen: Abhängigkeiten sind lose gekoppelt, die Programmier
ung im parallelen ist gewährleistet und Testbarkeit ist durch Konfiguration
 des Service Locators in der Testumgebung möglich.
 Trotzdem wird der Service Locator oft als Anti-Pattern angesehen.
 Klassen haben eine unnötige konkrete Abhängigkeit an den Service Locator.
 Die Klasse wird explizit für eine Verwendung mit dem Service Locator implementi
ert.
 Von Aussen ist es nicht sichtbar, dass die Klasse andere Abhängigkeiten
 hat.
 Es kann keine Aussage darüber getroffen werden, welche Abhängigkeiten notwendig
 sind, damit eine Klasse funktioniert.
 
\end_layout

\begin_layout Standard
Jedoch ermöglicht der Service Locator die Auflösung von Abhängigkeiten eines
 MonoBehaviours.
 Die Verwendung des ServiceLocators kann auf MonoBehaviours reduziert werden
 und in diesem Fall als notwendig angesehen werden.
 Das Problem ist jedoch, dass der Service Locator, aufgrund der globalen
 Sichtbarkeit als statische Klasse, von unwissenden Programmierern auch
 in anderen Bereichen genutzt werden kann.
 Im folgenden sollen zwei weitere Möglichkeiten vergestellt werden, mit
 denen sich Abhängigkeiten eines MonoBehaviours lassen.
 Alle haben ihre Vor- und Nachteile.
 Der Service Locator ist die einfachste, aber zugleich auch die am wenigsten
 elegante Lösung des Problems.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes gld
\end_inset

Inject
\begin_inset Quotes grd
\end_inset

-Event als MonoBehaviour-Extension
\end_layout

\begin_layout Standard
Die Grundidee dieser Methode ist, dem Container über einen Event bescheid
 zu geben, dass ein MonoBehaviour in der Szene erstellt wurde und dessen
 Abhängigkeiten aufgelöst werden müssen.
 Hierzu wird die Klasse MonoBehaviour mit der in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Erweiterungsmethode"

\end_inset

 gezeigten Extension erweitert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class MonoInjectionExtension
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Inject(this MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.ExecuteHierarchy<IMonoInjectionHandler>
\end_layout

\begin_layout Plain Layout

			(script.gameObject, null, (target, data) => target.InjectDependencies(script));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Erweiterungsmethode für MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "fig:Erweiterungsmethode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mittels der ExecuteHierarchy-Methode der Klasse ExecuteEvents wird ein Event
 in der Hierarchie nach oben gesendet.
 Das Event soll vom Composition Root entegengenommen werden, damit dieser
 die Aufllösung der Abhängigkeiten an den Container delegieren kann.
 Dazu muss CompositionRoot das für diesen Fall erstellte IMonoInjectionHandler-I
nterface implementieren.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IMonoInjectionHandler"

\end_inset

 zeigt das Interface IMonoInjectionHandler und dessen Implementation vom
 Composition Root.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IMonoInjectionHandler : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void InjectDependencies(MonoBehaviour script);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public abstract class CompositionRoot : IMonoInjectionHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void InjectDependencies(MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation von IMonoInjectionHandler
\begin_inset CommandInset label
LatexCommand label
name "fig:IMonoInjectionHandler"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei dieser Methode is zu Beachten, dass alle Spielobjekte im Szenengraph
 Kindknoten des Composition Roots sein müssen.
 Jedes MonoBehaviour muss im Start-Event explizit die Inject-Erweiterungsmethode
 aufrufen, damit die Abhängigkeiten vom Container aufgelöst werden.
 Dies könnte bereits im Awake-Event geschehen, da durch das Festlegen der
 Script Execution Order in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definieren-des-Composition"

\end_inset

 gewährleistet wurde, dass der Composition-Root den Container bereits initialisi
ert hat.
 Instanziiert man jedoch ein Spielobjekt zur Laufzeit, so muss der Composition
 Root unmittelbar darauf als Elternelement festgelegt werden.
 Es ist nicht möglich ein Spielobjekt direkt als Kindelement eines anderen
 Spielobjekts zu instanziieren.
 Zum Aurufzeitpunkt der Awake-Methode hat noch kein Parenting stattgefunden,
 auch wenn dies unmittelbar nach Instanziierung geschieht.
 Demzufolge sollte die Inject-Methode im Start-Event des MonoBehaviours
 aufgerufen werden.
\end_layout

\begin_layout Standard
Bei Verwendung der beschriebenen Methode ist es nötig, dass der Nutzer des
 Containers sich strikt an die beschriebenen Anweisungen hält.
 Ein Aufruf der Inject-Methode muss im Start-Event erfolgen.
 Alle Spielobjekte müssen Kindobjekte des Composition Roots sein.
 Nachfolgend soll eine letzte Möglichkeit vorgestellt werden, die dem Nutzer
 weniger Verantwortung abverlangt.
\end_layout

\begin_layout Subsubsection
Auflösung des Szenegraphs und Factories
\end_layout

\begin_layout Standard
Bei dieser Methode wird die Auflösung von Abhängigkeiten von MonoBehaviours
 in zwei Teile unterteilt.
 Durch den ersten Teil werden bereits in der Szene existierende MonoBehaviours
 mit ihren Abhängigkeiten versorgt.
 Dies wird bewerkstelligt indem dem CompositionRoot die ResolveScene-Methode
 hinzugefügt wird.
 Diese Methode wird im Awake-Event unmittelbar nach der Konfiguration des
 Containers aufgerufen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ResolveScene"

\end_inset

 zeigt die Änderungen an der CompositionRoot-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container = new Binder();
\end_layout

\begin_layout Plain Layout

		SetupBindings();
\end_layout

\begin_layout Plain Layout

		ResolveScene();
\end_layout

\begin_layout Plain Layout

		Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void ResolveScene()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		foreach (var script in Object.FindObjectsOfType(typeof(MonoBehaviour)))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzugefügte ResolveScene-Methode in CompositionRoot.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:ResolveScene"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um die Abhängigkeiten der existierenden MonoBehaviours aufzulösen, wird
 über alle MonoBehaviours in der Szene iteriert und dem Container mitgeteilt
 alle Properties zu instanziieren.
 Durch das Festlegen der Script Execution Order in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

, wird gewährleistet, dass alle sich in der Szene befindenden MonoBehaviours
 ihre Abhängigkeiten bereits vor dem Aufruf der Awake-Methode erhalten haben.
\end_layout

\begin_layout Standard
Weiter muss der Fall berücksichtigt werden, dass Spielobjekte dynamisch
 zur Laufzeit instanziiert werden können.
 Unmittelbar nach der Instanziierung müssen die Abhängigkeiten aller MonoBehavio
urs des Spielobjektes vom Container aufgelöst werden.
 Damit dies sichergestellt wird und an einem zentralen Ort geschieht, soll
 hierfür eine Factory implementiert werden.
 Über diese Factory sollen alle Spielobjekte zur Laufzeit erstellt werden.
 Das heißt, dass es im Programmcode keine weiteren Aufrufe der Instantiate-Metho
de der Klasse Object geben darf.
 Der einzige Aufruf der Instantiate-Methode findet in der Create-Methode
 der GameObjectFactory-Klasse wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GameObjectFactory"

\end_inset

 dargestellt, statt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GameObjectFactory : IGameObjectFactory
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GameObject Create(GameObject original)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var instance = Object.Instantiate(original);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		foreach (var script in instance.GetComponents<MonoBehaviour>())
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			binder.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		return instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausschnitt GameObjectFactory.cs
\begin_inset CommandInset label
LatexCommand label
name "fig:GameObjectFactory"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Direkt nach dem Instanziieren werden die Properties aller MonoBehaviours
 vom Container instanziiert.
 Es ist sichergestellt, dass MonoBehaviours zum Start-Event über alle Abhängigke
iten verfügen.
 Die GameObjectFactory bietet eine weitere Überladung der Create Methode.
 Aus Platzgründen wurde diese hier ausgelassen.
 Mit ihr lassen sich Prefabs anhand ihres Namens im Resource-Ordner instanziiere
n.
 Spielobjekte die aus dem Resource-Ordner geladen wurden, werden in einem
 Cache zwischengespeichert.
 
\end_layout

\begin_layout Standard
Bei Verwendung dieser Methode muss der Nutzer des Container Frameworks keine
 frameworkspezifischen Operationen innerhalb einer MonoBehaviour-Komponente
 vornehmen.
 Dem Nutzer muss lediglich bewusst sein, dass er die Klasse GameObjectFactory
 zur Instanziierung von Spielobjekten zu Laufzeit verwenden muss.
 Es ist nicht nötig, dass Spielobjekte Kindobjekte des Composition Roots
 sind, um ihre Abhängigkeiten zu erhalten.
 Aus diesem Grund ist aus Sicht des Autors, diese Methode den anderen vorzuziehe
n.
\end_layout

\begin_layout Subsubsection
Injecting MonoBehaviours
\end_layout

\begin_layout Standard
Alle bis jetzt gezeigten Methoden beschreiben wie Abhängigkeiten in MonoBehaviou
rs injektziert werden können.
 An dieser Stelle soll beschrieben werden, wie mit Abhängigkeiten zu anderen
 MonoBehaviours umgegangen werden soll.
 Zunächst sollte überprüft werden, ob es tatsächlich notwendig ist, dass
 die benötigte Klasse von MonoBehaviour erbt.
 Durch strike Trennung der Belange (Seperation Of Concerns) kann dies meist
 auf die Darstellungslogik reduziert werden.
 Die benötigten Komponenten sind meist Unity-eigene Klassen wie Button,
 Label oder RigidBody am selben Spielobjekt.
 In diesen Fällen können sie mithilfe des SerializeField-Attributs im Editor
 gesetzt werden.
 
\end_layout

\begin_layout Standard
Liegen dennoch Gründe vor, dass eine Abhängigkeit zu einem MonoBehaviour
 benötigt wird, könnte dieses theoretisch beim Container registriert werden.
 Vorrausgesetzt es implementiert ein Interface welches die benötigte Funktionali
tät abbildet.
 Das Spielobjekt des MonoBehaviours kann mittels Find-Methode vom Composition
 Root ausfindig gemacht und im Anschluss beim Container registriert werden.
 Die Registration ist somit jedoch auf eine einzige Instanz eines Typs beschränk
t.
 Hiervon wird jedoch ausdrücklich abgeraten.
 Anhand eines Beispiels soll im Folgenden ein alternativer Ansatz beschrieben
 werden.
\end_layout

\begin_layout Standard
Die Idee dieses Ansatzes ist, nicht ein MonoBehaviour, sondern einen Wrapper
 für dieses beim Container zu registrieren.
 Ein Feature eines MonoBehaviours welches auch ausserhalb von diesem benötigt
 werden könnte, ist das Ausführen von Coroutines.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html
\end_layout

\end_inset

 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 zeigt die Verwendung dieses Ansatzes bei der Umsetzung der beschriebenen
 Funktionalität.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunnerBehaviour : MonoBehaviour, ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		DontDestroyOnLoad(transform.gameObject);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunner : ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IGameObjectFactory gameObjectFactory;
\end_layout

\begin_layout Plain Layout

	private readonly ICoroutineRunner coroutineRunnerBehaviour;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public CoroutineRunner(IGameObjectFactory gameObjectFactory)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.gameObjectFactory = gameObjectFactory;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var go = this.gameObjectFactory.Create("CoroutineRunnerPrefab");
\end_layout

\begin_layout Plain Layout

		coroutineRunnerBehaviour = go.GetComponent<ICoroutineRunner>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return coroutineRunnerBehaviour.StartCoroutine(routine);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des CoroutineRunners
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-des-Coroutine"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die gewünschte Funktionalität wird zunächst durch die ICoroutineRunner-Schnittst
elle definiert.
 Die Implementation erfolgt von der Klasse CoroutineRunnerBehaviour indem
 sie von MonoBehaviour erbt.
 Weiter wird die Schnittstelle auch von der Klasse CoroutineRunner implementiert.
 Im Konstruktor erstellt sie, durch den Aufruf der Create-Methode der GameObject
Factory ein Prefab, welches die CoroutineRunnerBehaviour-Komponente besitzt.
 Den Aufruf der StartCoroutine-Methode delegiert die Klasse an diese CoroutineRu
nnerBehaviour-Komponente.
 Die Klasse CoroutineRunner kann ohne Weiteres im Composition Root beim
 Container registriert werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

container.RegisterTransient<ICoroutineRunner, CoroutineRunner>();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sie kann nun in alle anderen Module injekziert und genutzt werden.
 Damit ist eine grundlegende Zusammenarbeit zwischen Unity und dem Inversion
 Of Control-Container gewährleistet.
 Um die gezeigten Beispiele auf das Wesentliche zu reduzieren, wurde auf
 die Darstellung und Implementierung einiger Funktionalitäten verzichtet.
 Diese sollen jedoch im folgenden Abschnitt kurz Erwähnung finden.
\end_layout

\begin_layout Subsection
Weitere Ansatzpunkte zur Erweiterung
\end_layout

\begin_layout Standard
Bei dargestellten Implementierung des Inversion Of Control Containers handelt
 es sich um einen Proof Of Concept.
 Die Funktionsweise, sowie nötige Sprachfeatures sollten beschrieben und
 eine Zusammenarbeit mit Unity gewährleistet werden.
 Auf eine ausführliche Beschreibung aller Details wurde verzichtet.
 So wird beispielsweise das eager- und lazy-loading von Singletons der tatsächli
chen Implementierung 
\begin_inset Foot
status open

\begin_layout Plain Layout
Siehe Anhang!
\end_layout

\end_inset

 unterstützt.
\end_layout

\begin_layout Standard
Auch gibt es zahlreiche Ansatzpunkte zur Erweiterung des Frameworks:
\end_layout

\begin_layout Itemize
Die Verwendung von Reflection führt zu starken Performanceeinbußen.
 Obwohl sich die Aufrufe der Reflection-Bibliotheken zum Großteil auf den
 Programmstart beschränken, sollten diese reduziert werden.
 Die Ergebnisse der Reflection eines Typs sollten gecached und vom Container
 wiederverwendet werden.
\end_layout

\begin_layout Itemize
Das Verhalten bei zirkulären Abhhängigkeiten ist nicht bestimmt.
 Im besten Fall sollten diese gar nicht erst zugelassen werden.
 Es sollte eine Laufzeitexception geworfen werden.
\end_layout

\begin_layout Itemize
Die API zur Konfiguration/Registrierung des Containers kann verbessert und
 erweitert werden.
 Es können Fluent Interfaces zur Erstellung einer Domänenspezifischen Sprache
 verwendet werden.
 Eine weitere Konfigurationsmöglichkeit könnte über JSON oder XML geboten
 werden.
 Der Vorteil einer solchen externen Konfiguration ist, dass das Verhalten
 der Anwendung ohne erneuter Kompilierung geändert werden kann.
\end_layout

\begin_layout Itemize
Bis jetzt wurde die Verwendung des Containers auf eine einzige Szene beschränkt.
 Auf das Verhalten bei der Arbeit mit mehreren Szenen wurde nicht eingegangen.
 Jede Szene könnte einen eigenen Composition Root haben, welcher die nötigen
 Abhängigkeiten der Szenen individuell auflöst.
 Alternativ könnte ein einziger Container in der 
\begin_inset Quotes gld
\end_inset

Haupt
\begin_inset Quotes grd
\end_inset

-Szene die Abhängigkeiten in allen Szenen auflösen.
 Dies ist sinnvoll, wenn alle Szenen gleiche Abhängigkeiten haben.
 Werden Szenen additiv geladen, wäre auch die Erstellung einer Containerhierarch
ie eine Möglichkeit.
 Beim Root-Container werden Abhängigkeiten, die über mehrere Szenen hinweg
 benötigt werden registriert, während Childcontainer spezifische Abhängigkeiten
 der additiv geladenen Szene auflösen.
\end_layout

\begin_layout Itemize
Der Container sollte für eine ordnungsgemäße Entsorgung von Objekten sorgen.
 Im speziellen sollte sichergestellt werden, dass die Dispose-Methode von
 Klassen die IDisposable implementieren aufgerufen wird.
\end_layout

\begin_layout Itemize
Es ist derzeit nicht möglich Logik unmittelbar nach der Injection auszuführen.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 wird diese Beschränkung umgangen, weitere Logik im Konstruktor ausgeführt
 wird.
 Die Gefahr hierbei ist jedoch, dass Properties zu diesem Zeitpunkt noch
 nicht injected wurden.
 Desweiteren sollte das Single-Responcibility-Principle gewahrt werden indem
 im Konstruktor lediglich Initialisierungs-Logik ausgeführt wird.
 Aus diesem Grund sollte ein weiteres Attribut namens Postconstruct vorgestellt
 werden: Methoden die mit dem PostConstruct-Attribut versehen wurden, sollen
 unmittelbar nach dem Injection-Prozess vom Container aufgerufen werden.
\end_layout

\begin_layout Standard
Aus diesen Gründen wird von dem Autor dieser Arbeit davon abgeraten, den
 präsentierten Container zur Entwicklung eines Spiels zu verwenden.
 In dem folgenden Abschnitt sollen ausgereiftere Dependency Injection Container
 für Unity3D vorgestellt und auf ihre Tauglichkeit bei der Entwicklung von
 Spielen untersucht werden.
\end_layout

\begin_layout Section
Übersicht Dependency Injection Container für Unity3D
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten dieser Arbeit wurden Prinzipien, Praktiken
 und Funktionsweise von Dependency Injection und Inversion Of Control Containern
 beschrieben.
 Dieser Abschnitt soll eine Übersicht über die für Unity verfügbaren Inversion
 Of Control Container geben.
 Ihre Funktionsumfänge und Besonderheiten sollen beschrieben werden.
 Oft bieten diese Frameworks Funktionalitäten die weit über Automated Dependency
 Injection hinaus gehen.
\end_layout

\begin_layout Standard
Die vorzustellenden Container wurden speziell für die Verwendung mit Unity
 entwickelt.
 Ein Grund hierfür ist, dass - wie im vorherigen Abschnitt ausführlich beschrieb
en - einige Erweiterungen notwendig sind, um die Verwendung eines Containers
 in Unity zu ermöglichen.
 Ein weiterer Grund ist, dass Unity's Mono Laufzeitumgebung lediglich Kompabilit
ät zum .NET Framework 3.5 aufweist.
 Die meisten existierenden Inversion Of Control Container für .NET verwenden
 .NET 4.0 oder höher.
 
\end_layout

\begin_layout Standard
Das Grundkonzept für die Implementation eines Inversion Of Control Containers
 für Unity lieferte Sebastiano Mandalà im September 2012 in einer Serie
 von Blogeinträgen.
 Auf dieser Basis haben sich mit der Zeit eine Reihe von Frameworks entwickelt.
 Im Folgenden sollen die Frameworks Zenject, adic und StrangeIoC vorgestellt
 werden.
\end_layout

\begin_layout Subsubsection
Zenject
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/modesttree/Zenject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zenject ist ein Dependency Injection Container, der sich aus einem direkten
 Fork des Konzepts von Sebastiano Mandalà entwickelt hat.
 Zusätzlich zu den grundlegenden Funktionalitäten eines DI-Containers bietet
 das Framework eine Vielzahl von Registrierungsoptionen wie zum Beispiel
 die Registrierung von Prefabs und GameObjects oder Injection in spezifische
 Methoden und Getter.
 Darüber hinaus bietet das Framework eine Möglichkeit zur Validierung und
 Visualisierung des Object Graphs: Es kann überprüft werden, dass alle zu
 injizierenden Typen im Object Graph einer Szene beim Container registriert
 sind.
 Es ist möglich eine an UML angelegte graphische Darstellung des Object
 Graphs der Anwendung zu generieren.
\end_layout

\begin_layout Subsubsection
adic
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/intentor/adic
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adic ist ein weiterer Dependency Injection Container für Unity der sich
 vorallem durch seine Einfacheit in Umsetzung und Verwendung auszeichnet.
 Dennoch bietet er die vollständige Funktionalität eines Dependency Injection
 Containers und noch einige weitere Optionen.
 Diese sind unter Anderem: Conditional Bindings, die es ermöglichen eine
 Registrierung eines Typs unter bestimmten Bedingungen vorzunehmen.
 Eine mögliche Bedingung ist beispielsweise, dass Injection eines Typs nur
 über Konstruktoren oder in bestimmte Instanzen erfolgen soll.
 Zudem implementiert adic ein Command- und Eventsystem, das sehr ähnlich
 zu dem von StrangeIoC ist.
 Diese werden im folgenden Abschnitt genauer erläutert.
\end_layout

\begin_layout Subsubsection
StrangeIoC
\begin_inset Foot
status open

\begin_layout Plain Layout
http://strangeioc.github.io/strangeioc/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
StrangeIoC ist ein umfangreiches Inversion Of Control Framework, das weit
 mehr als nur einen Dependency Injection Container bietet.
 Das open-source Projekt verfügt über eine aktive Community, die bemüht
 ist, das Framework kontinuierlich zu verbessern und zu erweitern.
 StrangeIoC ist in großen Teilen von Robotlegs, einem Application Architecture
 Framework für ActionScript, beeinflusst.
 Aus diesem wurde auch das wohl augenscheinlichste Merkmal des Frameworks
 übernommen: Eine MVC(S)-Architektur, mit der sich ein breites Spektrum
 von Anwendungen umsetzen lassen soll.
 Die Architektur vereint eine umfangreiche Anzahl von Konzepten, welche
 in ihrer Gesamtheit eine saubere Trennung von Verantwortungen ermöglichen
 sollen.
 Diese Konzepte und ihr Zusammenwirken als MVC(S)-Architektur sollen im
 folgenden Abschnitt erläutert werden.
\end_layout

\begin_layout Section
MVC(S)-Architektur in Unity mithilfe von StrangeIoC
\end_layout

\begin_layout Standard
Model-View-Controller-Service, oder kurz MVCS, ist ein Architekturmuster,
 welches die Struktur einer Anwendung in vier eigenständige Module unterteilt:
 Model, View, Controller und Service.
 Es erweitert die klassische MVC-Architektur um eine Service-Schicht, unter
 welche der Zugriff auf externe Daten und Dienste, wie Web-Server, Datenbanksyst
eme oder Zugriffe auf das Dateisystem, fallen.
 
\end_layout

\begin_layout Standard
MVCS soll einen konsistenten Ansatz zur Strukturierung einer Anwendung liefern.
 Genauso wie bei der klassischen MVC-Architektur ist die Grundlage hierfür
 Präsentations- von Anwendungslogik zu trennen.
 Diese Trennung erfolgt durch die Definition folgender Schichten: Die Präsentati
onsschicht (View-Layer) ist für die Darstellung der Benutzeroberfläche und
 der Verarbeitung von Interaktionen mit dem Benutzer zuständig.
 Die Modellschicht (Model-Layer) speichert den aktuellen Zustand der Anwendung,
 der durch das Ausführen von Operationen durch den Nutzer und externer Quellen
 resultiert.
 Die Steuerungsschicht (Controller-Layer) stellt Mechanismen zur Interaktion
 und Koordination zwischen den anderen Schichten zur Verfügung.
 
\end_layout

\begin_layout Standard
Zusätzlich zu dem Vorteil der Strukturierung hilft die MVCS-Architektur
 von StrangeIoC die Kopplung zwischen den einzelnen Schichten zu minimieren.
 Damit sollen einzelne Programmabschnitte tesbar und die Austauschbarkeit
 der Darstellungs- und Service-Schicht gewährleistet werden.
 Abhängigkeiten zu externen APIs können in der Service-Schicht gekapselt
 und somit Austauschbar gemacht werden.
 Somit ist es beispielsweise ohne große Umstände möglich, den Zugriff auf
 Daten aus dem lokalen Dateisystem mit dem Remote-Zugriff auf eine Datenbank
 auszutauschen.
\end_layout

\begin_layout Standard
Die Umsetzung der MVC(S)-Architektur weicht stark von der des klassischen
 MVC-Entwurfsmusters ab.
 StrangeIoC verwendet eine Reihe von eigenen Konzepten und Mustern um die
 MVC(S)-Architektur umzusetzten.
\end_layout

\begin_layout Subsection
Umsetzung von MVC(S) in StrangeIoC
\end_layout

\begin_layout Standard
In diesem Abschnitt soll erklärt werden, wie die in StrangeIoC zur Verfügung
 stehenden Konzepte in der MVC(S)-Architektur zusammenspielen.
 Eine schlüssige Zusammenfassung der Architektur liefert ein Schaubild aus
 der Dokumentation (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MVCS-Context"

\end_inset

).
 Wie in der Grafik beschrieben, ist der Einstiegspunkt in die Anwendung
 der ContextView.
 Von ihm wird der eigentliche Context instanziiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Strange_Flow_Chart.png
	lyxscale 20
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild MVC(S) Context Architektur
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCS-Context"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Context und ContextView
\end_layout

\begin_layout Standard
Der Context ist ein von den restlichen Schichten der Architekur unabhängiges
 Modul.
 Grob gesagt handelt es sich um einen Composition Root wie in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

 definiert.
 Mit dem Unterschied, dass es möglich ist mehr als einen Context zu definieren.
 Jeder Context wird an einen ContextView, ein MonoBehaviour in einer bestimmten
 Scene, angehängt.
 Im Context wird wie im Composition Root die Registrierung von Typen beim
 Dependency Injection Container vorgenommen.
 Der Context definiert den Sichtbarkeitsbereich aller bei ihm registrierten
 Typen.
 Es jedoch auch möglich Registrierungen über mehrere Contexte hinweg vorzunehmen.
 StrangeIoC bezeichnet den Container als Binder und die Registrierung als
 Binding.
 Der Grund hierfür ist, dass nicht nur zu injekzierende Abhängigkeiten registrie
rt werden können.
 Es können auch, wie im später noch genauer erläutert wird, Commands an
 Signals und Views an Mediators gebunden werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleContext : MVCSContext
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void mapBindings()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.mapBindings();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IBoardLayoutModel>()
\end_layout

\begin_layout Plain Layout

			.To<BoardLayoutModel>().ToSingleton();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IMovementRules>().To<MovementRules>();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<FieldClickedSignal>().ToSingleton();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<StartSignal>().InSequence()
\end_layout

\begin_layout Plain Layout

			.To<LoadBoardLayoutCommand>()
\end_layout

\begin_layout Plain Layout

			.To<CreateBoardFieldViewsCommand>();
\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<FieldClickedSignal>()
\end_layout

\begin_layout Plain Layout

			.To<ToggleSelectionCommand>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		mediationBinder.Bind<FieldView>().To<FieldMediator>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override IContext Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.Start();
\end_layout

\begin_layout Plain Layout

		var startSignal = injectionBinder.GetInstance<StartSignal>();
\end_layout

\begin_layout Plain Layout

		startSignal.Dispatch();
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Contexts für ein Brettspiel
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Context"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-Context"

\end_inset

 zeigt ein Beispiel eines Contexts: In der mapBindings-Methode erfolgen
 die Typregistrierungen bei den jeweiligen Bindern.
 Abhängigkeiten werden beim InjectionBinder registriert, Commands werden
 über den CommandBinder an Signale gebunden und Views an Mediatoren durch
 den MediationBinder.
 Diese Registrierungen werden immer komplexer mit dem Wachstum der Anwendung.
 Aus diesem Grund können Sie auch in einzelne Klassen ausgelagert werden.
 Ist die Registrierung abgeschlossen, wird die Anwendung durch das Auslösen
 eines Signals in der Start-Methode gestartet.
 An dieses Startsignal wurden zuvor einige Commands gebunden, die nun ausgeführt
 werden.
\end_layout

\begin_layout Subsubsection
Signals
\end_layout

\begin_layout Standard
Signals stellen ein typsicheres Mittel zur Kommunikation zwischen den einzelen
 Architekturschichten dar.
 Signals können Commands auslösen, aber auch wie herkömmliche Events abonniert
 werden.
 Es handelt sich um eine Umsetzung des Observer-Musters, das intern Action-Deleg
aten anstatt Interfaces verwendet.
 Das Auslösen eines Signals erfolgt über die Dispatch-Methode.
 Wurde das Signal beim CommandBinder registriert, so fügt sich dieser als
 Listener hinzu.
 Beim Auslösen des Signals instanziiert der CommandBinder Instanzen der
 hinzugefügten Commands und führt diese aus.
 Damit sind Sender und Empfänger eines Signals komplett voneinander entkoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//Deklaration
\end_layout

\begin_layout Plain Layout

public class FieldClickedSignal : Signal<int>{};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Verwendung
\end_layout

\begin_layout Plain Layout

[Inject]
\end_layout

\begin_layout Plain Layout

public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clickSignal.Dispatch(12);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Deklaration und Verwendung eines Signals
\begin_inset CommandInset label
LatexCommand label
name "fig:Signals-Definition"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Signals-Definition"

\end_inset

 zeigt die Deklaration und Verwendung eines Signals.
 Signals können bis zu vier Parameter haben, dessen Typen als Generika bei
 der Deklaration des Signals definiert werden.
 Diese Parameter werden bei Aufruf in Properties des Commands injekziert.
 Signals sind Typsicher: Fehlerhaftes Aufrufen oder Abonnieren führt zu
 einer Ausnahme zur Laufzeit.
\end_layout

\begin_layout Subsubsection
Commands
\end_layout

\begin_layout Standard
Commands sind zustandslose Controller-Objekte, die ein einzelnes Verhalten
 kapseln.
 Commands werden von Signals ausgelöst: Ein Aufruf der Execute-Methode erfolgt
 automatisch.
 Im Normalfall haben sie eine sehr kurze Lebenszeit: Ein Signal löst die
 Instanziierung und Ausführung des Commands aus.
 Direkt danach erfolgt die Entsorgung.
 Commands bilden die Logik der Anwendung ab, indem sie Manipulationen an
 Models vornehmen, Spielobjekte instanziieren oder mit Services kommunizieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ToggleSelectionCommand : Command
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public int index { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IService service { get; set; } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void Execute()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Retain();
\end_layout

\begin_layout Plain Layout

		service.SendRequestToServer(response => {
\end_layout

\begin_layout Plain Layout

			//...
\end_layout

\begin_layout Plain Layout

			Release();
\end_layout

\begin_layout Plain Layout

		});
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für einen Command
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Command"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der an das Signal aus dem vorigen Beispiel gebundene Command, dargestellt.
 Der beim Auslösen des Signals übergebene Parameter wird bei Instanziierung
 des Commands in das Property 
\begin_inset Quotes gld
\end_inset

index
\begin_inset Quotes grd
\end_inset

 injekziert.
 Commands wird es durch Aufruf der Retain Methode ermöglicht, seine Zerstörung
 zu verzögern.
 Die Ausführung der Anwendung wird nicht eingeschränkt, da der Aufruf eines
 Commands asynchron erfolgt.
 Sehr nützlich ist Erhalten eines Commands beispielsweise bei der Client-Server-
Kommunikation: In dem gezeigten Beispiel in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der Command solange am Leben erhalten bis dieser eine Antwort vom
 Server erhält.
 Dies geschieht durch den Aufruf der Release-Methode im Callback der Anfrage.
\end_layout

\begin_layout Standard
Commands bieten eine sehr effiziente Möglichkeit Anwendungsschichten voneinander
 zu entkoppeln.
 Der Grund hierfür ist, dass sie sich nur durch Signale ausführen lassen:
 Es gibt für Models, Services und Mediatoren keinen Grund überhaupt von
 ihnen zu wissen.
 Models und Mediatoren brauchen lediglich Signale auszulösen um die Ausführung
 der Anwendung in Gang zu legen.
\end_layout

\begin_layout Subsubsection
Views
\end_layout

\begin_layout Standard
Wie bereits erwähnt sind Views oder View-Komponenten für die Darstellung
 der Benutzeroberfläche und der Verarbeitung von Interaktionen mit dem Benutzer
 verantwortlich.
 Dabei ist der Begriff 
\begin_inset Quotes gld
\end_inset

View
\begin_inset Quotes grd
\end_inset

 nicht unbedingt wörtlich zu nehmen: Sie übernehmen jegliche Ein- und Ausgabelog
ik, wie Rendering, Darstellungslogik von User Interfaces, Audioausgabe und
 eventuell Interaktion mit der Physikengine.
 Es sind Aufgaben, für die die Interaktion mit Unity notwendig ist.
 Aus diesem Grund sind Views MonoBehaviours.
 Sie beinhalten jedoch keinerlei Anwendungslogik und kommunizieren lediglich
 zu ihren Mediatoren über Events.
 Ansonsten sind sie komplett autonome Komponenten, die ausschließlich ihren
 eigenen Zustand manipulieren können.
 Aus diesem Grund sollten auch keine Injections in MonoBehaviours vorgenommen
 werden.
 Die Absicht hierbei ist, das Unity-Framework soweit wie möglich aus der
 Anwendungslogik rauszuhalten, um eine enge Kopplung zu diesem zu verhindern.
\end_layout

\begin_layout Subsubsection
Mediation
\end_layout

\begin_layout Standard
Das Mediator-Muster beschreibt einen Weg der Interaktion zwischen Objekten
 über einen Vermittler.
\begin_inset CommandInset citation
LatexCommand cite
after "S. 273"
key "Gamma1994"

\end_inset

 In StrangeIoC vermitteln Mediatoren zwischen View- und Anwendungslogik.
 Mediatoren interagieren im Auftrag ihres Views mit dem Rest des Frameworks
 und anders herum.
 Dies geschieht, indem der Mediator die Events seines Views abbonniert und
 daraufhin entsprechende Signals auslöst.
 Umgekehrt abonniert der Mediator auch die Events von Services oder Models
 und führt daraufin entsprechende Operationen an seinem View aus.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/strange_mediation.png
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild zur Verdeutlichung des Mediation-Prozesses
\begin_inset CommandInset label
LatexCommand label
name "fig:Schaubild-Mediation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Schaubild-Mediation"

\end_inset

 wird veranschaulicht wie der Mediation-Prozess in StrangeIoC vonstatten
 geht: Sobald ein View in eine Scene geladen wird, sendet dieser automatisch
 in der Awake-Methode eine Message an den ContextView.
 Dafür muss zwangsläufig jeder View ein Childobject des jeweiligen ContextViews
 sein.
 Über den Context des ContextViews wird der MediationBinder aufgerufen.
 Dieser instanziiert einen zuvor an den View gebundenen Mediator und versorgt
 ihn mit seinen Abhängigkeiten mithilfe des Injectors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleMediator : Mediator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleView view { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IBoardLayoutModel layout { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public override void OnRegister()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.AddListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.AddListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void OnRemove()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.RemoveListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.RemoveListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private void OnClick(Vector2 clickPosition)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var index = ClickPositionToFieldIndex(clickPosition);
\end_layout

\begin_layout Plain Layout

		clickSignal.Dispatch(index);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnLayoutChange()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.Refresh();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Implementation eines Mediators
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Mediator"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Mediator"

\end_inset

 wird ein Beispiel für eine mögliche Implementation eines Mediators gezeigt.
 Der Mediator reagiert auf das OnBoardClicked-Event des Views indem er die
 Klickposition in einen verwendbaren Index konvertiert und daraufhin ein
 FieldClickedSignal mit dem Index als Parameter auslöst.
 Weiter abonniert der Mediator das OnLayoutChanged-Event des IBoardLayoutModels.
 In Reaktion auf dieses Event ruft der Mediator die Refresh-Methode des
 von ihm vermittelten Views auf.
 Das An- und Abmelden an die Events erfolgt in den OnRegister- und OnRemove-Call
backs.
 OnRegister wird direkt nach der Injection von Abhängigkeiten aufgerufen.
 Der Aufruf von OnRemove erfolgt beim Zerstören des Views.
\end_layout

\begin_layout Standard
Wie im Beispiel deutlich wird, agieren Mediators lediglich als Brücke zwischen
 Darstellungs- und Anwendungslogik.
 Sie sollten somit leichtgewichtig sein und möglichst keine eigene Logik
 beinhalten.
 Sie dienen einzig dazu Anwendungslogik aus den Views herauszuhalten.
 Dafür gibt es zahlreiche Gründe: Darstellungslogik tendiert dazu mit der
 Zeit unüberschaubar zu werden, da an ihr oft Änderungen in letzter Minute
 vorgenommen werden.
 Weiter verwendet die Darstellungslogik eines Views die API von Unity, die
 durch statische Klassen und fehlendem Interfacesupport zu enger Kopplung
 und damit zu eingeschränkter Testbarkeit führt.
\end_layout

\begin_layout Subsubsection
Models und Services
\end_layout

\begin_layout Standard
Die Aufgaben eines Models in StrangeIoC unterscheiden sich nicht von denen
 eines Models in einer klassischen MVC-Architektur.
 Models kapseln Zustand und Daten der Anwendung und ermöglichen den Zugriff
 auf diese über wohldefinierte Schnittstellen.
 Andere Klassen können über diese Schnittstellen Anfragen an das Model senden.
 Models selber senden keine Anfragen: Wird ein Model geändert, lässt es
 dies den Rest der Anwendung wissen indem es einen Event auslöst.
\end_layout

\begin_layout Standard
Services stehen eng mit Models in Verbindung.
 Dennoch sollten sie getrennt voneinander existieren.
 Ein Service beschafft - oft durch die Kommunikation zur Außenwelt - Daten.
 Ein Model speichert diese Daten.
 Services kommunizieren mit externen Ressourcen einer Applikation.
 Beispiele für solche Resourcen sind unter anderem: Webserver und -Services,
 das Dateisystem und Datenbanken.
 Der Zugriff aus Services erfolgt über Commands, wie bereits in Abbildung
 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Beispiel-Command"

\end_inset

 gezeigt.
 
\end_layout

\begin_layout Subsection
Beispielanwendung
\end_layout

\begin_layout Standard
Die im letzten Abschnitt gezeigten Abbildungen wurden aus einer für diese
 Arbeit programmierten Beispielanwendung übernommen.
 Damit der Fokus auf die zu erläuternden Konzepte nicht verloren geht, wurden
 die Klassen für die Beispiele teilweise gekürzt und abgeändert.
 Die tatsächliche Implementation der Beispielanwendung ist auf der sich
 im Anhang dieser Arbeit befindlichen CD zu finden.
\end_layout

\begin_layout Standard
Es handelt sich um eine Implementation des Brettspiels Peg Solitaire.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Genauer erläutern oder weglassen!}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Kritische Betrachtung & Fazit
\end_layout

\begin_layout Section
Fazit zur Kopplung in Unity
\end_layout

\begin_layout Section
Fazit zur Anwendbarkeit von Dependency Injection in Unity
\end_layout

\begin_layout Subsection
Fazit zu StrangeIoC
\end_layout

\begin_layout Section
Alternative Architekturen
\end_layout

\begin_layout Section
Aussicht
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ab hier folgt nun der Glossar.
 Manchmal ist das nicht nötig, dann muss es auch unter Dokumente --> Einstellung
en --> Latex-Vorspann deaktivieren.
 Übrigens werden Lyx-Notizen im späteren Dokument nicht angezeigt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout

% Die folgende Zeile sorgt dafuer, dass der Glossar im Inhaltsverzeichnis
 angezeigt wird.
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Glossar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Single Responsibility Principle"
description "Eine Klasse soll nur eine Verantowrtlichkeit haben."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Open Closed Principle"
description "Eine Klasse soll offen für Erweiterung, jedoch geschlossen für Modifikation sein."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Liskov Subsitituion Principle"
description "Abgeleite Klassen sollen sich so verhalten wie der Basistyp es von ihnen erwartet."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Interface Segregation Principle"
description "Interfaces sollen nur die Funktionalität wiederspiegeln die ihre Klienten erwarten."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Dependency Inversion Principle"
description "High-Level Klassen sollen nicht von Low-Level Klassen abhängig sein, sondern beide von Interfaces. Interfaces sollen nicht von Details abhängig sein sondern Details von Interfaces"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "auto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Begriffe Einfügen: Stub, Mock, Fake, }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier folgt nun das Literaturverzeichnis.
 Die benötigten Dateien liegen im Verzeichnis: bibtex-daten
\end_layout

\begin_layout Plain Layout
Dieses wird automatisch erstellt.
 Zum bearbeiten der 
\begin_inset Quotes gld
\end_inset

Literatur-Datenbank
\begin_inset Quotes grd
\end_inset

 verwende ich das Programm 
\begin_inset Quotes gld
\end_inset

JabRef
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex-daten/bachelorarbeit-info"
options "bibtotoc,bibtex-daten/unsrtdin"

\end_inset


\end_layout

\end_body
\end_document
