#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage[titletoc]{appendix}

% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\captionsetup[table]{skip=10pt}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
\usepackage{lmodern}
\usepackage[scaled=0.92]{helvet}
\usepackage{mathptmx}
\usepackage{courier}

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{roman}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
\addto\captionsngerman{ 
\renewcommand{\figurename}{Abb.}% 
\renewcommand{\tablename}{Tab.}% 
\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}

%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
\usepackage{color}
\usepackage{listings}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
%xleftmargin = 15pt,
%frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\footnotesize,
backgroundcolor = \color{background},
tabsize=4,
}
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
todonotes
\end_modules
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 92
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Inversion of Control in Unity3D"
\pdf_author "Ludwig Lauer"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/hs-harz-logo.eps
	lyxscale 50
	scale 50

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\shape smallcaps
\size largest
Bachelorarbeit
\end_layout

\begin_layout Standard
\noindent
\align center

\shape smallcaps
\size large
BA AI 27/2015
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\shape smallcaps
\size huge
Inversion Of Control in Unity3D
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="right" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erstprüfer:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Daniel Ackermann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zweitprüfer:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Ph.
 D.
 Jürgen K.
 Singer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abgabedatum:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.10.2015
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row interlinespace="4pt">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape smallcaps
Vorgelegt von:
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="4pt">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="4pt">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Albert Schweitzer Str.
 8
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="4pt">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31061 Alfeld (Leine)
\end_layout

\end_inset
</cell>
</row>
<row interlinespace="4pt">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
m18711
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size larger
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.75
\noindent
Hochschule Harz
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.75
\noindent
Fachbereich Automatisierung und Informatik
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\align center

\shape smallcaps
\size large
Thema und Aufgabenstellung der Bachelorarbeit
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\align center

\shape smallcaps
\size large
BA AI 27/2015 
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\align center

\shape smallcaps
\size large
Ludwig Lauer
\end_layout

\begin_layout Standard
\noindent
\align center

\shape smallcaps
\size larger
Inversion Of Control in Unity3D
\end_layout

\begin_layout Standard
Unity3D hat sich in den letzten Jahren als Spieleengine etabliert.
 Immer größere und ambitioniertere Projekte werden mit der Engine umgesetzt.
 Da Unity3D als Rapid Prototyping Tool für unabhängige Spieleentwickler
 konzipiert wurde, fällt die parallele Entwicklung in mittleren bis großen
 Teams schwer.
 Eine der Ursachen dieses Problems ist die enge Kopplung von Abhängigkeiten
 zwischen Objekten.
 Die Folgen sind Starrheit und Zerbrechlichkeit bei Veränderung des Programmcode
s.
\end_layout

\begin_layout Standard
In der objektorientierten Programmierung gilt Inversion Of Control als Maßnahme
 um lose Kopplung zu erzielen.
 In dieser Arbeit soll untersucht werden, ob sich das Paradigma auch in
 der komponentenbasierten Architektur von Unity3D anwenden lässt.
 Dafür soll das Framework StrangeIoC herangezogen und genauer betrachtet
 werden.
 Mit Features wie Automated Dependency Injection, eigenem Eventsystem und
 einer MVC(S) Architektur sollen die Qualität, Testbarkeit, Skalierbarkeit
 und Wartbarkeit der Anwendung erhöht werden.
\end_layout

\begin_layout Standard
Ziel der Bachelorarbeit ist folglich das Erstellen einer lose gekoppelten
 Beispielanwendung in Unity3D unter Verwendung von StrangeIoC.
 Zudem soll untersucht werden, welche Praktiken die Ursache von enger Kopplung
 in Unity3D sind, welche Folgen diese haben und wie diese mit Inversion
 Of Control, Dependency Injection und StrangeIoC im speziellen, vermeidbar
 sind.
\end_layout

\begin_layout Standard
Die Bachelorarbeit beinhaltet folgende Teilaufgaben:
\end_layout

\begin_layout Itemize
Analyse von Ursachen und Folgen enger Kopplung zwischen Objekten in Unity3D
\end_layout

\begin_layout Itemize
Auseinandersetzung mit den Paradigmen Inversion Of Control und Dependency
 Injection
\end_layout

\begin_layout Itemize
Entwicklung einer Beispielanwendung mit StrangeIoC mit dem Ziel lose Kopplung
 unter Objekten umzusetzen
\end_layout

\begin_layout Itemize
Kritische Betrachtung von Entwicklungsaufwand, Qualität, Testbarkeit, Skalierbar
keit und Wartbarkeit im Vergleich mit anderen Architekturansätzen 
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 1cm
\end_inset

Prof.
 Daniel Ackermann
\begin_inset space \hfill{}
\end_inset

Prof.
 Ph.
 D.
 Jürgen K.
 Singer
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 2cm
\end_inset

1.
 Prüfer
\begin_inset space \hfill{}
\end_inset

2.
 Prüfer
\begin_inset space \hspace{}
\length 2.5cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Eidesstattliche Erklärung
\end_layout

\begin_layout Standard
Ich erkläre, dass ich meine Bachelor-Arbeit „Inversion Of Control in Unity3D“
 selbstständig und ohne Benutzung anderer als der angegebenen Hilfsmittel
 angefertigt habe und dass ich alle Stellen, die ich wörtlich oder sinngemäß
 aus Veröffentlichungen entnommen habe, als solche kenntlich gemacht habe.
 Die Arbeit hat bisher in gleicher oder ähnlicher Form oder auszugsweise
 noch keiner Prüfungsbehörde vorgelegen.
\end_layout

\begin_layout Standard
Ich versichere, dass die eingereichte schriftliche Fassung der auf dem beigefügt
en Medium gespeicherten Fassung entspricht.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ACHTUNG: Hier am Ende noch die richtige Seite einstellen! Sonst passt die
 Nummerierung nicht!
\end_layout

\begin_layout Plain Layout
!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Einleitung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Unity3D hat sich in den letzten Jahren zu einer der bedeutendsten Spieleengines
 entwickelt.
 Mit über 45
\begin_inset space ~
\end_inset

% des globalen Marktanteils unter Spieleengines trägt Unity3D maßgeblich
 zu dem Independent Videogame Boom der letzten Jahre bei 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Unity2015:CompanyFacts"

\end_inset

.
 Unity3D ermöglicht die plattformunabhängige Erstellung von 2D- und 3D-Spielen.
 Dies hat besonders auf dem fragmentierten Markt der mobilen Spieleindustrie
 Anklang gefunden.
 Mit sich kontinuierlich verbessernder Performance und Rendertechniken sind
 stets ambitioniertere Projekte möglich.
 Dies bewegt nicht nur Indieentwickler und kleine Teams dazu, sich die Vorteile
 der Engine zunutze zu machen: Unity3D findet immer mehr Einzug in professionell
e Spieleprojekte mit mittleren und großen Teams.
 Hier sind Tätigkeitsbereiche spezialisiert und klar definiert.
 Die Anforderungen an die Spieleengine beginnen sich zu wandeln: Parallele
 Entwicklung muss gewährleistet werden.
 Der Programmcode muss modular, skalierbar und wiederverwendbar sein.
 Es darf keinen Raum für Fehlkonfigurationen geben.
 Neue Geschäftsmodelle wie Free-to-Play bewirken, dass Spiele immer mehr
 zur Dienstleistung werden.
 Sie müssen über mehrere Jahre hinweg wartbar und erweiterbar bleiben.
\end_layout

\begin_layout Standard
Schaut man sich auf den zahlreichen Websites, Blogs und Foren über Unity3D
 um, scheinen diese Anforderungen Unitys Schwachstelle zu sein: Frustration
 und Beschwerden über entstehenden 
\begin_inset Quotes gld
\end_inset

Spaghetti
\begin_inset Quotes grd
\end_inset

-Code, Kritik an der komponentenbasierten Architektur, fehlende Testbarkeit
 und Aussagen, dass Unity3D nur als Rapid Prototyping Tool tauglich ist
 und Kollaboration in großen Teams kaum möglich ist 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl. "
key "Reddit2015,Suzdalnitski2015,Cann2014,Dabrowski2014"

\end_inset

.
\end_layout

\begin_layout Standard
Oft sollen die Ursachen gerade die Funktionalitäten sein, die unerfahrenen
 Programmierern den einfachen Einstieg in Unity3D ermöglichen.
 Eine Ursache ist so gut wie immer vertreten: die Auflösung von Abhängigkeiten
 und die Kommunikation zwischen Objekten.
 Enge Kopplung von Abhängigkeiten zwischen Objekten führt zu Starrheit und
 Zerbrechlichkeit bei Veränderung des Programmcodes.
 In der objektorientierten Programmierung ist dieses Problem seit Langem
 bekannt.
 Es existieren zahlreiche Lösungen für die unterschiedlichsten Situationen
 und Entwicklungsumgebungen.
 Oft sind diese Lösungen Frameworks, die eng mit den Begriffen Inversion
 Of Control und Dependency Injection in Verbindung stehen.
\end_layout

\begin_layout Standard
Nun implementiert Unity3D keine klassische objektorientierte Hierarchie,
 sondern eine komponentenbasierte Architektur.
 Trotzdem haben auch für Unity eine Handvoll Inversion Of Control Frameworks
 das Licht der Welt erblickt.
 
\end_layout

\begin_layout Section
Zielsetzung und Aufbau
\end_layout

\begin_layout Standard
In dieser Arbeit wird sich auf ein Problem beschränkt: die Kopplung von
 Abhängigkeiten zwischen Entitäten in Unity3D.
 Ziel ist es die Umsetzung von Spielen in Unity3D zu ermöglichen, ohne dessen
 Entitäten eng miteinander zu koppeln.
\end_layout

\begin_layout Standard
In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grundlagen"

\end_inset

 wird zunächst die Problematik der Kopplung beschrieben.
 Voraussetzung dafür ist, zu erläutern, was Abhängigkeiten sind und warum
 diese entstehen.
 Weiter werden die Folgen von enger Kopplung erläutert.
 Dem Leser soll damit verdeutlicht werden, dass Kopplung direkten Einfluss
 auf die Testbarkeit und Erweiterbarkeit des Programmcodes hat.
 
\end_layout

\begin_layout Standard
Nachfolgend wird anhand eines Beispiels erklärt, wie lose Kopplung mittels
 Dependency Injection umzusetzen ist.
 In diesem Zusammenhang werden auch zugrunde liegende Prinzipien erläutert.
\end_layout

\begin_layout Standard
Infolgedessen wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Analyse-der-Architektur"

\end_inset

 der Schritt zu Unity3D getätigt.
 Es wird untersucht, inwiefern Unity3D von einer herkömmlichen objektorientierte
n Hierarchie abweicht und ob dies hinderlich dabei ist, lose Kopplung umzusetzen.
 Es werden häufig verwendete Praktiken wie das Singletonpattern und Managerobjek
te untersucht.
 Wie im Verlauf der Arbeit im Detail erklärt wird, entstehen Abhängigkeiten
 unter anderem dadurch, dass Objekte miteinander kommunizieren müssen.
 Unity3D stellt unterschiedliche Wege der Kommunikation bereit.
 Es wird nachgeprüft, ob diese Wege es bereits ermöglichen lose Kopplung
 umzusetzen.
 Auf Basis dieser Erkenntnisse wird ein Zwischenfazit gezogen, um die Notwendigk
eit eines Inversion Of Control Frameworks für Unity3D zu verdeutlichen.
\end_layout

\begin_layout Standard
Im vierten Kapitel dieser Arbeit wird ein Inversion Of Control Container
 für Unity3D implementiert.
 Dieser Container soll Dependency Injection in MonoBehaviours automatisieren
 und somit die lose Kopplung unter MonoBehaviours ermöglichen.
 Die technische Umsetzung wird erläutert.
 Die mit Unity3D in Verbindung stehenden Hürden bei der Umsetzung werden
 überwunden und beschrieben.
 Im Anschluss wird ein Überblick über die vorhandenen Inversion Of Control
 Frameworks für Unity3D geliefert.
 Besonderheiten, Funktionsweisen und -umfänge der Frameworks werden beschrieben.
 Besondere Betrachtung wird StrangeIoC gewidmet: Die frameworkeigene MVC(S)-Arch
itektur und die damit verbundenen Muster und Praktiken werden anhand von
 Beispielen beschrieben.
\end_layout

\begin_layout Standard
Auf Basis dieser Analysen wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Fazit"

\end_inset

 eine Aussage über die Tauglichkeit von Inversion Of Control Frameworks
 in der komponentenbasierten Architektur Unitys getroffen.
 Im Speziellen wird ein Fazit über die MVC(S)-Architektur von StrangeIoC
 zur Entwicklung von Spielen in Unity3D gezogen.
 Es wird eine Entscheidung getroffen, für welche Anwendungsgebiete die Architekt
ur besonders geeignet ist und für welche nicht.
 Für diese wird ein alternativer Architekturansatz in Aussicht gestellt.
\end_layout

\begin_layout Section
Textliche Konventionen
\end_layout

\begin_layout Standard
In dieser Arbeit werden Fachbegriffe in englischer Sprache verwendet, sofern
 kein deutsches Gegenstück gebräuchlich ist.
\end_layout

\begin_layout Chapter
Grundlagen
\begin_inset CommandInset label
LatexCommand label
name "chap:Grundlagen"

\end_inset


\end_layout

\begin_layout Standard
Geringe Kopplung unter Softwareentitäten (Modulen, Klassen, Methoden) wird
 als Indiz für gute Softwarearchitektur angesehen.
 Inversion Of Control und genauer Dependency Injection sind Werkzeuge, die
 dabei helfen sollen, lose Kopplung umzusetzen.
 In diesem Teil der Arbeit wird zunächst erläutert, was Kopplung zwischen
 Entitäten ist und wie diese zustande kommt.
 Es wird verdeutlicht, warum hohe Kohäsion unter minimaler Kopplung anzustreben
 ist.
 Die Vorteile loser Kopplung werden verdeutlicht.
 Inversion Of Control, Dependency Injection und die eng mit diesen Begriffen
 zusammenhängenden SOLID-Prinzipien werden beschrieben.
 Zum besseren Verständnis der vorgestellten Prinzipien, Muster und Praktiken
 wird lose Kopplung anhand eines Beispiels in einer Konsolenanwendung umgesetzt.
\end_layout

\begin_layout Section
Kopplung und Kohäsion
\end_layout

\begin_layout Standard
Kopplung ist ein Maß, das die Anzahl und Stärke von Abhängigkeiten unter
 Softwareentitäten einer Anwendung beschreibt (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 2-3"
key "Society2014"

\end_inset

).
 Ist eine Softwareentität direkt von der Implementation einer anderen Entität
 abhängig, so sind diese eng miteinander gekoppelt.
 Ziel ist es, die Anzahl und Stärke von Abhängigkeiten zu minimieren und
 so lose Kopplung umzusetzen.
 Martin Fowler beschreibt in dem Artikel 
\begin_inset Quotes gld
\end_inset

Reducing Coupling
\begin_inset Quotes grd
\end_inset

 Kopplung wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

If changing one module in a program requires changing another module, then
 coupling exists.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Fowler2001"

\end_inset

 
\end_layout

\begin_layout Standard
Eine Abhängigkeit zwischen Entitäten entsteht, sobald eine Entität von der
 anderen wissen muss, um zu funktionieren.
 Abhängigkeiten können unterschiedliche Stärken und Ausprägungen haben.
 Je größer das Wissen über eine andere Entität ist, desto stärker ist die
 Abhängigkeit zu ihr.
 Muss also eine Entität von der konkreten Implementation einer anderen Entität
 wissen, so existiert eine starke Abhängigkeit und folglich eine enge Kopplung.
 Wird sich hingegen auf eine Schnittstelle zur Kommunikation geeinigt, existiert
 lediglich eine Abhängigkeit zu eben dieser Schnittstelle.
 Die Entitäten selbst sind lose miteinander gekoppelt.
 Die tatsächliche Implementation einer Entität wird erst zur Laufzeit durch
 späte Bindung bekannt.
 
\end_layout

\begin_layout Standard
Kopplung steht im Kontrast zu dem Begriff der Kohäsion.
 Kohäsion beschreibt ein Maß für den inneren Zusammenhalt einer Softwareentität.
 Hohe Kohäsion liegt dann vor, wenn eine Entität nur Funktionalitäten aufweist,
 die einer einzelnen, wohldefinierten Aufgabe dienen.
 Mit anderen Worten: Eine Entität weist eine hohe Kohäsion auf, wenn ihre
 Elemente in einem engen Zusammenhang stehen.
 Ein qualitativ hochwertiges Softwaredesign weist demzufolge hohe Kohäsion
 unter minimaler Kopplung auf 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 31"
before "vgl."
key "Schatten2010"

\end_inset

.
 Im nächsten Abschnitt soll Inversion Of Control als Maßnahme präsentiert
 werden, um Kopplung zu minimieren.
\end_layout

\begin_layout Section
Inversion of Control
\begin_inset CommandInset label
LatexCommand label
name "sec:Inversion-of-Control"

\end_inset


\end_layout

\begin_layout Standard
Im ursprünglichen Sinne beschreibt Inversion Of Control nach 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "Johnson1988"

\end_inset

 lediglich die Charakteristik eines Frameworks: 
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

[...] methods defined by the user to tailor the framework will often be called
 from within the framework itself, rather than from the user's application
 code.
 The framework often plays the role of the main program in coordinating
 and sequencing application activity.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnson1988"

\end_inset

 
\end_layout

\begin_layout Standard
Frameworks diktieren die Architektur und den Kontrollfluss einer Anwendung.
 Sie definieren einen wiederverwendbaren Teil eines Softwaredesigns.
 Der vom Nutzer des Frameworks geschriebene, anwendungsspezifische Code
 wird vom Framework aufgerufen (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 27"
key "Gamma1994"

\end_inset

).
 Der Nutzer gibt also die Kontrolle über den Anwendungsfluss an das Framework.
 Die Kontrolle ist somit invertiert: Es ist nicht der Nutzer, der das Framework
 aufruft, sondern das Framework den Code des Nutzers.
 Diese Tatsache wird oft auch als Hollywood-Prinzip bezeichnet: "Don't call
 us, we'll call you" (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
key "Fowler2005"

\end_inset

).
\end_layout

\begin_layout Standard
Inversion Of Control ist das zentrale Merkmal, welches Frameworks von Bibliothek
en unterscheidet.
 Allein Inversion Of Control ermöglicht die Definition einer wiederverwendbaren
 Softwarearchitektur, ohne dabei die konkrete Implementation einer Anwendung
 zu kennen.
 Das Framework ist lose mit der Implementation der eigentlichen Anwendung
 gekoppelt.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Wege und Entwurfsmuster um Inversion Of Control in unterschie
dlichen Aspekten einer Anwendung umzusetzen.
 Einige Beispiele hierfür sind die Entwurfsmuster Factory, Strategy und
 Template Method.
 In dieser Arbeit soll der Fokus auf die Umkehr der Kontrolle über die Auflösung
 von Abhängigkeiten liegen, mit dem Ziel lose Kopplung zu ermöglichen.
 Um diese spezielle Art von Inversion Of Control besser abzugrenzen, verwendet
 Fowler in seinem Artikel 
\begin_inset Quotes gld
\end_inset

Inversion of Control Containers and the Dependency Injection pattern
\begin_inset Quotes grd
\end_inset

 den Begriff Dependency Injection 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Fowler2004"

\end_inset

.
\end_layout

\begin_layout Section
Dependency Injection
\end_layout

\begin_layout Standard
Seemann gibt in 
\begin_inset Quotes gld
\end_inset

Dependency Injection in .NET
\begin_inset Quotes grd
\end_inset

 eine sehr vage Definition des Begriffs Dependency Injection:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency Injection is a set of software design principles and patterns
 that enable us to develop loosely coupled code.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 4"
key "Seemann2011"

\end_inset

 
\end_layout

\begin_layout Standard
Dependency Injection umfasst eine Reihe von Praktiken, die es ermöglichen
 lose Kopplung umzusetzen.
 Um welche Praktiken es sich genau handelt, wird in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Umsetzung-von-Dependency"

\end_inset

 anhand eines Beispiels erläutert.
 Der Kern von Dependency Injection lässt sich jedoch auf eine einzige Praktik
 reduzieren.
 James Shore beschreibt diese auf seiner Webseite wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency injection means giving an object its instance variables.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Shore2006"

\end_inset


\end_layout

\begin_layout Standard
Anstatt, dass sich das Objekt selbst um die Erstellung seiner Abhängigkeiten
 -- seiner Instanzvariablen -- kümmert, wird diese Aufgabe an einen Dritten
 übergeben.
 Die Verwendung des benötigten Objekts ist von der Konfiguration des Objekts
 getrennt.
 
\end_layout

\begin_layout Standard
Doch diese Praxis allein ist unzureichend, um lose Kopplung mittels Dependency
 Injection zu ermöglichen.
 Es müssen zudem eine Reihe von Prinzipien gewahrt werden.
 Diese wurden von Robert C.
 Martin geprägt und sind im Allgemeinen als SOLID-Prinzipien bekannt 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 49"
before "vgl."
key "Bender2011"

\end_inset

.
 Diese werden in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SOLID-Prinzipien"

\end_inset

 näher beschrieben.
\end_layout

\begin_layout Section
SOLID Prinzipien
\begin_inset CommandInset label
LatexCommand label
name "sec:SOLID-Prinzipien"

\end_inset


\end_layout

\begin_layout Standard
SOLID ist ein Akronym, welches für die folgenden Prinzipien steht: das Single
 Responsibility Principle, das Open/Closed Principle, das Liskov Substitution
 Principle, das Interface Segregation Principle und das Dependency-Inversion
 Principle.
 Es handelt sich um eine Sammlung von Richtlinien im Umgang mit Abhängigkeiten,
 die eine saubere Softwarearchitektur ermöglichen sollen 
\begin_inset CommandInset citation
LatexCommand citep
after "9:10 Min."
before "vgl."
key "Metz2009"

\end_inset

.
 Im folgenden Abschnitt werden diese Prinzipen vorgestellt und ihre Relevanz
 bei der Umsetzung von Dependency Injection beschrieben.
\end_layout

\begin_layout Subsection
Single Responsibility Principle
\end_layout

\begin_layout Standard
Das Single Responsibility Principle besagt, dass es niemals mehr als einen
 Grund geben sollte, um eine Klasse zu ändern.
 Darauf Folgend wird ein 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 in dem Zusammenhang als eine Verantwortung definiert.
 Jedoch wurde 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 bewusst gewählt, da es auch legitim ist mehrere Verantwortlichkeiten in
 einer Klasse unterzubringen, wenn diese sich mit hoher Wahrscheinlichkeit
 gemeinsam ändern 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 95-98"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Wird das Single Responsibility Principle gewahrt, so ist in der Regel davon
 auszugehen, dass Klassen hohe Kohäsion aufweisen.
 Hohe Kohäsion ist jedoch nicht immer auf das Single Responsibility Principle
 zurückzuführen.
 So kann eine Klasse hohe Kohäsion aufweisen, aber trotzdem mehrere Verantwortun
gen haben.
\end_layout

\begin_layout Standard
Dependency Injection wendet das Single Responsibility Principle an, indem
 es Klassen die Verantwortung über die Erstellung von Instanzen ihrer Abhängigke
iten entzieht (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 24"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Open/Closed Principle
\end_layout

\begin_layout Standard
Softwareentitäten (Klassen, Methoden, Funktionen) sollen offen für Erweiterung,
 aber geschlossen für Modifikation sein.
 Mit 
\begin_inset Quotes gld
\end_inset

Offen für Erweiterung
\begin_inset Quotes grd
\end_inset

 ist gemeint, dass es möglich sein soll, die Entität in ihrem Umfang und
 Verhalten zu erweitern.
 
\begin_inset Quotes gld
\end_inset

Geschlossen für Modifikation
\begin_inset Quotes grd
\end_inset

 zum anderen bedeutet, dass zur Erweiterung keine Änderungen an der Entität
 an sich notwendig sind 
\begin_inset CommandInset citation
LatexCommand citep
after "S.99-100"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Abstraktion ermöglicht die Umsetzung des Open/Closed Principles.
 Wird von einer abstrakten Basisklasse geerbt, so ist es möglich das Verhalten
 der Abstraktion zu ändern, ohne die Abstraktion selbst zu manipulieren.
 Die Entwurfsmuster Strategy und Template Method sind Beispiele für das
 Open/Closed Principle.
\end_layout

\begin_layout Standard
Auch Dependency Injection setzt das Open/Closed Principle um, indem Abhängigkeit
en lediglich in Form von Abstraktionen existieren.
 Damit ist dieses Prinzip eine wichtige Grundlage für lose Kopplung (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 106"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Liskov Substitution Principle
\end_layout

\begin_layout Standard
Das Liskov Substitution Principle beschreibt eine grundlegende Anforderung
 beim Einsatz von Vererbung: Untertypen einer Basisklasse sollen untereinander
 ersetzbar sein, ohne dabei das Verhalten des Programms selbst zu verändern.
 Das Programm selbst darf zu keinem Zeitpunkt einen Untertyp anders als
 einen anderen Untertypen behandeln 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 111-112"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Dependency Injection ermöglicht es, dass Abhängigkeiten beliebig austauschbar
 sind, solange sie die nötige Abstraktion implementieren.
 Dies ist jedoch nur möglich, wenn das Liskov Substitution Prinzip gewahrt
 wird (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 9-10"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
Dieses Prinzip kommt besonders beim Unittesting zum Vorschein: Abhängigkeiten
 eines Systems Under Test können durch Test Doubles ersetzt werden, ohne
 das Verhalten des Systems selbst zu verändern (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S.19"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Interface Segregation Principle
\end_layout

\begin_layout Standard
Anstatt umfangreiche Interfaces zu nutzen, sollten diese in mehrere kleine
 Interfaces aufgeteilt werden.
 Die Aufteilung soll nach Methodengruppen erfolgen, entsprechend wie sie
 von anderen Entitäten, die das Interface nutzen, gebraucht werden.
 So wird gewährleistet, dass andere Entitäten nur von Abstraktionen mit
 hoher Interfacekohäsion abhängig sind.
 Auch wenn diese Abstraktionen von einer einzigen nicht-kohäsiven Entität
 implementiert werden 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 135"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Das Interface Segregation Principle scheint zunächst nicht mit Dependency
 Injection im Zusammenhang zu stehen.
 Es ist eher eine Richtlinie, die bei der Anwendung von Dependency Injection
 gewahrt werden sollte.
 Wird eine Abhängigkeit von einem einzigen großen Interface repräsentiert,
 lenkt dieses Interface in die Richtung einer konkreten Implementation.
 Die Folge ist, dass Entitäten schwieriger auszutauschen sind, weil sie
 Interfacemethoden implementieren, die sie eigentlich gar nicht benötigen,
 um eine Abhängigkeit zu erfüllen (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 284"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Subsection
Dependency Inversion Principle
\end_layout

\begin_layout Standard
Das Dependency Inversion Principle besteht aus zwei Teilen:
\end_layout

\begin_layout Itemize
High-Level Module sollen nicht von Low-Level Modulen abhängig sein.
 Beide sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Itemize
Abstraktionen sollten nicht von Details abhängen.
 Details sollten von Abstraktionen abhängen 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 127"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Zum einen beschreibt das Dependency Inversion Principle, dass die Architektur
 einer Anwendung in Schichten erfolgen sollte.
 Dabei soll die abstraktere, höher liegende Schicht ihre Abhängigkeiten
 in Form von Interfaces deklarieren.
 Die ihr untergeordnete Schicht wird basierend auf diesen Interfaces realisiert.
 Folglich sind die übergeordneten Schichten nicht von untergeordneten Schichten
 abhängig.
 Stattdessen sind untergeordnete Schichten von den abstrakten Interfaces
 in den übergeordneten Schichten abhängig 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 128-129"
before "vgl."
key "Martin2003"

\end_inset

.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:DIP"

\end_inset

 verdeutlicht diese Invertierung der Abhängigkeiten: Anstatt, dass das 
\shape italic
Policy
\shape default
-Modul -- wie in der linken Bildhälfte gezeigt -- von der Implementation
 des 
\shape italic
Mechanism
\shape default
-Moduls abhängt, besteht lediglich eine Abhängigkeit an ein 
\shape italic
Mechanism
\shape default
-Interface.
 Dieses Interface befindet sich innerhalb des höherliegenden 
\shape italic
Policy
\shape default
-Moduls.
 Die tatsächliche Implementation erfolgt innerhalb des untergeordneten 
\shape italic
Mechanism-
\shape default
Moduls, wodurch eine Abhängigkeit an das 
\shape italic
Policy
\shape default
-Modul entsteht.
 Demzufolge haben Änderungen des 
\shape italic
Mechanism-
\shape default
Moduls keinen Einfluss auf das 
\shape italic
Policy
\shape default
-Modul.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/DIP.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Invertierung der Abhängigkeiten zwischen Schichten.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S.129"
before "Quelle: in Anlehnung an"
key "Martin2003"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dependency Inversion Principle
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:DIP"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zum anderen beschreibt Martin eine weitere, allgemeine Interpretation des
 Dependency Inversion Principles:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Depend on abstractions.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 129"
key "Martin2003"

\end_inset


\end_layout

\begin_layout Standard
So sollen Klassen keine Referenzen zu anderen konkreten Klassen halten,
 von ihnen ableiten oder Methoden ihrer Basisklasse überschreiben.
 Diese Praxis wurde bereits von der Gang of Four in 
\begin_inset Quotes gld
\end_inset

Design Patterns - Elements of Reusable Object-Oriented Software
\begin_inset Quotes grd
\end_inset

 mit den folgenden Worten beschrieben:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Program to an interface, not an implementation.
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 17-18"
key "Gamma1994"

\end_inset

 
\end_layout

\begin_layout Standard
Die Deklaration von Abhängigkeiten in Form von Abstraktionen ist eine Grundlage,
 um lose Kopplung mittels Dependency Injection umzusetzen.
 Späte Bindung ermöglicht es, dass die konkrete Implementation auf diesem
 Wege erst zur Laufzeit bekannt sein muss.
\end_layout

\begin_layout Section
Umsetzung von Dependency Injection
\begin_inset CommandInset label
LatexCommand label
name "sec:Umsetzung-von-Dependency"

\end_inset


\end_layout

\begin_layout Standard
Um zu erläutern, wie die in den vorherigen Abschnitten erklärten Prinzipien
 bei der Umsetzung von Inversion Of Control mittels Dependency Injection
 zusammenspielen, wird ein Beispiel herangezogen.
 Anhand dieses Beispiels werden Entwurfsmuster die im direkten Zusammenhang
 zu Dependency Injection stehen, beschrieben.
 Um das Beispiel so einfach wie möglich zu halten, wurde hierfür eine Konsolenan
wendung in C# gewählt.
\end_layout

\begin_layout Subsection
Ausgangssituation
\end_layout

\begin_layout Standard
Eine gewünschte Funktionalität eines zu entwickelnden Spiels ist es, auszugeben,
 dass ein verwundbares Objekt Schaden genommen hat.
 Die in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Ausgangssituation"

\end_inset

 dargestellte Klasse 
\shape italic
DamageRenderer
\shape default
 setzt diese Funktionalität um.
 Alle qualitativen und funktionalen Anforderungen werden von der Klasse
 erfüllt.
 Sie kann von allen Objekten wiederverwendet werden, wenn diese Schaden
 nehmen.
 Die Klasse beschränkt ihre Verantwortung auf eine einzige Funktionalität:
 Sie formatiert die Information in ein lesbares Format und gibt diese in
 der Konsole aus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format("{0} was attacked and took {1} damage.", target,
 damage);         		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausgangssituation des Beispiels.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Ausgangssituation"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Ausgangssituation des Beispiels
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Neue Anforderungen
\end_layout

\begin_layout Standard
Im Verlauf der Entwicklung des Spieles wird deutlich, dass das Spiel in
 verschiedenen Sprachen veröffentlicht werden soll.
 Diese auch als Lokalisierung bekannte Anforderung ist eine gängige Anforderung
 für jegliche Art von Software.
 Es wird mit dem Refactoring begonnen und die Klasse 
\shape italic
EnglishLocalization
\shape default
 extrahiert.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Extraction"

\end_inset

 wird das Resultat des Refactorings gezeigt.
 Die Verantwortung über die Lokalisierung wurde in eine allein dafür vorgesehene
 Klasse verschoben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly EnglishLocalization localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Extraction der englischen Lokalisierung aus der existierenden Klasse.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Extraction"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Extraction der englischen Lokalisierung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Klasse 
\shape italic
DamageRenderer
\shape default
 funktioniert weiterhin wie im vorherig gezeigten Beispiel.
 Der Unterschied ist, dass 
\shape italic
DamageRenderer
\shape default
 nun eine Abhängigkeit zu 
\shape italic
EnglishLocalization
\shape default
 besitzt.
 Wie kann es nun ermöglicht werden, die englische Lokalisierung mit der
 Deutschen aus Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Deutsche-Lokalisierung"

\end_inset

 auszutauschen? Das Problem hierbei ist, dass 
\shape italic
DamageRenderer
\shape default
 eine konkrete Abhängigkeit zu 
\shape italic
EnglishLocalization
\shape default
 besitzt.
 Mit anderen Worten, sie sind eng miteinander gekoppelt.
 Die Folge ist, dass 
\shape italic
EnglishLocalization
\shape default
 nicht -- ohne 
\shape italic
DamageRenderer
\shape default
 zu ändern -- durch 
\shape italic
GermanLocalization
\shape default
 ausgetauscht werden kann.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GermanLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Deutsche Lokalisierung.
 Quelle: Eigene Abbildung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Deutsche-Lokalisierung"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation deutsche Lokalisierung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Programming to an Interface
\end_layout

\begin_layout Standard
Um lose Kopplung umzusetzen, darf keine Abhängigkeit zu einer konkreten
 Implementation existieren.
 Stattdessen muss sich auf eine Abstraktion als Abhängigkeit verlassen werden.
 In dem Beispiel in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Depend-Abstractions"

\end_inset

 wird dies umgesetzt, indem 
\shape italic
English-
\shape default
 und 
\shape italic
GermanLocalization
\shape default
 das Interface 
\shape italic
ILocalizationService
\shape default
 implementieren.
 Dadurch, dass 
\shape italic
DamageRenderer
\shape default
 nur noch eine Variable des Interfaces 
\shape italic
ILocalizationService
\shape default
 hält, lässt sich die konkrete Implementation austauschen.
 Voraussetzung hierfür ist jedoch weiterhin, dass 
\shape italic
DamageRenderer
\shape default
 geändert wird.
 Der Grund dafür ist, dass 
\shape italic
EnglishLocalization
\shape default
 im Konstruktor von 
\shape italic
DamageRenderer
\shape default
 instanziiert wird.
 Somit ist 
\shape italic
DamageRenderer
\shape default
 weiterhin eng mit 
\shape italic
EnglishLocalization
\shape default
 gekoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	string GetText();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class GermanLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von 
\begin_inset Quotes gld
\end_inset

Depend on abstractions
\begin_inset Quotes grd
\end_inset

.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Depend-Abstractions"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel von 
\begin_inset Quotes gld
\end_inset

Depend on abstractions
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Injecting Dependencies
\end_layout

\begin_layout Standard
Um die Klassen lose miteinander zu koppeln, kommt an dieser Stelle der Einsatz
 von Dependency Injection ins Spiel: Anstatt, dass sich eine Klasse selbst
 um die Auflösung ihrer Abhängigkeiten kümmert, sollte sie von außen mit
 diesen versorgt werden.
 Die Verantwortung über die Auflösung der Abhängigkeiten wird abgegeben.
 Die Klasse selbst macht lediglich deutlich, dass Sie ein Objekt benötigt,
 welches die abstrakten Bedürfnisse eines Interfaces umsetzt.
 In diesem Fall handelt es sich um die Bedürfnisse eines 
\shape italic
ILocalizationServices
\shape default
.
 Dependency Injection lässt sich auf unterschiedlichen Wegen umsetzen.
 Die Gebräuchlichsten sind Constructor Injection und Property Injection.
\end_layout

\begin_layout Subsubsection
Constructor Injection
\end_layout

\begin_layout Standard
Die Abhängigkeit wird über den Konstruktor bei der Instanziierung des Objektes
 bereitgestellt.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Constructor"

\end_inset

 wird Constructor Injection in der 
\shape italic
DamageRenderer
\shape default
-Klasse angewandt.
 Eine Instanz von 
\shape italic
ILocalizationService
\shape default
 muss bei Aufruf des Konstruktors übergeben werden.
\end_layout

\begin_layout Standard
Constructor Injection stellt sicher, dass die nötige Abhängigkeit auch tatsächli
ch verfügbar ist, indem eine Instanziierung des Objektes (ein Konstruktoraufruf)
 ohne diese nicht möglich ist.
 Damit wird erzwungen, dass der gesamte Abhängigkeitsgraph aufgebaut wird,
 bevor die Klasse genutzt werden kann.
 Eine Guard Clause stellt sicher, dass nicht 
\shape italic
null
\shape default
 als Argument übergeben wird.
 Constructor Injection sollte in den meisten Fällen angewandt werden, denn
 in der Regel ist eine Abhängigkeit zwingend notwendig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer(ILocalizationService localization)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		this.localization = localization;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Constructor Injection.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Constructor"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel Constructor Injection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Property Injection
\end_layout

\begin_layout Standard
Ist eine Abhängigkeit optional, kann die Klasse über ein Property mit einer
 Instanz dieser Abhängigkeit versorgt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Property"

\end_inset

 zeigt die Umsetzung von Property Injection anhand des gewählten Beispiels.
 Die Klasse stellt ein öffentlich setzbares Property vom Typ der Abhängigkeit
 bereit.
 In dem gezeigten Beispiel ist Property Injection wenig angebracht, da die
 Abhängigkeit notwendig ist.
 Man könnte jedoch, falls kein 
\shape italic
LocalizationService
\shape default
 bereitgestellt wird, beispielsweise im Getter des Properties eine Instanz
 von 
\shape italic
EnglishLocalization
\shape default
 erstellen und diese so als Local Default verwenden.
\end_layout

\begin_layout Standard
Das Open/Closed Principle lässt sich somit auch mit Properties umsetzen:
 Properties bieten die Möglichkeit eine optionale Abhängigkeit zur Erweiterung
 der Funktionalität einer Klasse preiszugeben, ohne dabei die Klasse selbst
 zu modifizieren.
\end_layout

\begin_layout Standard
Ein Nachteil ist, dass andere Klassen zu jeder Zeit Veränderungen an dem
 Property vornehmen können.
 Aus diesem Grund wird Property Injection in manchen Kreisen kritisiert,
 da es die Datenkapselung bricht 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Butler2013"

\end_inset

.
\end_layout

\begin_layout Standard
In einigen Fällen muss -- aufgrund von Beschränkungen durch die Verwendung
 von Frameworks wie z.
\begin_inset space ~
\end_inset

B.
 ASP.NET -- auf Constructor Injection verzichtet werden.
 Das Framework schreibt das Vorhandensein eines Default Constructors vor,
 der zur Initialisierung genutzt wird.
 In diesen Fällen kann auch alternativ auf Property Injection zurückgegriffen
 werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer : IDamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ILocalizationService Localization { private get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var output = string.Format(Localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Property Injection.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Property"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel Property Injection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Composition Root
\begin_inset CommandInset label
LatexCommand label
name "sub:Composition-Root"

\end_inset


\end_layout

\begin_layout Standard
In den vorangegangenen Abschnitten wurde verdeutlicht, dass Dependency Injection
 es verlangt, die Verantwortung über die Auflösung der Abhängigkeiten abzugeben.
 Es wurde jedoch nicht beschrieben, an wen diese Verantwortung übertragen
 werden soll.
 Die Antwort ergibt sich durch die konsequente Umsetzung von Dependency
 Injection: Abhängigkeiten werden in der Objekthierarchie nach oben gereicht
 bis dies nicht mehr möglich ist.
 Die Auflösung der Abhängigkeiten sollte demzufolge so nah wie möglich beim
 Einstiegspunkt der Applikation geschehen.
 Soweit es möglich ist, sollte die Initialisierungslogik aller Objekte an
 diesem zentralen Ort umgesetzt werden.
 Dieser zentrale Ort wird als Composition Root bezeichnet (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 76-77"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
In einer Konsolenanwendung -- wie dem gezeigten Beispiel -- erfüllt die
 Main-Methode die Voraussetzungen für einen Composition Root: Sie ist der
 Einstiegspunkt in die Anwendung und zugleich der höchste Punkt in der Objekthie
rarchie.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CompositionRoot"

\end_inset

 zeigt den Composition Root der Beispielanwendung.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Main(string[] args)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var localization = new GermanLocalization();
\end_layout

\begin_layout Plain Layout

		var renderer = new DamageRenderer(localization);
\end_layout

\begin_layout Plain Layout

		renderer.Render("Mario", 10);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Main-Methode erfüllt die Eigenschaften des Composition Roots in einer
 Konsolenanwendung.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Main-Methode als Composition Root in einer Konsolenanwendung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Composition Root wird die Konfiguration der Anwendung vorgenommen.
 Es ist der einzige Ort, an dem die konkreten Instanzen von Objekten bekannt
 sein müssen.
 Er sollte unabhängig von dem Rest der Anwendung kompilierbar sein und sich
 deswegen in einem separaten Assembly befinden.
\end_layout

\begin_layout Subsection
Feste und unbeständige Abhängigkeiten
\end_layout

\begin_layout Standard
Nicht jede Abhängigkeit muss lose mit der Anwendung gekoppelt werden.
 Tatsächlich ist dies für bestimmte, feste Abhängigkeiten unnötig.
 Wichtig ist jedoch unterscheiden zu können, wann eine Abhängigkeit als
 fest (
\begin_inset Quotes gld
\end_inset

stable
\begin_inset Quotes grd
\end_inset

) und wann als unbeständig (
\begin_inset Quotes gld
\end_inset

volatile
\begin_inset Quotes grd
\end_inset

) angesehen werden sollte.
 
\end_layout

\begin_layout Standard
Kann davon ausgegangen werden, dass ein bereits existierendes Modul niemals
 ausgetauscht oder verändert wird, so kann es als eine feste Abhängigkeit
 angesehen werden.
 Ein Beispiel hierfür sind die meisten Module der Base Class Library, da
 sie fester Bestandteil des .NET Frameworks sind.
 Ob ein Modul als feste Abhängigkeit angesehen werden kann, lässt sich anhand
 der folgenden Kriterien beurteilen:
\end_layout

\begin_layout Itemize
Die Klasse oder das Modul existiert bereits.
\end_layout

\begin_layout Itemize
Es ist zu erwarten, dass neue Versionen der Abhängigkeit keine Änderungen
 enthalten werden, die Auswirkungen auf den Programmcode haben.
\end_layout

\begin_layout Itemize
Das Modul beinhaltet ausschließlich deterministische Algorithmen.
\end_layout

\begin_layout Itemize
Es ist nicht zu erwarten, dass das Modul jemals durch ein anderes ausgetauscht
 wird.
\end_layout

\begin_layout Standard
Den Gegensatz zu festen Abhängigkeiten bilden Klassen und Module, bei denen
 es absehbar ist, dass sie sich verändern werden.
 Ist eine Abhängigkeit unbeständig, sollte sie lose mit dem Rest der Anwendung
 gekoppelt werden, um ihre Austauschbarkeit zu ermöglichen.
 Eine Abhängigkeit wird als unbeständig angesehen, wenn eines der folgenden
 Kriterien auf sie zutrifft:
\end_layout

\begin_layout Itemize
Durch die Abhängigkeit wird eine bestimmte Laufzeitumgebung vorausgesetzt.
 
\end_layout

\begin_layout Itemize
Die Abhängigkeit existiert noch nicht.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nutzt eine Bibliothek, die nicht auf allen Systemen vorhanden
 ist.
\end_layout

\begin_layout Itemize
Die Abhängigkeit weist nichtdeterministisches Verhalten auf (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 23-24"
key "Seemann2011"

\end_inset

).
\end_layout

\begin_layout Standard
Ein Beispiel für eine in der Base Class Library vorhandene Klasse, die als
 unbeständige Abhängigkeit behandelt werden sollte, ist 
\shape italic
System.Random
\shape default
.
 Die Klasse weist nichtdeterministisches Verhalten auf, was sich besonders
 auf die Testbarkeit der Anwendung auswirkt.
\end_layout

\begin_layout Section
Resultierende Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten wurde ausführlich beschrieben, wie und warum
 lose Kopplung umzusetzen ist.
 Jedoch sind eventuell die Gründe für lose Kopplung, aufgrund des einfach
 gehaltenen Beispiels, noch nicht ganz ersichtlich geworden.
 Besonders große und komplexe Softwareprojekte profitieren maßgeblich von
 loser Kopplung.
 Welche Faktoren genau beeinflusst werden, wird im Folgenden erläutert.
\end_layout

\begin_layout Subsection
Erweiterbarkeit
\end_layout

\begin_layout Standard
Während der Entwicklung einer Anwendung werden neue Anforderungen bekannt
 und existierende Anforderungen beginnen sich zu verändern.
 Trotzdem muss die Anwendung erweiterbar und wartbar bleiben.
 Mit zunehmender Größe der Anwendung, wird es umso problematischer sie zu
 erweitern.
 In sehr großen Softwareprojekten ist es schwer abzusehen, welche Auswirkungen
 auch nur die kleinste Änderung hat.
 Aus diesem Grund ist es notwendig, Entitäten so autonom wie möglich zu
 halten.
 Dadurch, dass die Abhängigkeiten einer Entität auf Interfaces reduziert
 werden, haben Änderungen der konkreten Implementation keinen Einfluss auf
 sie.
\end_layout

\begin_layout Standard
Lose Kopplung setzt das Open/Closed Principle in die Tat um: Module sind
 offen für Erweiterung und geschlossen für Veränderung.
 Maßgeblich verantwortlich hierfür ist das Konzept der späten Bindung, welches
 sich durch 
\begin_inset Quotes gld
\end_inset

programming to an interface
\begin_inset Quotes grd
\end_inset

 konsequent umsetzen lässt.
 Die konkrete Implementation ist austauschbar und wird erst zur Laufzeit
 bekannt.
 Sie ist unabhängig vom Rest der Anwendung veränderbar.
\end_layout

\begin_layout Standard
Dependency Injection hilft dabei, Verantwortungen klarer aufzuteilen und
 zu definieren.
 Durch das Einhalten des Single Responsibility Principles wird es deutlicher
 an welchen Stellen Änderungen gemacht werden müssen.
 Oft genügt es eine konkrete Implementation durch eine andere auszutauschen,
 um ein gewünschtes Verhalten zu erzielen.
 Dependency Injection macht dies trivial.
\end_layout

\begin_layout Subsection
Wiederverwendbarkeit
\end_layout

\begin_layout Standard
Einzelne Softwaremodule sind wiederverwendbar, da diese lose zu ihren Abhängigke
iten gekoppelt sind.
 Die eigentliche Implementation dieser Abhängigkeiten ist für das Modul
 nicht relevant.
 Ist in einer anderen Umgebung eine andere konkrete Implementation notwendig,
 so kann sie einfach ausgetauscht werden.
\end_layout

\begin_layout Subsection
Parallele Entwicklung
\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht die parallele Entwicklung einer Softwareanwendung,
 indem klare Schnittstellen zur Kommunikation definiert werden.
 Unter den kollaborierenden Entwicklern muss sich lediglich auf diese Schnittste
llen geeinigt werden.
 Die konkreten Implementationen sind nicht mehr relevant und können unabhängig
 voneinander im Parallelen umgesetzt werden.
\end_layout

\begin_layout Subsection
Testbarkeit
\end_layout

\begin_layout Standard
Wie lose Kopplung die Testbarkeit einer Anwendung drastisch erleichtert,
 lässt sich am besten anhand eines Beispiels erläutern: Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Testability"

\end_inset

 zeigt die Implementation eines simplen Spiels: Der Spieler soll das Resultat
 eines Würfelwurfs erraten.
 Mit der 
\shape italic
Roll
\shape default
-Methode der gezeigten 
\shape italic
GuessANumber
\shape default
-Klasse soll der Würfelwurf ausgeführt werden.
 Darauf folgend kann der Spieler -- durch den Aufruf der 
\shape italic
MakeGuess
\shape default
-Methode -- den Versuch vornehmen, das Ergebnis zu erraten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GuessANumber
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private IRandom random;
\end_layout

\begin_layout Plain Layout

	private int result;
\end_layout

\begin_layout Plain Layout

	private const int max = 6;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public GuessANumber(IRandom random)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.random = random;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GuessANumber Roll()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		result = random.Range(1, max);
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public bool MakeGuess(int guess)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return result == guess;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IRandom
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int Range(int min, int max);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel einer durch Dependency Injection testbaren Klasse.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Testability"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Testbare Klasse durch Dependency Injection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die 
\shape italic
GuessANumber
\shape default
-Klasse hat eine unbeständige (
\begin_inset Quotes gld
\end_inset

volatile
\begin_inset Quotes grd
\end_inset

) Abhängigkeit zu 
\shape italic
IRandom
\shape default
.
 Diese Entscheidung wurde bewusst getroffen, da das Generieren einer Zufallsnumm
er nicht deterministisch ist.
 Die Abhängigkeit zu 
\shape italic
IRandom
\shape default
 wird über Constructor Injection aufgelöst.
 Eine Klasse, die das 
\shape italic
IRandom
\shape default
-Interface implementiert, könnte mithilfe von 
\shape italic
UnityEngine.Random 
\shape default
oder 
\shape italic
System.Random
\shape default
 umgesetzt werden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:GuessANumber-UnitTest"

\end_inset

 zeigt einen Unittest, der sicherstellen soll, dass die 
\shape italic
MakeGuess
\shape default
-Methode korrekt feststellen kann, ob richtig geraten wurde.
 Um die 
\shape italic
GuessANumber
\shape default
-Klasse durch einen Unittest auf korrekte Funktionalität prüfen zu können,
 muss das Resultat deterministisch sein.
 Hierzu wird anstatt einer echten Implementation einer 
\shape italic
Random
\shape default
-Klasse ein Stub des 
\shape italic
IRandom
\shape default
-Interfaces erzeugt.
 Das Erzeugen eines Stubs kann durch Verwendung des Isolation-Frameworks
 NSubstitute automatisiert werden: Durch Aufruf der Methode 
\shape italic
For<T>
\shape default
 der Klasse 
\shape italic
Substitute
\shape default
 wird ein dynamischer Stub für 
\shape italic
IRandom
\shape default
 erzeugt.
 Der Stub wird so konfiguriert, dass er für jeden Aufruf der 
\shape italic
Range
\shape default
-Methode -- unabhängig von beiden Parametern -- einen vorgegebenen Wert
 zurückgibt.
 Das Ergebnis eines Würfelwurfs durch die 
\shape italic
Roll
\shape default
-Methode wird somit diesem vorgegebenen Wert entsprechen.
 Damit ist zu erwarten, dass der Aufruf der 
\shape italic
MakeGuess
\shape default
-Methode mit dem vorgegebenen Wert, 
\begin_inset Quotes gld
\end_inset

true
\begin_inset Quotes grd
\end_inset

 zurückgibt.
 Die tatsächliche Funktionalität der Methode kann nun durch ein Assert-Statement
 überprüft werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using NUnit.Framework;
\end_layout

\begin_layout Plain Layout

using NSubstitute;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[TestFixture]
\end_layout

\begin_layout Plain Layout

public class GuessANumberTests
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Test]
\end_layout

\begin_layout Plain Layout

	public void ShouldReturnTrueForRightGuess()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var expected = 6;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var randomStub = Substitute.For<IRandom>();
\end_layout

\begin_layout Plain Layout

		randomStub.Range(Arg.Any<int>(), Arg.Any<int>()).Returns(expected);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var guessANumber = new GuessANumber(randomStub);
\end_layout

\begin_layout Plain Layout

		guessANumber.Roll();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Assert.True(guessANumber.MakeGuess(expected));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Testen der 
\shape italic
GuessANumber
\shape default
-Klasse.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:GuessANumber-UnitTest"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Testen der GuessANumber-Klasse
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lose Kopplung ermöglicht, dass Module in Isolation betrachtet werden können.
 Durch Dependency Injection können zugrunde liegende Implementationen einer
 Abstraktion durch Fakes, Mocks und Stubs ausgetauscht werden.
 Es muss mit Bedacht auf die Testbarkeit einer Anwendung entschieden werden,
 ob eine Abhängigkeit fest oder unbeständig ist.
 Der sicherste Weg Testbarkeit zu gewährleisten, ist es Test Driven Development
 in Kombination mit Dependency Injection zu praktizieren 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 10"
before "vgl."
key "Bender2011"

\end_inset

.
\end_layout

\begin_layout Chapter
Analyse der Architektur von Unity3D
\begin_inset CommandInset label
LatexCommand label
name "chap:Analyse-der-Architektur"

\end_inset


\end_layout

\begin_layout Standard
In dem letzten Kapitel wurde beschrieben, was lose Kopplung ist und wie
 Inversion Of Control, und genauer Dependency Injection, dabei helfen, diese
 umzusetzen.
 Es wurde beschrieben, dass lose Kopplung maßgeblich zu der Qualität eines
 Softwareproduktes beiträgt.
 Dependency Injection wurde beispielhaft in einer Konsolenanwendung angewendet.
 In diesem Kapitel werden relevante Unterschiede zwischen der klassischen
 objektorientierten Programmierung bei der Entwicklung einer Konsolenanwendung
 und der komponentenbasierten Architektur von Unity3D beschrieben.
 Gute und schlechte Praktiken bei der Arbeit mit Unity3D werden erläutert.
 Unity3D stellt von sich aus Mittel bereit, um die Kommunikation zwischen
 Klassen zu ermöglichen.
 Es wird untersucht, ob diese es bereits ermöglichen lose Kopplung umzusetzen.
\end_layout

\begin_layout Section
Komponentenbasierte Architektur von Unity3D
\end_layout

\begin_layout Standard
Jede Spieleengine implementiert eine Form eines Game Object Models.
 Ein Game Object Model beschreibt Hilfsmittel, die es ermöglichen Entitäten
 innerhalb der Spielwelt zu modellieren und zu simulieren 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 854"
before "vgl."
key "Gregory2014"

\end_inset

.
 Meistens bestehen diese Hilfsmittel aus zwei Teilen: einer visuellen Repräsenta
tion der Spielobjekte innerhalb des Editors der Engine und einer Laufzeitumgebun
g, die die Entwicklung neuer Spielobjekte ermöglicht.
 In jedem Fall wird ein Framework bereitgestellt, das die Konstruktion neuer
 Spielobjekte erlaubt 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 869"
before "vgl."
key "Gregory2014"

\end_inset

.
\end_layout

\begin_layout Standard
In klassischen objektorientierten Implementationen eines Game Object Models
 werden Spielobjekte von einer Vererbungshierarchie abgeleitet.
 Es handelt sich um eine monolithische Klassenhierarchie: Alle Objekte werden
 von einer gemeinsamen Basisklasse namens 
\shape italic
GameObject
\shape default
 abgeleitet.
 Diese Basisklasse enthält Funktionalitäten, die für alle Klassen notwendig
 sind.
 Ein Beispiel hierfür ist Serialisierung.
 Mit Wachstum des Projektes wächst auch die Hierarchie stets tiefer und
 weiter.
 Es folgt eine Reihe von Problemen: Klassen, die sich tief in der Vererbungshier
archie befinden, sind schwierig zu verstehen und zu verändern, da hierfür
 auch alle Basisklassen bekannt sein müssen.
\end_layout

\begin_layout Standard
Es kann nur ein Merkmal als Basis für eine Vererbungshierarchie gewählt
 werden.
 Ein Merkmal kann beispielsweise die Beweglichkeit eines Objekts sein.
 Eine andere Charakteristik wäre die Fähigkeit mit anderen Objekten zu kollidier
en.
 Möchte man ein Objekt mit beiden Merkmalen haben, so stößt man schnell
 an die Grenzen einer solchen Architektur: Die benötigten Funktionalitäten
 müssen in der Hierarchie nach oben verschoben werden und bewirken so, dass
 sie eventuell in Klassen vorhanden sind in denen sie nicht gebraucht werden.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:monolitic"

\end_inset

 wird das Problem veranschaulicht.
 Das Problem kann in einigen Sprachen auch durch Mehrfachvererbung gelöst
 werden, was aber zu einem Deadly Diamond führen kann: Ein Deadly Diamond
 entsteht indem eine Klasse von zwei Klassen erbt, die wiederum von der
 selben Basisklasse erben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/problem.png
	scale 66

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Doppelte Logik aufgrund einer monolithischen Vererbungshierarchie.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 215"
before "Quelle: in Anlehnung an"
key "Nystrom2014"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Monolithsche Vererbungshierarchie
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:monolitic"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um dem Auftreten dieser Probleme vorzubeugen, implementiert Unity3D ein
 komponentenbasiertes Game Object Model.
 Das Grundprinzip dieses Models ist Komposition der Vererbung vorzuziehen.
 Anstatt Objekte mittels Vererbung und des 
\begin_inset Quotes gld
\end_inset

is a
\begin_inset Quotes grd
\end_inset

-Verhältnisses zu erweitern, erfolgt die Komposition eines Spielobjekts
 aus einzelnen Komponenten über das 
\begin_inset Quotes gld
\end_inset

has a
\begin_inset Quotes grd
\end_inset

-Verhältnis.
 In Unity werden Spielobjekte von der Klasse 
\shape italic
GameObject
\shape default
 abgebildet.
 Ein 
\shape italic
GameObject
\shape default
 fungiert als Knotenpunkt für eine variable Anzahl von Komponenten und hat
 kaum bis gar keine weitere Funktionalität 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 887"
before "vgl."
key "Gregory2014"

\end_inset

.
 Funktionalität wird erst durch das Anfügen von Komponenten hinzugefügt.
 Komponenten werden in Unity3D von der Klasse 
\shape italic
MonoBehaviour
\shape default
 abgeleitet.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:ComponentBasedArchitecture"

\end_inset

 zeigt eine vereinfachte Darstellung der komponentenbasierten Architektur
 Unitys.
 Die tatsächliche Implementation ist jedoch nicht bekannt, da es sich bei
 Unity3D um proprietäre Software handelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/CBA.png
	scale 66

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vereinfachte Darstellung der komponentenbasierten Architektur Unitys.
 
\begin_inset CommandInset citation
LatexCommand citealp
after "S. 886"
before "Quelle: in Anlehnung an"
key "Gregory2014"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Komponentenbasierte Architektur Unitys
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:ComponentBasedArchitecture"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Programmierung und Konfiguration
\end_layout

\begin_layout Standard

\shape italic
MonoBehaviours
\shape default
 sind die Schnittstelle, die es Programmierern ermöglicht die Engine mit
 individuellem Verhalten zu erweitern, um ein Spiel umsetzen zu können.
 Unity3D verwendet die .NET-kompatible Laufzeitumgebung Mono um die plattformunab
hängige Entwicklung von Komponenten in C# und UnityScript zu ermöglichen.
 Dem Nutzer stehen folglich objektorientierte Sprachfeatures wie Polymorphismus
 und Vererbung innerhalb der Komponenten zur Verfügung.
 Komponenten können durch die Implementation von einer Reihe von vordefinierten
 Eventfunktionen Einfluss auf das Spielgeschehen nehmen.
\end_layout

\begin_layout Standard
Der Rest -- also die Konfiguration und Komposition von Komponenten -- erfolgt
 in einem visuellen Editor.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Unity-Editor"

\end_inset

 zeigt das Benutzerinterface des Unity Editors.
 Der Editor erlaubt das Anlegen von Szenen, die den Lebensraum für Spielobjekte
 darstellen.
 Spielobjekte werden im sogenannten Hierarchiefenster erstellt und in einem
 Szenegraph angeordnet.
 Per Drag-and-Drop können Spielobjekten Komponenten hinzugefügt werden.
 Öffentliche Member einer Komponente können im Inspector konfiguriert werden.
 Wird eine Szene geladen, kümmert sich Unity3D, um die Instanziierung aller
 sich in der Szene befindlichen Spielobjekte und deren Komponenten.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Editor-Breakdown.jpg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Das Benutzerinterface vom Unity Editor.
 Quelle: 
\begin_inset CommandInset citation
LatexCommand citealp
key "Unity2015:Interface"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Unity-Editor"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Das Benutzerinterface vom Unity Editor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Betrachtet man die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Inversion-of-Control"

\end_inset

 gegebene Definition von Inversion Of Control, stellt man fest, dass diese
 auch auf Unity3D zutrifft.
 Die Kontrolle über die Komposition und Lebenszeit von Objekten ist bereits
 invertiert: Sie liegt in den Händen von Unity3D.
 Ein Indiz hierfür ist, dass Unity3D keine Konstruktoren in 
\shape italic
MonoBehaviours
\shape default
 zulässt.
 Es ist also nicht möglich, Komponenten über einen Konstruktor mit ihren
 Abhängigkeiten zu versorgen.
 Aus diesem Grund stellt Unity3D alternative Wege zur Referenzierung und
 Kommunikation mit anderen Komponenten bereit.
 Diese werden im folgenden Abschnitt erläutert.
\end_layout

\begin_layout Section
Kommunikation und Abhängigkeiten
\end_layout

\begin_layout Standard
In Unity3D soll jede Komponente eine einzige Funktionalität kapseln und
 sie wiederverwendbar machen.
 Mit anderen Worten: Komposition anstelle von Vererbung soll es ermöglichen
 Funktionalitäten aus unterschiedlichen Bereichen in wiederverwendbare Komponent
en aufzuteilen, ohne sie dabei miteinander zu koppeln 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 213"
before "vgl."
key "Nystrom2014"

\end_inset

.
 In der Realität ist dies jedoch nur begrenzt möglich: Komponenten sind
 Teile eines größeren Ganzen und müssen somit kommunizieren und interagieren.
 Komponenten haben folglich Abhängigkeiten zueinander.
 
\end_layout

\begin_layout Standard
Oft beschränkt sich die Kommunikation auf Komponenten desselben GameObjects.
 Es kommt jedoch auch vor, dass ein MonoBehaviour mit einem MonoBehaviour
 eines anderen GameObjects kommunizieren muss.
 Folglich wird zwischen zwei Arten der Kommunikation unterschieden:
\end_layout

\begin_layout Itemize
Die Intra-Objekt-Kommunikation erfolgt unter MonoBehaviours desselben GameObject
s oder Kindern von diesem.
\end_layout

\begin_layout Itemize
Die Inter-Objekt-Kommunikation beschreibt die Kommunikation zu anderen GameObjet
cts, die ansonsten in keiner Relation zueinanderstehen.
\end_layout

\begin_layout Standard
In beiden Fällen kann die Kommunikation direkt oder indirekt erfolgen.
 Bei direkter Kommunikation ist es notwendig, dass entweder Sender oder
 Empfänger einander kennen.
 Eines der Objekte hat also eine Abhängigkeit zu dem anderen.
 Kommunikation ist indirekt, wenn sie über ein drittes Objekt -- einem Vermittle
r -- erfolgt.
 In den meisten Fällen wird eine Referenz auf ein weiteres Objekt benötigt
 und es existiert somit eine Abhängigkeit zu diesem.
\end_layout

\begin_layout Standard
Im folgenden Abschnitt wird untersucht, ob Unitys integrierte Möglichkeiten
 Abhängigkeiten aufzulösen es ermöglichen, lose Kopplung zwischen Komponenten
 umzusetzen.
\end_layout

\begin_layout Subsection
Referenzieren von anderen MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "sub:Referenzieren"

\end_inset


\end_layout

\begin_layout Standard
Unity3D bietet unterschiedliche Möglichkeiten, um Zugriff auf Spielobjekte
 und Komponenten zu erlangen.
 Es werden zahlreiche Game Object Queries für die Inter-Objekt-Kommunikation
 bereitgestellt.
 Um andere Komponenten referenzieren zu können, existieren sogenannte Component
 Queries.
 Des Weiteren ist auch eine Kommunikation über Events und Messages möglich.
 
\end_layout

\begin_layout Subsubsection
SerializeField
\end_layout

\begin_layout Standard

\shape italic
SerializeField
\shape default
 ist ein Attribut, das ermöglicht private Member einer Komponente zu serialisier
en und somit im Inspektor zu setzen.
 Setzbare Datentypen sind primitive Datentypen wie 
\shape italic
int
\shape default
, 
\shape italic
float
\shape default
, 
\shape italic
bool
\shape default
 und in Unity3D eingebaute Datentypen wie 
\shape italic
Vector
\shape default
, 
\shape italic
Quaternion
\shape default
 und 
\shape italic
Color
\shape default
, sowie Strings, Enums und Structs.
 Des Weiteren können Referenzen zu Klassen und Objekten durch Drag-and-Drop
 im Editor gesetzt werden.
 Dabei ist zu beachten, dass diese Objekte vom Typ 
\shape italic
UnityEngine.Object
\shape default
 ableiten müssen.
 Es können also ausschließlich Komponenten oder Spielobjekte referenziert
 werden.
 Aufgrund dieser Limitierung ist es nicht möglich, Interfaces im Editor
 zugänglich zu machen.
 Mit dem 
\shape italic
SerializeField
\shape default
-Attribut lässt sich somit keine lose Kopplung umsetzen.
 
\end_layout

\begin_layout Standard
Neben Variablen mit dem 
\shape italic
SerializeField
\shape default
-Attribut werden auch Variablen, die mit dem Zugriffsmodifizierer 
\shape italic
public
\shape default
 gekennzeichnet wurden im Editor zugänglich gemacht.
 Dies ist jedoch ausdrücklich nicht zu empfehlen, da so die Datenkapselung
 des Objektes gebrochen wird.
\end_layout

\begin_layout Standard
Ist bereits vor Ausführung des Spiels bekannt, welche Referenzen benötigt
 werden, sollten diese, wenn möglich, über 
\shape italic
SerializeField
\shape default
 aufgelöst werden.
 Um sicherzugehen, dass die Referenz im Editor aufgelöst wurde, ist es ratsam,
 einen Guard Clause in die 
\shape italic
OnValidate
\shape default
-Funktion der Komponente hinzuzufügen.
 In Abbildung
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SerializeField"

\end_inset

 wird dies anhand eines einfachen Beispiels verdeutlicht.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.UI;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Assertions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SomeBehaviour : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[SerializeField]
\end_layout

\begin_layout Plain Layout

	private Image myImage;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnValidate()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Assert.IsNotNull(myImage);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SerializeField mit Guard Clause in OnValidate.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:SerializeField"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
SerializeField mit Guard Clause in OnValidate
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn erst zur Laufzeit bestimmt werden kann, welches das benötigte Objekt
 ist, zum Beispiel, wenn sich die Abhängigkeit außerhalb eines instanziierten
 Prefabs befindet, so muss auf eine andere Methode der Referenzierung zurückgegr
iffen werden.
\end_layout

\begin_layout Subsubsection*
GetComponent
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponent(Type type);
\end_layout

\begin_layout Plain Layout

public T GetComponent();
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Signaturen der GetComponent-Methoden.
 Quelle: Eigene Abbildung
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Signaturen der GetComponent-Methoden
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Signaturen-der-GetComponent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
GetComponent
\shape default
 ermöglicht es, auf andere Komponenten desselben GameObjects zuzugreifen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Signaturen-der-GetComponent"

\end_inset

 zeigt die Signaturen, der in der Klasse 
\shape italic
MonoBehavior
\shape default
 zur Verfügung stehenden 
\shape italic
GetComponent
\shape default
-Methoden.
 Ist keine Komponente des gewünschten Typs vorhanden, wird 
\shape italic
null
\shape default
 zurückgegeben.
 Dies kann verhindert werden, indem man dem Script das Attribut 
\shape italic
RequireComponent
\shape default
 hinzufügt.
 
\shape italic
RequireComponent
\shape default
 bewirkt, dass die benötigte Komponente automatisch an das GameObject angefügt
 wird.
 Um auf Komponenten von anderen GameObjects in der über- und untergeordneten
 Hierarchieebene zugreifen zu können, werden zusätzlich die in Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GetComponentInChildren"

\end_inset

 gezeigten Methoden bereitgestellt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponentInChildren(Type t);
\end_layout

\begin_layout Plain Layout

public Component GetComponentInParent(Type t);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Signaturen der GetComponentInChildren-Methoden.
 Quelle: Eigene Abbildung
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Signaturen der GetComponentInChildren-Methoden
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:GetComponentInChildren"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle 
\shape italic
GetComponent
\shape default
-Methoden spezifizieren einen Typparameter 
\shape italic
T
\shape default
 als Suchkriterium (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GetComponentInChildren"

\end_inset

).
 Da 
\shape italic
T
\shape default
 nicht weiter -- zum Beispiel auf 
\shape italic
UnityEngine.Object
\shape default
 -- beschränkt wird, ist es möglich, anstatt konkreten Komponenten auch
 Komponenten anhand eines Interfaces zu finden.
 Enge Kopplung zu einer konkreten Implementation einer Komponente entsteht
 so nicht.
 Dennoch ist 
\shape italic
GetComponent
\shape default
 keine optimale Lösung: Die Komponente selbst kümmert sich um die Auflösung
 ihrer Abhängigkeiten.
 
\shape italic
GetComponent
\shape default
 funktioniert somit entgegengesetzt zum Hollywood-Prinzip.
 Es ist von außen nicht sichtbar, dass die Komponente Abhängigkeiten hat.
 Ohne die Implementation der Komponente zu kennen, kann keine Aussage darüber
 getroffen werden, welche Abhängigkeiten notwendig sind, damit sie funktioniert.
 Die Komponente kann nur in Verbindung mit anderen Komponenten als GameObject
 getestet werden.
\end_layout

\begin_layout Standard
Beim Verwenden von 
\shape italic
GetComponent
\shape default
 wird implizit eine Anordnung in der Objekthierarchie festgelegt.
 Wird zum Beispiel eine benötigte Komponente in ein Child-GameObject verschoben,
 ist das Spiel ohne Änderung im Programmcode nicht mehr lauffähig.
 Aus diesem Grund sollte GetComponent nur in Ausnahmefällen, wenn beispielsweise
 eine Komponente zur Laufzeit hinzugefügt wird, verwendet werden.
 
\end_layout

\begin_layout Subsubsection*
Stringbasierte Find-Funktionen
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static GameObject Find(string name);
\end_layout

\begin_layout Plain Layout

public static GameObject FindWithTag(string tag);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Signaturen der stringbasierten Find-Funktionen.
 Quelle: Eigene Abbildung
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Signaturen der stringbasierten Find-Funktionen
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Find-stringbasierten"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unitys 
\shape italic
Find
\shape default
-Funktionen sind klassische Game Object Queries zur Inter-Objekt Kommunikation.
 Das gewünschte Spielobjekt wird auf Basis eines Strings als Suchkriterium
 zurückgegeben (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Find-stringbasierten"

\end_inset

).
 Dieser String kann entweder der Name oder ein Tag sein.
 Nachdem das gesuchte Objekt gefunden wurde, muss die gewünschte Komponente
 mittels 
\shape italic
GetComponent
\shape default
 ausfindig gemacht werden.
 Die Funktionen unterscheiden sich im Verhalten, falls kein passendes GameObject
 gefunden wird: Wird kein Objekt mit einem passenden Namen gefunden, gibt
 
\shape italic
Find
\shape default
 
\shape italic
null
\shape default
 zurück.
 Wird kein Objekt mit einem passenden Tag gefunden, wirft 
\shape italic
FindWithTag
\shape default
 eine 
\shape italic
UnityException
\shape default
.
\end_layout

\begin_layout Standard
Generell ist von der Nutzung beider Funktionen abzuraten, da diese nicht
 gewährleisten, dass das gesuchte GameObject tatsächlich auffindbar ist.
 Es wird sich darauf verlassen, dass ein GameObject mit bestimmtem Namen
 oder Tag in der Szene existiert und die gewünschten Komponenten an diesem
 vorhanden sind.
 Es gibt somit viel Raum für Fehlkonfiguration.
\end_layout

\begin_layout Subsubsection*
FindObjectOfType
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static Object FindObjectOfType(Type type);
\end_layout

\begin_layout Plain Layout

public static T FindObjectOfType<T>() where T : Object;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Signaturen der FindObjectOfType-Methoden.
 Quelle: Eigene Abbildung
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Signaturen der FindObjectOfType-Methoden
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:FindObjectOfType"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Gegensatz zu den anderen 
\shape italic
Find
\shape default
 Functions ist 
\shape italic
FindObjectOfType
\shape default
 typsicher (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FindObjectOfType"

\end_inset

).
 Es wird gewährt, dass eine in der Szene aktive Instanz eines bestimmten
 Typs erhalten wird.
 Anzumerken ist, dass der gewünschte Typ von 
\shape italic
UnityEngine.Object
\shape default
 abgeleitet sein muss.
 Somit funktioniert auch 
\shape italic
FindObjectOfType
\shape default
 nicht mit Interfaces.
 Die generische Variante von 
\shape italic
FindObjectOfType
\shape default
 ist anderen 
\shape italic
Find
\shape default
-Funktionen vorzuziehen, da sie direkt die Instanz der gesuchten Komponente
 vom Typ 
\shape italic
T
\shape default
 als Rückgabewert liefert.
 Es ist also nicht nötig 
\shape italic
GetComponent
\shape default
 zu nutzen.
\end_layout

\begin_layout Standard
In der Dokumentation der Funktion wird angemerkt, dass 
\shape italic
FindObjectOfType
\shape default
 sehr langsam ist.
 Sie sollte daher nicht in jedem Frame aufgerufen werden.
 Als Alternative wird das Singleton Pattern vorgeschlagen 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Unity2015:FindObjectOfType"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Singleton und Statics
\end_layout

\begin_layout Standard
Singletons stellen sicher, dass es nur eine Instanz einer Klasse gibt, auf
 welche ein globaler Zugriffspunkt existiert.
 Singletons werden hier mit aufgeführt, weil sie in Unity3D alternativ zu
 
\shape italic
FindObjectOfType
\shape default
 genutzt werden können, mit der Beschränkung, dass sie auf eine Instanz
 limitiert sind.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Singleton"

\end_inset

 zeigt eine mögliche Implementation eines Singletons, welches von 
\shape italic
MonoBehaviour
\shape default
 ableitet.
 Die Singletonkomponente muss lediglich einem Spielobjekt in der Szene hinzugefü
gt werden, um es global verfügbar zu machen.
 Der Zugriff auf die Singletonkomponente erfolgt über die statische Variable
 
\shape italic
Instance
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Singleton : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static Singleton Instance { get; private set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Awake ()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (Instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Instance = this;
\end_layout

\begin_layout Plain Layout

			DontDestroyOnLoad (this);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Destroy (gameObject);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Singleton Patterns in Form eines MonoBehaviours.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Singleton"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation des Singleton Patterns
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die abgebildete Implementation des Singletons erlaubt es, Funktionalitäten
 eines MonoBehaviours, wie dem Update Loop, zu nutzen.
 Sollten diese Funktionalitäten nicht notwendig sein, kann auch ein klassischer
 Singleton nach der Gang Of Four verwendet werden 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 127"
before "siehe"
key "Gamma1994"

\end_inset

.
 Ist gar keine Vererbung notwendig, gibt es keinen Grund ein Singleton zu
 implementieren.
 Stattdessen kann eine statische Klasse verwendet werden.
\end_layout

\begin_layout Standard
An dieser Stelle sei anzumerken, dass Singletons aus vielen Gründen als
 Anti-Pattern angesehen werden.
 Eine der Ursachen dafür ist, dass sie einen globalen Zustand einführen.
 Gleiches gilt für statische Klassen.
 Globaler Zustand führt dazu, dass Klassen nicht in Isolation testbar sind.
 Wird Zustand von einem Testfall auf einen anderen übertragen, kann dieser
 das Verhalten des Tests manipulieren.
 
\end_layout

\begin_layout Standard
Eine Klasse die einen Singleton verwendet, verschleiert ihre Abhängigkeit
 zu diesem.
 Von außerhalb ist nicht ersichtlich, dass die Klasse überhaupt eine Abhängigkei
t hat.
 Damit ist der Singleton eng mit der Klasse gekoppelt und nicht austauschbar.
 In Unittests kann eine solche Abhängigkeit nicht durch ein Test Double
 ausgetauscht werden.
\end_layout

\begin_layout Standard
Singletons verletzen das Single Responsibility Principle: Zusätzlich zu
 ihrer Anwendungslogik erhält eine Klasse die Verantwortung, sicherzustellen,
 dass lediglich eine einzige Instanz von ihr existiert 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Densmore2004"

\end_inset

.
\end_layout

\begin_layout Subsection
Events und Messages
\end_layout

\begin_layout Standard
Alternativ kann die Kommunikation zwischen Objekten auch über Events erfolgen.
 Events können im Unterschied zu Methodenaufrufen keinen oder mehrere Empfänger
 haben.
 Grundlage für Events ist das Observer Pattern.
 Die Klasse, die das Event auslöst, wird als Sender und die Klassen, die
 das Event behandeln als Empfänger, bezeichnet.
 Ein typischer Anwendungsfall für Events sind UI-Elemente wie Buttons, Slider
 und Toggles.
 Nichtsdestotrotz kann mit Events das gleiche Ergebnis wie mit Referenzierung
 und Methodenaufruf erzielt werden.
 Unity3D und C# bieten mehrere Möglichkeiten um die Kommunikation mittels
 Events umzusetzen.
 In dieser Arbeit wird die Implementation von C# Events nicht aufgeführt,
 da sie ohne Mediation oder Statics nicht das Problem der Referenzierung
 lösen.
 Wird ein gewöhnliches C# Event als Kommunikationskanal gewählt, so muss
 der Empfänger über einen der im letzten Abschnitt beschriebenen Wege Zugriff
 auf den Sender erhalten.
 Um diese Limitierung zu umgehen, bietet Unity3D ab der Version 4.6 eine
 eigene Implementierung von Events.
\end_layout

\begin_layout Subsubsection*
UnityEvent (Unity3D 4.6+)
\end_layout

\begin_layout Standard
UnityEvents ermöglichen das Setzen von Callbacks über das Editorfenster.
 Auf diese Weise sind Sender und Empfänger komplett voneinander entkoppelt.
 Darüber hinaus bieten UnityEvents zusätzlich nahezu identische Funktionalität
 wie klassische C# Events.
\end_layout

\begin_layout Standard
Die Verwendung eines nicht-generischen UnityEvents ohne Parameter wird in
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEventCode"

\end_inset

 gezeigt.
 Die 
\shape italic
Publisher
\shape default
 Komponente löst das Event in der 
\shape italic
Start
\shape default
-Methode aus.
 Ein Empfänger benötigt lediglich eine öffentliche Methode mit der passenden
 Signatur.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Events;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public UnityEvent myEvent;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (myEvent != null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			myEvent.Invoke();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Recieved");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Senders und Empfängers unter Verwendung eines UnityEvents.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEventCode"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
UnityEvent Publisher und Subscriber
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist, dass bis jetzt noch keine Verbindung zwischen Sender und
 Empfänger existiert.
 Diese kann im Editor gesetzt werden (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEvent"

\end_inset

).
 Somit wird es ohne weiteren Programmcode möglich, zu bestimmen wer auf
 ein Event reagieren soll.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/UnityEvent.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzufügen einer Callback-Methode für einen UnityEvent im Editor.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEvent"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Hinzufügen einer Callback-Methode für einen UnityEvent im Editor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents bieten eine Möglichkeit, Sender von Empfänger komplett voneinander
 zu entkoppeln.
 Allerdings besteht ebenfalls ein hohes Risiko einer Fehlkonfiguration.
 Es ist nicht im Programmcode ersichtlich, ob Empfänger existieren und wer
 diese sind.
 Genauso wenig wird deutlich, ob eine als öffentlich gekennzeichnete Methode
 als Callback genutzt wird oder nicht.
 Oft werden Methoden und Events, auf die keine Referenzen im Programmcode
 existieren, einfach gelöscht.
\end_layout

\begin_layout Standard
Events sind dafür geeignet optionale Abhängigkeiten aufzulösen.
 Ist eine Abhängigkeit jedoch zwingend erforderlich, sollte zu einer anderen
 Möglichkeit gegriffen werden.
\end_layout

\begin_layout Subsubsection*
Senden von Messages
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void SendMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, SendMessageOptions options);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Methoden der Klasse MonoBehaviour zur Message-Kommunikation.
 Quelle: Eigene Abbildung 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Methoden der Klasse MonoBehaviour zur Message-Kommunikation
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:SendMessage-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
MonoBehaviours bieten die Funktionalität, untereinander mittels Messages
 zu kommunizieren (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SendMessage-1"

\end_inset

).
 
\shape italic
SendMessage
\shape default
 ermöglicht die Kommunikation zwischen Komponenten innerhalb eines Spielobjekts.
 
\shape italic
BroadcastMessage
\shape default
 sendet eine Message an das aufrufende Spielobjekt und dessen Kindobjekte.
 
\shape italic
SendMessageUpwards
\shape default
 sendet die Nachricht an alle Spielobjekte, die sich dem Spielobjekt übergeordne
t in der Szene-Hierarchie befinden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SendMessage"

\end_inset

 zeigt die Verwendung von 
\shape italic
SendMessage
\shape default
 anhand von zwei Komponenten, die sich am gleichen Spielobjekt befinden.
 Der Sender einer Message spezifiziert die Callbackmethode mittels eines
 Stringparameters.
 Dieser String repräsentiert den Namen der gewünschten Callbackmethode.
 Der Zugriffsmodifizierer der Callbackmethode ist dabei nicht relevant.
 Sie kann, wie im Beispiel gezeigt, auch als 
\shape italic
private
\shape default
 deklariert werden.
 Durch den Aufzählungstyp 
\shape italic
SendMessageOptions
\shape default
 ist es möglich zu spezifizieren, ob ein Empfänger zwingend erforderlich
 ist.
 Wenn dieser als erforderlich gekennzeichnet wurde und dennoch kein Empfänger
 gefunden wird, wirft 
\shape italic
SendMessage
\shape default
 eine Ausnahme zur Laufzeit.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessagePublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		SendMessage("Receive");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessageSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendung von SendMessage.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:SendMessage"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Verwendung von SendMessage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape italic
SendMessage
\shape default
 verwendet 
\begin_inset Quotes gld
\end_inset

magic strings
\begin_inset Quotes grd
\end_inset

 zur Identifikation der Callbackmethode.
 Refactorings der Methodennamen gefährden die Funktionalität der Anwendung.
 Auch hier ist es nicht ersichtlich, ob eine ansonsten nicht verwendete
 private Methode als Callback genutzt wird.
 Nach dem YAGNI-Prinzip werden nicht verwendete private Methoden einfach
 gelöscht.
 
\shape italic
SendMessage
\shape default
 legt implizit eine Anordnung in der Hierarchie fest, indem Aufrufe spezifisch
 an Parent- oder Childelemente erfolgen müssen.
\end_layout

\begin_layout Standard
Aus diesen Gründen ist der Nutzung von SendMessage generell abzuraten.
 Besonders, da mit Unity Version 4.6 ein neues Messaging System als Ersatz
 für SendMessage vorgestellt wurde 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Unity2015:MessagingSystem"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
UnityEngine.EventSystems (Unity3D 4.6+)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static bool Execute(GameObject target, EventSystems.BaseEventData
 eventData, EventFunction<T> functor);
\end_layout

\begin_layout Plain Layout

public static GameObject ExecuteHierarchy(GameObject root, EventSystems.BaseEvent
Data eventData, EventFunction<T> callbackFunction);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Methodensignaturen des Eventsystems.
 Quelle: Eigene Abbildung 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Methodensignaturen des Eventsystems
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Methodensignaturen-des-Event"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Eventsystem wurde in Verbindung mit uGUI in Unity3D 4.6 eingeführt.
 Es wird dazu verwendet, um Events bei Nutzereingaben zu senden.
 Man kann es jedoch auch für benutzerdefinierte Events verwenden.
 Anstelle eines Strings wird ein Interface verwendet, um eine Komponente
 zu kennzeichnen, die eine Callbackfunktion für ein bestimmtes Event implementie
rt.
 Events können mittels 
\shape italic
ExecuteHierarchy
\shape default
 in der Objekthierarchie nach oben, jedoch nicht nach unten, gesendet werden
 (siehe Abb.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Methodensignaturen-des-Event"

\end_inset

).
\end_layout

\begin_layout Standard
Ein Beispiel zur Verwendung des Eventsystems wird in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EventSystems"

\end_inset

 gezeigt.
 Der Sender löst ein Event durch den Aufruf der 
\shape italic
Execute
\shape default
-Methode der Klasse 
\shape italic
ExecuteEvents
\shape default
 in der 
\shape italic
Start
\shape default
-Methode aus.
 Die Angabe der Callbackmethode erfolgt als Parameter in Form einer Lambdafunkti
on.
  Es wird die 
\shape italic
Recieve
\shape default
-Methode des Empfängers aufgerufen.
 Hierzu muss der Empfänger das 
\shape italic
IEventTarget
\shape default
-Interface implementieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.EventSystems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.Execute<IEventTarget>(this.gameObject, null, (target, data)
 => target.Receive());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IEventTarget : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void Receive();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour, IEventTarget 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwenden von UnityEngine.EventSystems.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:EventSystems"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Verwenden von UnityEngine.EventSystems
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das neue Eventsystem ist ein typsicherer Ansatz Events an Komponenten in
 der Szenehierarchie zu senden.
 Sender und Empfänger sind lose miteinander gekoppelt.
 Bei der Verwendung entsteht jedoch eine Abhängigkeit zu der statischen
 
\shape italic
ExecuteEvents
\shape default
-Klasse.
 Testbarkeit ist somit nur innerhalb von Unity3D gewährleistet.
 Ohne das Spielobjekt der Empfängerkomponente zu kennen, kann jedoch nur
 an das eigene oder an direkte Parent-Spielobjekte gesendet werden.
 
\end_layout

\begin_layout Section
Wertung und Konsequenzen
\end_layout

\begin_layout Standard
Unitys komponentenbasierte Architektur hilft dabei, Klassen mit lediglich
 einer Verantwortung zu erstellen.
 Spielobjekte lassen sich durch Komposition aus Komponenten in der Szenehierarch
ie arrangieren.
 Um koordinieren zu können, müssen Komponenten miteinander kommunizieren.
 Unity3D stellt dafür unterschiedliche Wege zur Kommunikation mit anderen
 Komponenten bereit.
 Durch Verwendung dieser Kommunikationsmittel entstehen Abhängigkeiten und
 damit eine Form von Kopplung.
 Einige Methoden ermöglichen zwar lose Kopplung, aber nicht durch Inversion
 Of Control.
 Eines haben jedoch alle Kommunikationsmittel gemeinsam: Die Kommunizierenden
 müssen Komponenten oder Spielobjekte sein.
 Dies führt dazu, dass Objekte, um überhaupt kommunizieren zu können, von
 
\shape italic
MonoBehaviour
\shape default
 ableiten und an Spielobjekte angehängt werden.
\end_layout

\begin_layout Standard
Der Architektur von Unity3D fehlt ein Mittel zum Umgang mit geteilter Logik,
 die keinem einzelnen Spielobjekt zugeordnet werden kann.
 Es wird sich in der Regel auf einem von zwei Wegen Abhilfe geschaffen:
 
\end_layout

\begin_layout Itemize
Durch die Erstellung von sogenannten Manager- und Controllerobjekten, die
 an ansonsten 
\begin_inset Quotes gld
\end_inset

leere
\begin_inset Quotes grd
\end_inset

 Spielobjekte angehängt werden.
\end_layout

\begin_layout Itemize
Durch Singletons und statischen Klassen, die globalen Zugriff ermöglichen.
\end_layout

\begin_layout Standard
Solche Klassen haben oft keine eindeutig definierten Aufgaben.
 Sie wachsen mit der Zeit und werden somit zu 
\begin_inset Quotes gld
\end_inset

God Objects
\begin_inset Quotes grd
\end_inset

.
 Managerobjekte verletzen das Single-Responsibility Principle somit gleich
 auf mehreren Ebenen: Sie haben oft mehr als nur eine Aufgabe.
 Sie vermischen Darstellungs- mit Anwendungslogik, indem sie als Spielobjekte
 in der Szene existieren.
 Des Weiteren verletzen insbesondere Singletons das Single Responsibility
 Principle, indem sie ihre Erstellung mit anderer Anwendungslogik mischen.
 
\end_layout

\begin_layout Standard
Durch die Referenzierung von Singletons, statischen Klassen oder Managern
 mittels 
\begin_inset Quotes gld
\end_inset

Find
\begin_inset Quotes grd
\end_inset

-Methoden wird der Rest der Anwendung eng mit diesen gekoppelt.
 Es wird unmöglich einzelne Komponenten zu testen und in anderen Projekten
 wiederzuverwenden.
 Es besteht folglich auch in Unity3D das Bedürfnis nach einer Alternative,
 die es ermöglicht lose Kopplung umzusetzen, ohne dabei die Kommunikation
 auf Komponenten oder Spielobjekte zu beschränken.
 Im nächsten Kapitel wird beschrieben, wie Dependency Injection in Unity3D
 umgesetzt werden kann, um diese Ansprüche zu erfüllen.
\end_layout

\begin_layout Chapter
Dependency Injection in Unity3D
\end_layout

\begin_layout Standard
Aus dem Fazit des letzten Kapitels geht hervor, dass keiner der in Unity3D
 zur Verfügung stehenden Kommunikationsmechanismen den gewünschten Ansprüchen
 entspricht.
 Das Ziel lose Kopplung in Unity3D umzusetzen, besteht weiterhin.
 Weiter wurde im letzten Kapitel festgestellt, dass Unity3D Programmierer
 in vieler Hinsicht einschränkt.
 Kommunikation ist auf die in der Szene existierenden Spielobjekte und deren
 Komponenten beschränkt.
 Es wurde festgestellt, dass die Kontrolle über die Komposition von Objekten
 bereits invertiert ist.
 In diesem Kapitel wird beschrieben, wie es dennoch ermöglicht wurde, Dependency
 Injection in Unity3D umzusetzen.
 
\end_layout

\begin_layout Section
Automating Dependency Injection
\end_layout

\begin_layout Standard
In Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Composition-Root"

\end_inset

 wurde veranschaulicht, wie Dependency Injection 
\begin_inset Quotes gld
\end_inset

per Hand
\begin_inset Quotes grd
\end_inset

 angewendet werden kann.
 Benötigte Instanzen werden manuell im Composition Root instanziiert.
 In dem gezeigten Beispiel war dies noch sehr überschaubar.
 In einer echten Anwendung entstehen jedoch schnell komplexe Abhängigkeitshierar
chien, die eine manuelle Dependency Injection unübersichtlich und fehleranfällig
 machen.
 Aus diesem Grund wird sich oft dazu entschlossen, die Auflösung von Abhängigkei
ten zu automatisieren.
 
\end_layout

\begin_layout Standard
In Unity3D ist diese Automatisierung zwangsläufig erforderlich.
 Die Kontrolle über die Erstellung von Komponenten liegt in den Händen von
 Unity3D.
 Es ist nicht möglich, Komponenten über den Konstruktor mit ihren Abhängigkeiten
 zu versorgen.
 Es existiert kein klarer Einstiegspunkt in die Anwendung, der es ermöglichen
 würde, Komponenten von außen mit ihren Abhängigkeiten zu versorgen.
 Beim Laden einer Szene werden alle sich in ihr befindlichen Spielobjekte
 instanziiert.
\end_layout

\begin_layout Standard
Die Kontrolle über die Komposition von Objekten soll an einen sogenannten
 Inversion Of Control Container abgegeben werden.
 Im Composition Root wird vom Nutzer lediglich die Konfiguration des Containers
 vorgenommen.
 Die zu instanziierenden Typen werden an diesem Ort beim Container registriert.
 Der Container kümmert sich um alles Notwendige: Er versorgt alle Klassen
 mit ihren registrierten konkreten Abhängigkeiten und verwaltet die Lebenszeit
 aller Objekte.
 Im Folgenden wird eine Möglichkeit der Implementation eines Inversion Of
 Control Containers in Unity3D beschrieben.
 Dabei wird besonders darauf eingegangen, wo aufgrund von Unitys Architektur
 Einschränkungen gemacht werden müssen.
\end_layout

\begin_layout Section
Umsetzung eines Inversion Of Control Containers für Unity3D
\end_layout

\begin_layout Standard
Der folgende Abschnitt beschreibt die Umsetzung eines Inversion Of Control
 Containers für Unity.
 Als Name für das Framework wurde der Einfachheit halber 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

 gewählt.
 Anhand der Implementation des Frameworks werden die mit Inversion Of Control
 Containern verbundenen Konzepte erläutert.
 Weiter werden Hürden und Einschränkungen, die aus Unitys Architektur hervorgehe
n, beschrieben.
 Es werden Lösungen und Abhilfemaßnahmen für diese präsentiert.
 
\end_layout

\begin_layout Subsection
Definieren des Composition Roots
\begin_inset CommandInset label
LatexCommand label
name "sub:Definieren-des-Composition"

\end_inset


\end_layout

\begin_layout Standard
In Unity3D steht kein klarer Einstiegspunkt in die Anwendung zur Verfügung.
 Es existiert kein Zugriff auf eine 
\shape italic
Main
\shape default
-Methode, in der der Kontrollfluss der Anwendung beginnt.
 Der frühste Zeitpunkt, an dem der Nutzer Einfluss auf den Kontrollfluss
 der Anwendung nehmen kann, ist die 
\shape italic
Awake
\shape default
-Methode eines 
\shape italic
MonoBehaviours
\shape default
.
 Zu diesem Zeitpunkt wurden bereits die in der Szene platzierten Spielobjekte
 mitsamt ihren Komponenten instanziiert.
 Soweit nicht anders spezifiziert, erfolgt die Aufrufreihenfolge der 
\shape italic
Awake
\shape default
-Methoden der Komponenten zufällig nach der Reihenfolge, in der sie geladen
 werden.
 Es ist möglich in den Script Execution Order Settings anzugeben, dass ein
 bestimmtes Script früher oder später geladen werden soll 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Unity2015:ScriptExecution"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ExecutionOrderSettings.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Script Execution Order Settings mit Composition Root Komponente an oberster
 Stelle.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Script-Execution-Order"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Script Execution Order Settings mit Composition Root
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zur Definition des Composition Roots wird zunächst ein einfaches MonoBehaviour
 erstellt und einem leeren GameObject in der Szene hinzugefügt.
 Um sicherzustellen, dass dieses MonoBehaviour auch das erste Script ist,
 welches bei Anwendungsstart ausgeführt wird, sollte es in den Execution
 Order Settings an oberster Stelle stehen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Script-Execution-Order"

\end_inset

 zeigt die korrekte Konfiguration eines Composition Roots in den Script
 Execution Order Settings.
 Damit ist gewährleistet, dass der Composition Root Zugriff auf alle sich
 in der Szene befindlichen Komponenten hat, bevor diese ausgeführt werden.
 Im Composition Root kann nun die Konfiguration des Inversion Of Control
 Containers vorgenommen werden und Komponenten mit ihren Abhängigkeiten
 versorgt werden.
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CompositionRoot-Klasse"

\end_inset

 zu sehen ist, wurde der Composition Root im 
\begin_inset Quotes gld
\end_inset

Containter
\begin_inset Quotes grd
\end_inset

-Framework als abstrakte Klasse definiert.
 Die Aufgabe der Klasse ist es zunächst eine Instanz eines 
\shape italic
Containers
\shape default
 zu erstellen.
 Der 
\shape italic
Container
\shape default
 bildet das Herzstück des Frameworks.
 Durch ihn können abstrakte Basisklassen an ihre konkreten Instanzen 
\begin_inset Quotes gld
\end_inset

gebunden
\begin_inset Quotes grd
\end_inset

 werden.
 Diese Typregistrierung soll in der Methode 
\shape italic
SetupBindings
\shape default
 vorgenommen werden.
 Umgehend danach wird die 
\shape italic
Init
\shape default
-Methode aufgerufen.
 In ihr kann weitere Initialisierungslogik vorgenommen werden.
 Beide Methoden sind abstrakt, da die Typregistrierung für jede Applikation
 individuell erfolgen muss.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Container.Framework
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public abstract class CompositionRoot : UnityEngine.MonoBehaviour
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		protected IContainer container;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		protected virtual void Awake()
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container = new Container();
\end_layout

\begin_layout Plain Layout

			SetupBindings();
\end_layout

\begin_layout Plain Layout

			Init();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void SetupBindings();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		protected abstract void Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Klasse CompositionRoot.cs.
 Quelle: Eigene Abbildung 
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot-Klasse"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Klasse CompositionRoot.cs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die Umsetzung des Composition Roots abgeschlossen.
 Es fehlt jedoch noch die Implementation des Containers an sich.
 Im Folgenden wird beschrieben, wie dieser im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework umgesetzt wurde.
\end_layout

\begin_layout Subsection
Aufgaben eines Inversion Of Control Containers
\end_layout

\begin_layout Standard
Bevor mit der Implementierung des Containers begonnen werden kann, müssen
 zunächst dessen grundlegende Aufgaben erläutert werden.
 Die Hauptaufgabe eines Inversion Of Control Containers ist die Erstellung
 von Objekten.
 Hierfür muss dem Container bekannt sein, wie der Objekt Graph der Anwendung
 aufzulösen ist.
 Dem Nutzer des Containers muss es folglich ermöglicht werden, ihn zu konfigurie
ren: Er muss auswählen können, welche konkreten Implementationen einer Abstrakti
on 
\begin_inset Quotes gld
\end_inset

injiziert
\begin_inset Quotes grd
\end_inset

 werden sollen.
 Die 
\shape italic
Register
\shape default
-Methoden bilden diese Funktionalität ab.
\end_layout

\begin_layout Standard
Mit der Aufgabe der Erstellung von Objekten geht eine weitere Aufgabe einher:
 die Kontrolle über die Lebensdauer der Objekte.
 Der Container muss bestimmen, wann eine Instanz eines Objektes erstellt
 werden soll und wann diese nicht mehr gebraucht wird.
 Hierfür ist es für den Container wichtig den Sichtbarkeitsbereich (
\begin_inset Quotes gld
\end_inset

scope
\begin_inset Quotes grd
\end_inset

) eines Objektes zu kennen.
 Im 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework wird zwischen zwei unterschiedlichen Sichtbarkeitsbereichen unterschi
eden: Transient und Singleton.
\end_layout

\begin_layout Subsubsection
Register Transient
\end_layout

\begin_layout Standard
Wird eine Klasse beim Container mit dem Sichtbarkeitsbereich Transient registrie
rt, so wird dieser bei jeder Anfrage zur Auflösung eine neue Instanz des
 Typs liefern.
 Instanzen können somit unabhängig voneinander Zustand halten.
 Aus diesem Grund ist Transient die sicherste Variante der Sichtbarkeitsbereiche.
 Sollte es beispielsweise Zweifel an der Threadsicherheit einer Klasse geben,
 kann diese als Transient registriert werden.
 Die Möglichkeit Klassen als Transient zu registrieren, soll vom Container
 durch die Methode 
\shape italic
RegisterTransient
\shape default
 implementiert werden.
\end_layout

\begin_layout Subsubsection
Register Singleton
\end_layout

\begin_layout Standard
Im Gegensatz zu Transient wird bei dem Sichtbarkeitsbereich Singleton für
 jede Anfrage zur Auflösung eines Typs dieselbe Instanz geliefert.
 Zur Registrierung eines Objektes mit Singleton Sichtbarkeitsbereich soll
 die Methode 
\shape italic
RegisterSingleton
\shape default
 dienen.
 Genauso wie beim Singleton Entwurfsmuster kann die Instanz entweder 
\begin_inset Quotes gld
\end_inset

eager
\begin_inset Quotes grd
\end_inset

 oder 
\begin_inset Quotes gld
\end_inset

lazy
\begin_inset Quotes grd
\end_inset

 instanziiert werden.
 Erfolgt die Instanziierung direkt bei der Registrierung, ist diese 
\begin_inset Quotes gld
\end_inset

eager
\begin_inset Quotes grd
\end_inset

, erfolgt sie erst bei Injektion, ist sie 
\begin_inset Quotes gld
\end_inset

lazy
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
Der Singleton Sichtbarkeitsbereich sollte nicht mit dem Singleton Entwurfsmuster
 verwechselt werden: Ein Container liefert immer die selbe Instanz eines
 Typs, jedoch verwendet er im Gegensatz zum Singleton Entwurfsmuster hierzu
 keine statische Membervariable.
 Der Sichtbarkeitsbereich eines als Singleton registrierten Typs ist der
 des Containers an dem er registriert wurde.
 Durch die Definition von mehr als einem Composition Roots, ist es möglich
 mehrere Container zu verwenden.
 Somit ergibt sich auch die Möglichkeit, dass verschiedene Container eine
 unterschiedliche Instanz liefern.
\end_layout

\begin_layout Subsubsection
Resolve
\end_layout

\begin_layout Standard
Analog zu den 
\shape italic
Register
\shape default
-Methoden liefert die Methode 
\shape italic
Resolve
\shape default
 eine zuvor registrierte Instanz eines Typs.
 Mit dieser Instanz soll auch ihr gesamter Abhängigkeitsgraph instanziiert
 werden.
 In den meisten Fällen genügt ein einmaliger Aufruf der 
\shape italic
Resolve
\shape default
-Methode für das Root-Objekt des Object Graphs, um die komplette Anwendung
 zu initialisieren.
 
\end_layout

\begin_layout Subsubsection
Release
\end_layout

\begin_layout Standard
Üblicherweise gehört zu der Verwaltung der Lebensdauer eines Objekts zu
 entscheiden, was mit Objekten geschieht, die sich außerhalb des Sichtbarkeitsbe
reiches befinden.
 Mit dem Aufruf einer 
\shape italic
Release
\shape default
-Methode soll der Speicherbereich eines nicht mehr benötigten Objekts korrekt
 freigegeben werden.
 In .NET ist dies jedoch in den meisten Fällen nicht nötig, da ein Objekt,
 welches nicht mehr referenziert wird, vom Garbage-Collector aus dem Speicher
 entfernt wird.
 Aus diesem Grund wurde beim 
\begin_inset Quotes gld
\end_inset

Container
\begin_inset Quotes grd
\end_inset

-Framework auf die Implementation einer 
\shape italic
Release
\shape default
-Methode verzichtet.
 
\end_layout

\begin_layout Subsubsection
Das Interface des Containers
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void RegisterTransient<TInter, TClass>() where TClass : class, TInter;
\end_layout

\begin_layout Plain Layout

	void RegisterSingleton<TInter, TClass>(TClass instance = null) where TClass
 : class, TInter;
\end_layout

\begin_layout Plain Layout

	T Resolve<T>();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Minimales IContainer-Interface.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Minimales-IBinder-Interface"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Minimales IContainer-Interface
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aus den beschriebenen Aufgaben ergibt sich das in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Minimales-IBinder-Interface"

\end_inset

 gezeigte Interface des zu implementierenden Dependency Injection Containers.
 Im nächsten Abschnitt wird die konkrete Implementation der Klasse 
\shape italic
Container
\shape default
 beschrieben.
\end_layout

\begin_layout Subsection
Implementation des Containers
\end_layout

\begin_layout Standard
Die Implementation beginnt mit der Erstellung der Klasse 
\shape italic
Container
\shape default
, die das IContainer Interface implementiert.
 Um eine grundlegende Typregistrierung vornehmen zu können, müssen die Zuordnung
en abgespeichert werden.
\end_layout

\begin_layout Subsubsection
Registrieren und Speichern von Typzuordnungen
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Container : IContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, Type> transientMap = new Dictionary<Type,
 Type>();
\end_layout

\begin_layout Plain Layout

	private readonly IDictionary<Type, object> singletonMap = new Dictionary<Type,
 object>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterTransient<TInter, TClass>() where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		transientMap[typeof(TInter)] = typeof(TClass);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void RegisterSingleton<TInter, TClass>(TClass instance = null) where
 TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//Eager instantiation of singleton objects
\end_layout

\begin_layout Plain Layout

		if (instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			instance = (TClass)Instantiate(typeof(TClass));
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		singletonMap[typeof(TInter)] = instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation der Register-Methoden in Container.cs.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:RegisterMappings"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation der Register-Methoden in Container.cs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RegisterMappings"

\end_inset

 wird die Implementation der beiden 
\shape italic
Register
\shape default
-Methoden in 
\shape italic
Container.cs
\shape default
 gezeigt.
 Um die Registrierung abzuspeichern, werden zwei 
\shape italic
Dictionaries
\shape default
 als Datenstrukturen verwendet.
 Hierzu werden in beiden Methoden die Typen einer Abstraktion als Schlüssel
 verwendet.
 Der Unterschied zwischen Transient und Singleton besteht in der Speicherung
 der Datenwerte: Bei der Registrierung als Transient wird der Typ der konkreten
 Klasse als Wert in der 
\shape italic
transientMap
\shape default
 abgespeichert.
 Bei der Registrierung eines Singletons wird dahingegen eine konkrete Instanz
 der Klasse gespeichert.
 Diese Instanz kann als Parameter übergeben werden.
 Aus der Abbildung geht hervor, dass es nicht zwingend notwendig ist eine
 Instanz bereitzustellen.
 Für diesen Fall wurde sich dazu entschieden, direkt eine 
\begin_inset Quotes gld
\end_inset

eager Instantiation
\begin_inset Quotes grd
\end_inset

 vorzunehmen.
 Auf die Implementation der 
\shape italic
Instantiate
\shape default
-Methode wird zu einem späteren Zeitpunkt innerhalb dieses Abschnitts eingegange
n.
\end_layout

\begin_layout Subsubsection
Implementation der Resolve-Methode
\end_layout

\begin_layout Standard
Wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Resolve"

\end_inset

 zu sehen ist, delegiert die generische 
\shape italic
Resolve
\shape default
-Methode ihren Aufruf an eine nicht-generische Version.
 Diese prüft zunächst, ob eine Instanz in der Singleton-Registrierung vorliegt.
 Bei Vorhandensein wird diese zurückgegeben.
 Ist der Typ jedoch als Transient registriert, wird eine neue Instanz des
 in der 
\shape italic
transientMap
\shape default
 registrierten, konkreten Typs erstellt und zurückgegeben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public T Resolve<T>()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = typeof(T);
\end_layout

\begin_layout Plain Layout

	return (T)Resolve(type);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private object Resolve(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (singletonMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = singletonMap[type];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else if (transientMap.ContainsKey(type))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		instance = Instantiate(transientMap[type]);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		throw new Exception("Couldn't resolve binding for " + type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation der Resolve-Methode.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Resolve"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation der Resolve-Methode
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Instanziieren von Klassen basierend auf Typinformationen
\begin_inset CommandInset label
LatexCommand label
name "sub:Instanziieren-von-Klassen"

\end_inset


\end_layout

\begin_layout Standard
Die tatsächliche Erstellung von Objekten übernimmt die in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Instantiate-Methode"

\end_inset

 gezeigte 
\shape italic
Instantiate
\shape default
-Methode der Klasse 
\shape italic
Container
\shape default
.
 Unter Vorgabe eines konkreten Typs wird eine Instanz dieses Typs geliefert.
 Die Methode delegiert diese Verantwortung an eine Methode namens 
\shape italic
CreateInstance
\shape default
 der Klasse 
\shape italic
Activator
\shape default
.
 Es sind hierfür noch weitere Informationen über die Klasse notwendig.
 Dies ist zum einen der zu verwendende Konstruktor der Klasse mitsamt seinen
 Parametern und zum Anderen Properties, in die Abhängigkeiten injiziert
 werden sollen.
 Über die 
\shape italic
GetConstructor
\shape default
-Methode erhält der Container Informationen über den Konstruktor, den er
 zur Erstellung des Objektes nutzen soll.
 Dieser kann vom Nutzer des Frameworks spezifiziert werden.
 Um den Ablauf genauer beschreiben zu können, ist es Voraussetzung zwei
 Sprachfeatures von C#, die diese Funktionalität ermöglichen, vorzustellen:
 Attributes und Reflection.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object Instantiate(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	object instance;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	var constructor = GetConstructor(type);
\end_layout

\begin_layout Plain Layout

	if (constructor != null)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var paramInfos = constructor.GetParameters();
\end_layout

\begin_layout Plain Layout

		var paramInstances = ResolveParameters(paramInfos);
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type, paramInstances);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//No constructor defined, use the default constructor
\end_layout

\begin_layout Plain Layout

		instance = Activator.CreateInstance(type);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	InjectProperties(instance);
\end_layout

\begin_layout Plain Layout

	return instance;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Instantiate-Methode in Container.cs.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Instantiate-Methode"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Instantiate-Methode in Container.cs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attributes
\end_layout

\begin_layout Standard
Mittels Attributes lassen sich Metadaten für Programmcodeelemente definieren.
 Diese Metadaten sind Informationen, die von der Anwendung zur Laufzeit
 ausgewertet werden können.
 Es können praktisch alle Elemente des Programmcodes mit Metadaten versehen
 werden: Assemblys, Klassen, Methoden, Eigenschaften usw.
 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Msdn2015:Attributes"

\end_inset

.
 Ein Beispiel hierfür ist das bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Referenzieren"

\end_inset

 gezeigte 
\shape italic
SerializeField
\shape default
-Attribut.
 Die Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendung-Attribute"

\end_inset

 zeigt eine Membervariable, welcher das 
\shape italic
SerializeField
\shape default
-Attribut zugewiesen wurde.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\begin_layout Plain Layout

private Text sampleWithAttribute;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für die Verwendung eines Attributes.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendung-Attribute"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel für die Verwendung eines Attributes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für den Inversion Of Control Container sind zwei Metadaten einer Klasse
 relevant: Ihm muss bekannt sein, welcher Konstruktor zur Instanziierung
 eines Objektes verwendet werden soll und in welche Properties Abhängigkeiten
 injiziert werden sollen.
 Es ist ausreichend ein einziges benutzerdefiniertes Attribut zu erstellen,
 um beide Funktionalitäten abzubilden: Bei der späteren Auswertung des Attributs
 kann geprüft werden, ob sich dieses an einem Konstruktor oder einem Property
 befindet und dementsprechend gehandelt werden.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Definition-des-Inject-Attributs"

\end_inset

 wird die Erstellung des hierfür vorgesehenen 
\shape italic
InjectAttribute
\shape default
-Attributes dargestellt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Constructor)]
\end_layout

\begin_layout Plain Layout

public class InjectAttribute : Attribute
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Definition des Inject-Attributs.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Definition-des-Inject-Attributs"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Definition des Inject-Attributs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird zunächst eine Klasse definiert, die von der Klasse 
\shape italic
Attribute
\shape default
 ableitet.
 Um die Gültigkeit des Attributs festzulegen, wird die Klasse selbst mit
 einem 
\shape italic
AttributeUsage
\shape default
-Attribut gekennzeichnet.
 Im Fall des 
\shape italic
Inject
\shape default
-Attributs wird die Gültigkeit auf Properties und Konstruktoren beschränkt.
 Bei der Verwendung entspricht der Attributname dem Klassennamen des Attributs
 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Msdn2015:Type"

\end_inset

.
 Die Endung Attribute kann weggelassen werden.
 Aus Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Verwendungmöglichkeiten"

\end_inset

 können die gültigen Verwendungsmöglichkeiten des 
\shape italic
InjectAttribute
\shape default
-Attributs entnommen werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleClass
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//Alternativ [InjectAttribute]
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public ISomeProperty property { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleClass(ISomeDependency first, IAnotherDependency second)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendungsmöglichkeiten des Inject-Attributes.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Verwendungmöglichkeiten"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Verwendungsmöglichkeiten des Inject-Attributes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reflection
\end_layout

\begin_layout Standard
Der Zugriff auf die mit dem 
\shape italic
Inject
\shape default
-Attribut gekennzeichneten Attribute erfolgt mittels Reflection.
 Reflection ermöglicht das Auslesen und Auswerten von Metadaten eines Assemblys
 oder Typs zur Laufzeit.
 Metadaten werden über die 
\shape italic
System.Type
\shape default
-Klasse abgebildet 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Msdn2015:Reflection"

\end_inset

.
 Diese Klasse wurde bereits an einigen Stellen zur Implementation des Containers
 verwendet.
 Es wurde also genau genommen bereits Reflection eingesetzt.
 
\end_layout

\begin_layout Standard
Bei der Implementation des Containers wird an zwei Stellen Zugriff auf die
 Typinformationen des zu instanziierenden Objekts benötigt: Als Erstes muss
 mittels Reflection herausgefunden werden, welcher Konstruktor zur Instanziierun
g genutzt werden soll.
 Diese Funktionalität wird von der Methode 
\shape italic
GetConstructor
\shape default
 in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Zugriff-auf-Typinformationen"

\end_inset

 implementiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private ConstructorInfo GetConstructor(Type type)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var constructors = type.GetConstructors();
\end_layout

\begin_layout Plain Layout

	ConstructorInfo constructor;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (constructors.Length == 1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors[0];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		constructor = constructors.Single(x => Attribute.IsDefined(x, typeof(InjectAttri
bute)));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return constructor;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zugriff auf Typinformationen mittels Reflektion in der Methode GetConstructor.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Zugriff-auf-Typinformationen"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Zugriff auf Typinformationen mittels Reflektion
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methode 
\shape italic
GetConstructors
\shape default
 der Klasse 
\shape italic
Type
\shape default
 liefert Informationen zu allen definierten Konstruktoren einer Klasse.
 Um den gewünschten, mit dem 
\shape italic
Inject
\shape default
-Attribut gekennzeichneten Konstruktor zu erhalten, wird über die vorhandenen
 Konstruktoren iteriert und dieser mithilfe der statischen Methode 
\shape italic
IsDefined
\shape default
 der Klasse 
\shape italic
Attribute
\shape default
 identifiziert.
 Existiert nur ein einziger Konstruktor für einen Typ, muss dieser nicht
 explizit mit dem 
\shape italic
Inject
\shape default
-Attribut gekennzeichnet werden, um vom Container zu Instanziierung genutzt
 zu werden.
\end_layout

\begin_layout Standard
Betrachtet man die 
\shape italic
Instantiate
\shape default
-Methode in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Instantiate-Methode"

\end_inset

 ein weiteres Mal, stellt man fest, dass bevor die tatsächliche Instanziierung
 über den Konstruktor vorgenommen wird, zunächst alle Parameter instanziiert
 werden müssen.
 Diese Aufgabe übernimmt die Methode 
\shape italic
ResolveParameters
\shape default
 in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Auflösen-Konstruktorparameter"

\end_inset

.
 Es wird über die Parameterinformationen des Konstruktors iteriert und alle
 Parameter der Reihe nach instanziiert.
 Dies geschieht über einen rekursiven Aufruf der 
\shape italic
Resolve
\shape default
-Methode.
 Somit ist es Voraussetzung, dass alle Typen der Konstruktorparameter zuvor
 bei dem Container registriert wurden.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private object[] ResolveParameters(ParameterInfo[] parameterInfos)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var parameters = new object[parameterInfos.Length];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < parameters.Length; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var parameterInfo = parameterInfos[i];
\end_layout

\begin_layout Plain Layout

		parameters[i] = Resolve(parameterInfo.ParameterType);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return parameters;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen der Konstruktorparameter durch die ResolveParameters-Methode.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-Konstruktorparameter"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Auflösen von Konstruktorparametern durch ResolveParameters-Methode
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nach der Instanziierung eines Typs ist es notwendig, die Klasse mit Abhängigkeit
en, die in Form von Properties vorliegen, zu versorgen.
 Die Methode 
\shape italic
InjectProperties
\shape default
, gezeigt in der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Auflösen-von-Properties"

\end_inset

, bildet diese Funktionalität des Containers ab.
 Es werden Informationen zu Properties mit dem 
\shape italic
Inject
\shape default
-Attribut über die Methode 
\shape italic
GetProperties
\shape default
 der Klasse 
\shape italic
Type
\shape default
 geliefert.
 Im nächsten Schritt wird über die 
\shape italic
PropertyInfos
\shape default
 iteriert und mittels Aufruf der 
\shape italic
Resolve
\shape default
-Methode eine Instanz des Properties geholt.
 Diese Instanz wird danach dem Property des Objektes mithilfe 
\shape italic
SetValue
\shape default
-Methode zugewiesen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void InjectProperties(object instance)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var type = instance.GetType();
\end_layout

\begin_layout Plain Layout

	var propertyInfos = type.GetProperties().Where(prop => Attribute.IsDefined(prop,
 typeof(InjectAttribute))).GetEnumerator();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (propertyInfos.MoveNext())
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var propertyInfo = propertyInfos.Current;
\end_layout

\begin_layout Plain Layout

		var propertyInstance = Resolve(propertyInfo.PropertyType);
\end_layout

\begin_layout Plain Layout

		propertyInfo.SetValue(instance, propertyInstance, null);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Auflösen von Properties durch die InjectProperties-Methode.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Auflösen-von-Properties"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Auflösen von Properties durch die InjectProperties-Methode
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit ist die grundlegende Implementation des Containers abgeschlossen.
 Zur optimalen Zusammenarbeit mit Unity3D sollten jedoch noch einige Erweiterung
en vorgenommen werden.
 Diese Erweiterungen werden im folgenden Abschnitt beschrieben.
\end_layout

\begin_layout Subsection
Erweiterungen des Containers für die Zusammenarbeit mit Unity3D
\end_layout

\begin_layout Standard
Damit bessere Zusammenarbeit des Containers mit Unity3D gewährleistet werden
 kann, sollten noch einige Erweiterungen an diesem vorgenommen werden.
 Es gibt beispielsweise derzeit keine Möglichkeit Abhängigkeiten in MonoBehaviou
rs zu injizieren.
 Die Umsetzungen dieser Erweiterungen werden in diesem Abschnitt präsentiert.
 Es wird verdeutlicht, wo Hürden und Einschränkungen bei der Umsetzung von
 Dependency Injection in Unity3D vorhanden sind.
\end_layout

\begin_layout Subsubsection
Injecting into MonoBehaviours
\end_layout

\begin_layout Standard
Wie bereits in den vorigen Abschnitten festgestellt, übernimmt Unity3D selbst
 die Verantwortung über die Erstellung von MonoBehaviours.
 Es existiert folglich kein Konstruktor über den Abhängigkeiten aufgelöst
 werden können.
 Es muss sich auf Property Injection beschränkt werden.
 Dabei ist zu berücksichtigen, dass MonoBehaviours bereits in der Szene
 existieren, bevor die 
\shape italic
Awake
\shape default
-Methode des Composition Roots aufgerufen wird.
 Des Weiteren können GameObjects und MonoBehaviours auch zur Laufzeit instanziie
rt werden.
 In beiden Fällen muss es ermöglicht werden, dass diese ihre Abhängigkeiten
 erhalten.
 Im Folgenden sollen drei Ansätze hierfür erläutert werden: das Verwenden
 des Containers als Service Locator, Factories und ExecuteEvents als MonoBehavio
ur-Extension.
\end_layout

\begin_layout Subsubsection
Service Locator
\end_layout

\begin_layout Standard
Eine mögliche Lösung für das Problem ist die Verwendung des Containers als
 Service Locator.
 Bei einem Service Locator handelt es sich um einen statischen Wrapper für
 den Container.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Service-Locator"

\end_inset

 zeigt eine mögliche Implementation des Service Locator Patterns unter Verwendun
g der 
\shape italic
Container
\shape default
-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class ServiceLocator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private static readonly IContainer container = new Container();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterTransient<TInter, TClass>() where TClass : class,
 TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container.RegisterTransient<TInter, TClass>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static void RegisterSingleton<TInter, TClass>(TClass instance =
 null) where TClass : class, TInter
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container.RegisterSingleton<TInter, TClass>(instance);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public static T Resolve<T>()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return container.Resolve<T>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Service Locators.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Service-Locator"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation des Service Locators
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Konfiguration des Service Locators würde, wie die des Containers, in
 der zuvor definierten 
\shape italic
CompositionRoot
\shape default
-Klasse stattfinden.
 Der Unterschied zwischen einem Service Locator und einem Inversion Of Control
 Frameworks liegt nicht in der Implementation, sondern in der Verwendung.
 Die Verwendung der 
\shape italic
Resolve
\shape default
-Methode des Containers beschränkt sich üblicherweise auf einen einzigen
 Aufruf im Composition Root und setzt somit die rekursive Auflösung des
 gesamten Object Graphs in Gang.
 Wird ein Service Locator verwendet, können Abhängigkeiten von überall im
 Programm durch Aufruf der 
\shape italic
Resolve
\shape default
-Methode angefordert werden.
 MonoBehaviours würden also in der 
\shape italic
Awake
\shape default
-Methode durch Anfrage beim Service Locator ihre Abhängigkeiten erhalten.
 
\end_layout

\begin_layout Standard
Auf den ersten Blick scheinen keine Vorteile bei der Verwendung des Service
 Locators verloren zu gehen: Abhängigkeiten sind lose gekoppelt, die Programmier
ung im Parallelen ist gewährleistet und Testbarkeit ist durch Konfiguration
 des Service Locators in der Testumgebung möglich.
 Trotzdem wird der Service Locator oft als Anti-Pattern angesehen.
 Klassen haben eine unnötige konkrete Abhängigkeit an den Service Locator.
 Die Klasse wird explizit für eine Verwendung mit dem Service Locator implementi
ert.
 Von außen ist es nicht sichtbar, dass die Klasse andere Abhängigkeiten
 hat.
 Es kann keine Aussage darüber getroffen werden, welche Abhängigkeiten notwendig
 sind, damit eine Klasse funktioniert.
 
\end_layout

\begin_layout Standard
Jedoch ermöglicht der Service Locator die Auflösung von Abhängigkeiten eines
 MonoBehaviours.
 Die Verwendung des Service Locators kann auf MonoBehaviours reduziert werden
 und in diesem Fall als notwendig angesehen werden.
 Das Problem ist jedoch, dass der Service Locator, aufgrund der globalen
 Sichtbarkeit als statische Klasse, von unwissenden Programmierern auch
 in anderen Bereichen genutzt werden kann.
 Im folgenden sollen zwei weitere Möglichkeiten vorgestellt werden, mit
 denen sich Abhängigkeiten eines MonoBehaviours auflösen lassen.
 Alle haben ihre Vor- und Nachteile.
 Der Service Locator ist die einfachste, aber zugleich auch die am wenigsten
 elegante Lösung des Problems.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes gld
\end_inset

Inject
\begin_inset Quotes grd
\end_inset

-Event als MonoBehaviour-Extension
\end_layout

\begin_layout Standard
Die Grundidee einer anderen Methode ist, dem Container über ein Event bescheid
 zu geben, dass ein MonoBehaviour in der Szene erstellt wurde und dessen
 Abhängigkeiten aufgelöst werden müssen.
 Hierzu wird die Klasse MonoBehaviour mit der in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Erweiterungsmethode"

\end_inset

 gezeigten Extension erweitert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class MonoInjectionExtension
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Inject(this MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.ExecuteHierarchy<IMonoInjectionHandler>
\end_layout

\begin_layout Plain Layout

			(script.gameObject, null, (target, data) => target.InjectDependencies(script));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Erweiterungsmethode für MonoBehaviours.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Erweiterungsmethode"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Erweiterungsmethode für MonoBehaviours
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mittels der 
\shape italic
ExecuteHierarchy
\shape default
-Methode der Klasse 
\shape italic
ExecuteEvents
\shape default
 wird ein Event in der Hierarchie nach oben gesendet.
 Das Event soll vom Composition Root entgegengenommen werden, damit dieser
 die Auflösung der Abhängigkeiten an den Container delegieren kann.
 Dazu muss 
\shape italic
CompositionRoot
\shape default
 das für diesen Fall erstellte 
\shape italic
IMonoInjectionHandler-
\shape default
Interface implementieren.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IMonoInjectionHandler"

\end_inset

 zeigt das Interface 
\shape italic
IMonoInjectionHandler
\shape default
 und dessen Implementation vom Composition Root.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IMonoInjectionHandler : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void InjectDependencies(MonoBehaviour script);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public abstract class CompositionRoot : IMonoInjectionHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void InjectDependencies(MonoBehaviour script)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation von IMonoInjectionHandler.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:IMonoInjectionHandler"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation von IMonoInjectionHandler
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei dieser Methode ist zu beachten, dass alle Spielobjekte im Szenengraph
 Children des Composition Roots sein müssen.
 Jedes MonoBehaviour muss im 
\shape italic
Start
\shape default
-Event explizit die 
\shape italic
Inject
\shape default
-Erweiterungsmethode aufrufen, damit die Abhängigkeiten vom Container aufgelöst
 werden.
 Dies könnte bereits im 
\shape italic
Awake
\shape default
-Event geschehen, da durch das Festlegen der Script Execution Order in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definieren-des-Composition"

\end_inset

 gewährleistet wird, dass der Composition Root den Container bereits initialisie
rt hat.
 Instanziiert man jedoch ein Spielobjekt zur Laufzeit, so muss der Composition
 Root unmittelbar darauf als Parentelement festgelegt werden.
 Es ist nicht möglich ein Spielobjekt direkt als Child eines anderen Spielobjekt
s zu instanziieren.
 Zum Zeitpunkt des Aufrufs der 
\shape italic
Awake
\shape default
-Methode hat noch kein parenting stattgefunden, auch wenn dies unmittelbar
 nach Instanziierung geschieht.
 Demzufolge sollte die 
\shape italic
Inject
\shape default
-Methode im 
\shape italic
Start-
\shape default
Event des MonoBehaviours aufgerufen werden.
\end_layout

\begin_layout Standard
Bei Verwendung der beschriebenen Methode ist es nötig, dass der Nutzer des
 Containers sich strikt an die beschriebenen Anweisungen hält.
 Ein Aufruf der 
\shape italic
Inject
\shape default
-Methode muss im 
\shape italic
Start
\shape default
-Event erfolgen, da ansonsten keine Abhängigkeiten injiziert werden.
 Alle Spielobjekte müssen Children des Composition Roots sein.
 Nachfolgend soll eine letzte Möglichkeit vorgestellt werden, die dem Nutzer
 weniger Verantwortung abverlangt.
\end_layout

\begin_layout Subsubsection
Auflösung des Szenegraphs und Factories
\end_layout

\begin_layout Standard
Bei dieser Methode wird die Auflösung von Abhängigkeiten von MonoBehaviours
 in zwei Teile unterteilt.
 Durch den ersten Teil werden bereits in der Szene existierende MonoBehaviours
 mit ihren Abhängigkeiten versorgt.
 Dies wird bewerkstelligt indem dem Composition Root die 
\shape italic
ResolveScene
\shape default
-Methode hinzugefügt wird.
 Diese Methode wird im 
\shape italic
Awake
\shape default
-Event unmittelbar nach der Konfiguration des Containers aufgerufen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ResolveScene"

\end_inset

 zeigt die Änderungen an der 
\shape italic
CompositionRoot
\shape default
-Klasse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		container = new Binder();
\end_layout

\begin_layout Plain Layout

		SetupBindings();
\end_layout

\begin_layout Plain Layout

		ResolveScene();
\end_layout

\begin_layout Plain Layout

		Init();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void ResolveScene()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		foreach (var script in Object.FindObjectsOfType(typeof(MonoBehaviour)))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			container.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzugefügte ResolveScene-Methode in CompositionRoot.cs.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:ResolveScene"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Hinzugefügte ResolveScene-Methode in CompositionRoot.cs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um die Abhängigkeiten der existierenden MonoBehaviours aufzulösen, wird
 über alle MonoBehaviours in der Szene iteriert und dem Container mitgeteilt
 alle Properties zu instanziieren.
 Durch das Festlegen der Script Execution Order in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

, wird gewährleistet, dass alle sich in der Szene befindenden MonoBehaviours
 ihre Abhängigkeiten bereits vor dem Aufruf der 
\shape italic
Awake
\shape default
-Methode erhalten haben.
\end_layout

\begin_layout Standard
Weiter muss der Fall berücksichtigt werden, dass Spielobjekte dynamisch
 zur Laufzeit instanziiert werden können.
 Unmittelbar nach der Instanziierung müssen die Abhängigkeiten aller MonoBehavio
urs des Spielobjektes vom Container aufgelöst werden.
 Damit dies sichergestellt ist und an einem zentralen Ort geschieht, soll
 hierfür eine Factory implementiert werden.
 Über diese Factory sollen alle Spielobjekte zur Laufzeit erstellt werden.
 Das heißt, dass es im Programmcode keine weiteren Aufrufe der 
\shape italic
Instantiate
\shape default
-Methode der Klasse 
\shape italic
Object
\shape default
 geben darf.
 Der einzige Aufruf der Instantiate-Methode findet in der 
\shape italic
Create
\shape default
-Methode der 
\shape italic
GameObjectFactory
\shape default
-Klasse wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GameObjectFactory"

\end_inset

 dargestellt, statt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GameObjectFactory : IGameObjectFactory
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public GameObject Create(GameObject original)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var instance = Object.Instantiate(original);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		foreach (var script in instance.GetComponents<MonoBehaviour>())
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			binder.InjectProperties(script);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		return instance;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausschnitt GameObjectFactory.cs.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:GameObjectFactory"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Ausschnitt GameObjectFactory.cs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Direkt nach dem Instanziieren werden die Properties aller MonoBehaviours
 vom Container instanziiert.
 Es ist sichergestellt, dass MonoBehaviours zum Start-Event über alle Abhängigke
iten verfügen.
 Die 
\shape italic
GameObjectFactory-Klasse
\shape default
 bietet eine weitere Überladung der 
\shape italic
Create
\shape default
-Methode.
 Aus Platzgründen wurde diese hier ausgelassen.
 Mit ihr lassen sich Prefabs anhand ihres Namens im Resource-Ordner instanziiere
n.
 Spielobjekte, die aus dem Resource-Ordner geladen wurden, werden in einem
 Cache zwischengespeichert.
 
\end_layout

\begin_layout Standard
Bei Verwendung dieser Methode muss der Nutzer des Containers Frameworks
 keine frameworkspezifischen Operationen innerhalb eines MonoBehaviours
 vornehmen.
 Dem Nutzer muss lediglich bewusst sein, dass er die Klasse 
\shape italic
GameObjectFactory
\shape default
 zur Instanziierung von Spielobjekten zur Laufzeit verwenden muss.
 Es ist nicht nötig, dass Spielobjekte Children des Composition Roots sind,
 um ihre Abhängigkeiten zu erhalten.
 Aus diesem Grund ist aus Sicht des Autors der vorliegenden Arbeit diese
 Methode den anderen vorzuziehen.
\end_layout

\begin_layout Subsubsection
Injecting MonoBehaviours
\end_layout

\begin_layout Standard
Alle bis jetzt gezeigten Methoden beschreiben, wie Abhängigkeiten in MonoBehavio
urs injiziert werden können.
 An dieser Stelle soll beschrieben werden, wie mit Abhängigkeiten zu anderen
 MonoBehaviours umgegangen werden soll.
 Zunächst sollte überprüft werden, ob es tatsächlich notwendig ist, dass
 die benötigte Abhängigkeit von MonoBehaviour erbt.
 Durch strikte Trennung der Belange (
\begin_inset Quotes gld
\end_inset

Seperation Of Concerns
\begin_inset Quotes grd
\end_inset

) kann dies meist auf die Darstellungslogik reduziert werden.
 Die benötigten Komponenten sind meist Unity-Eigene Klassen wie 
\shape italic
Button
\shape default
, 
\shape italic
Label
\shape default
 oder 
\shape italic
RigidBody
\shape default
 am selben Spielobjekt.
 In diesen Fällen können sie mithilfe des
\shape italic
 SerializeField
\shape default
-Attributs im Editor gesetzt werden.
 
\end_layout

\begin_layout Standard
Liegen dennoch Gründe vor, dass eine Abhängigkeit zu einem MonoBehaviour
 benötigt wird, könnte dieses theoretisch beim Container registriert werden.
 Vorausgesetzt es implementiert ein Interface, welches die benötigte Funktionali
tät abbildet.
 Das Spielobjekt des MonoBehaviours kann mittels 
\shape italic
Find
\shape default
-Methode vom Composition Root aus ausfindig gemacht und im Anschluss beim
 Container registriert werden.
 Die Registration ist somit jedoch auf eine einzige Instanz eines Typs beschränk
t.
 Hiervon wird jedoch ausdrücklich abgeraten.
 Anhand eines Beispiels soll im Folgenden ein alternativer Ansatz beschrieben
 werden.
\end_layout

\begin_layout Standard
Die Idee dieses Ansatzes ist, nicht ein MonoBehaviour, sondern einen Wrapper
 für dieses beim Container zu registrieren.
 Eine Funktionalität eines MonoBehaviours, welche auch ausserhalb von diesem
 benötigt werden könnte, ist das Ausführen von Coroutines 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Unity2015:StartCoroutine"

\end_inset

.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 zeigt die Verwendung dieses Ansatzes bei der Umsetzung der gewünschten
 Funktionalität, Coroutines auszuführen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunnerBehaviour : MonoBehaviour, ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Awake()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		DontDestroyOnLoad(transform.gameObject);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class CoroutineRunner : ICoroutineRunner
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly IGameObjectFactory gameObjectFactory;
\end_layout

\begin_layout Plain Layout

	private readonly ICoroutineRunner coroutineRunnerBehaviour;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public CoroutineRunner(IGameObjectFactory gameObjectFactory)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.gameObjectFactory = gameObjectFactory;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var go = this.gameObjectFactory.Create("CoroutineRunnerPrefab");
\end_layout

\begin_layout Plain Layout

		coroutineRunnerBehaviour = go.GetComponent<ICoroutineRunner>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Coroutine StartCoroutine(IEnumerator routine)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return coroutineRunnerBehaviour.StartCoroutine(routine);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des CoroutineRunners.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-des-Coroutine"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Implementation des CoroutineRunners
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die benötigte Funktionalität wird zunächst durch die 
\shape italic
ICoroutineRunner-
\shape default
Schnittstelle definiert.
 Die Implementation erfolgt von der Klasse 
\shape italic
CoroutineRunnerBehaviour,
\shape default
 indem sie von 
\shape italic
MonoBehaviour
\shape default
 erbt.
 Weiter wird die Schnittstelle auch von der Klasse 
\shape italic
CoroutineRunner
\shape default
 implementiert.
 Im Konstruktor erstellt sie, durch den Aufruf der 
\shape italic
Create
\shape default
-Methode der 
\shape italic
GameObjectFactory
\shape default
 ein Prefab, welches die 
\shape italic
CoroutineRunnerBehaviour
\shape default
-Komponente besitzt.
 Den Aufruf der 
\shape italic
StartCoroutine
\shape default
-Methode delegiert die Klasse an diese 
\shape italic
CoroutineRunnerBehaviour
\shape default
-Komponente.
 Die Klasse 
\shape italic
CoroutineRunner
\shape default
 kann ohne Weiteres im Composition Root beim Container registriert werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

container.RegisterTransient<ICoroutineRunner, CoroutineRunner>();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sie kann nun in alle anderen Module injiziert und genutzt werden.
 Damit ist eine grundlegende Zusammenarbeit zwischen Unity3D und dem Inversion
 Of Control Container gewährleistet.
 Um die gezeigten Beispiele auf das Wesentliche zu reduzieren, wurde auf
 die Darstellung und Implementierung einiger Funktionalitäten verzichtet.
 Diese sollen jedoch im folgenden Abschnitt kurz Erwähnung finden.
\end_layout

\begin_layout Subsection
Weitere Ansatzpunkte zur Erweiterung
\end_layout

\begin_layout Standard
Bei der dargestellten Implementierung des Inversion Of Control Containers
 handelt es sich um ein 
\begin_inset Quotes gld
\end_inset

Proof Of Concept
\begin_inset Quotes grd
\end_inset

.
 Die Funktionsweise, sowie nötige Sprachfeatures sollten beschrieben und
 eine Zusammenarbeit mit Unity3D gewährleistet werden.
 Auf eine ausführliche Beschreibung aller Details wurde verzichtet.
 So wird beispielsweise das 
\begin_inset Quotes gld
\end_inset

eager
\begin_inset Quotes grd
\end_inset

- und 
\begin_inset Quotes gld
\end_inset

lazy-loading
\begin_inset Quotes grd
\end_inset

 von Singletons der tatsächlichen Implementierung unterstützt.
 Die Implementation ist auf der beigelegten CD zu dieser Arbeit zu finden.
\end_layout

\begin_layout Standard
Überdies gibt es zahlreiche Ansatzpunkte zur Erweiterung des Frameworks:
\end_layout

\begin_layout Itemize
Die Verwendung von Reflection führt zu starken Performanceeinbußen.
 Obwohl sich die Aufrufe der Reflection-Bibliotheken zum Großteil auf den
 Programmstart beschränken, sollten diese reduziert werden.
 Die Ergebnisse der Reflection eines Typs sollten gecached und vom Container
 wiederverwendet werden.
\end_layout

\begin_layout Itemize
Das Verhalten bei zirkulären Abhängigkeiten ist nicht bestimmt.
 Im besten Fall sollten diese gar nicht erst zugelassen werden.
 Es sollte eine Ausnahme zur Laufzeit geworfen werden.
\end_layout

\begin_layout Itemize
Die API zur Konfiguration/Registrierung des Containers kann verbessert und
 erweitert werden.
 Es können 
\begin_inset Quotes gld
\end_inset

fluent interfaces
\begin_inset Quotes grd
\end_inset

 zur Erstellung einer domänenspezifischen Sprache verwendet werden.
 Eine weitere Konfigurationsmöglichkeit könnte über JSON oder XML geboten
 werden.
 Der Vorteil einer solchen externen Konfiguration ist, dass das Verhalten
 der Anwendung ohne erneuter Kompilierung geändert werden kann.
\end_layout

\begin_layout Itemize
Bis jetzt wurde die Verwendung des Containers auf eine einzige Szene beschränkt.
 Auf das Verhalten bei der Arbeit mit mehreren Szenen wurde nicht eingegangen.
 Jede Szene könnte einen eigenen Composition Root haben, welcher die nötigen
 Abhängigkeiten der Szenen individuell auflöst.
 Alternativ könnte ein einziger Container in der 
\begin_inset Quotes gld
\end_inset

Haupt
\begin_inset Quotes grd
\end_inset

-Szene die Abhängigkeiten in allen Szenen auflösen.
 Dies ist sinnvoll, wenn alle Szenen gleiche Abhängigkeiten haben.
 Werden Szenen additiv geladen, wäre auch die Erstellung einer Containerhierarch
ie eine Möglichkeit.
 Beim Root-Container werden Abhängigkeiten, die über mehrere Szenen hinweg
 benötigt werden registriert, während Child-Container spezifische Abhängigkeiten
 der additiv geladenen Szene auflösen.
\end_layout

\begin_layout Itemize
Der Container sollte für eine ordnungsgemäße Entsorgung von Objekten sorgen.
 Im Speziellen sollte sichergestellt werden, dass die 
\shape italic
Dispose
\shape default
-Methode von Klassen die 
\shape italic
IDisposable
\shape default
 implementieren aufgerufen wird.
\end_layout

\begin_layout Itemize
Es ist derzeit nicht möglich, Logik unmittelbar nach der Injection auszuführen.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-des-Coroutine"

\end_inset

 wird diese Beschränkung umgangen, indem weitere Logik im Konstruktor ausgeführt
 wird.
 Die Gefahr hierbei ist jedoch, dass Properties zu diesem Zeitpunkt noch
 nicht inijziert wurden.
 Desweiteren sollte das Single Responsibility Principle gewahrt werden,
 indem im Konstruktor lediglich Initialisierungslogik ausgeführt wird.
 Aus diesem Grund sollte ein weiteres Attribut namens 
\shape italic
PostConstruct
\shape default
 vorgestellt werden: Methoden, die mit dem 
\shape italic
PostConstruct
\shape default
-Attribut versehen wurden, sollen unmittelbar nach dem Injection-Prozess
 vom Container aufgerufen werden.
\end_layout

\begin_layout Standard
Aus diesen Gründen wird von dem Autor dieser Arbeit davon abgeraten, den
 präsentierten Container zur Entwicklung eines Spiels zu verwenden.
 In dem folgenden Abschnitt sollen ausgereiftere Inversion Of Control Frameworks
 für Unity3D vorgestellt und auf ihre Tauglichkeit bei der Entwicklung von
 Spielen untersucht werden.
\end_layout

\begin_layout Section
Übersicht Inversion Of Control Frameworks für Unity3D
\end_layout

\begin_layout Standard
In den vorherigen Abschnitten dieser Arbeit wurden Prinzipien, Praktiken
 und Funktionsweise von Dependency Injection und Inversion Of Control Containern
 beschrieben.
 Dieser Abschnitt soll eine Übersicht über die für Unity3D verfügbaren Inversion
 Of Control Container geben.
 Ihre Funktionsumfänge und Besonderheiten sollen beschrieben werden.
 Oft bieten diese Frameworks Funktionalitäten, die weit über automated Dependenc
y Injection hinausgehen.
\end_layout

\begin_layout Standard
Die vorzustellenden Container wurden speziell für die Verwendung mit Unity3D
 entwickelt.
 Ein Grund hierfür ist, dass - wie im vorherigen Abschnitt ausführlich beschrieb
en - einige Erweiterungen notwendig sind, um die Verwendung eines Containers
 in Unity3D zu ermöglichen.
 Ein weiterer Grund ist, dass Unitys Mono Laufzeitumgebung lediglich Kompatibili
tät zum .NET Framework 3.5 aufweist.
 Die meisten existierenden Inversion Of Control Container für .NET verwenden
 .NET 4.0 oder höher.
 
\end_layout

\begin_layout Standard
Das Grundkonzept für die Implementation eines Inversion Of Control Containers
 für Unity3D lieferte Sebastiano Mandalà im September 2012 in einer Serie
 von Blogeinträgen.
 Auf dieser Basis haben sich mit der Zeit eine Reihe von Frameworks entwickelt.
 Im Folgenden sollen die Frameworks Zenject, adic und StrangeIoC vorgestellt
 werden 
\begin_inset CommandInset citation
LatexCommand citep
before "siehe"
key "Mandala2012"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Zenject
\end_layout

\begin_layout Standard
Zenject ist ein Dependency Injection Container, der sich aus einem direkten
 Fork des Konzepts von Sebastiano Mandalà entwickelt hat.
 Zusätzlich zu den grundlegenden Funktionalitäten eines Dependency Injection
 Containers bietet das Framework eine Vielzahl von Registrierungsoptionen,
 wie zum Beispiel die Registrierung von Prefabs und GameObjects oder Injection
 in spezifische Methoden und Getter.
 Darüber hinaus bietet das Framework eine Möglichkeit zur Validierung und
 Visualisierung des Object Graphs: Es kann überprüft werden, dass alle zu
 injizierenden Typen im Object Graph einer Szene beim Container registriert
 sind.
 Es ist möglich, eine an UML angelegte graphische Darstellung des Object
 Graphs der Anwendung zu generieren 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Zenject2015"

\end_inset

.
\end_layout

\begin_layout Subsubsection
adic
\end_layout

\begin_layout Standard
Adic ist ein weiterer Dependency Injection Container für Unity3D, der sich
 vor allem durch seine Einfachheit in Umsetzung und Verwendung auszeichnet.
 Dennoch bietet er die vollständige Funktionalität eines Dependency Injection
 Containers und noch einige weitere Optionen.
 Diese sind unter anderem: Conditional Bindings, die es ermöglichen eine
 Registrierung eines Typs unter bestimmten Bedingungen vorzunehmen.
 Eine mögliche Bedingung ist beispielsweise, dass Injection eines Typs nur
 über Konstruktoren oder in bestimmte Instanzen erfolgen soll.
 Zudem implementiert Adic ein Command- und Eventsystem, das sehr ähnlich
 zu dem von StrangeIoC ist.
 Diese werden im folgenden Abschnitt genauer erläutert 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Adic2015"

\end_inset

.
\end_layout

\begin_layout Subsubsection
StrangeIoC
\end_layout

\begin_layout Standard
StrangeIoC ist ein umfangreiches Inversion Of Control Framework, das weit
 mehr als nur einen Dependency Injection Container bietet.
 Das Open-Source Projekt verfügt über eine aktive Community, die bemüht
 ist, das Framework kontinuierlich zu verbessern und zu erweitern.
 StrangeIoC ist in großen Teilen von Robotlegs, einem Application Architecture
 Framework für ActionScript, beeinflusst.
 Aus diesem wurde auch das wohl augenscheinlichste Merkmal des Frameworks
 übernommen: Eine MVC(S)-Architektur, mit der sich ein breites Spektrum
 von Anwendungen umsetzen lassen soll.
 Die Architektur vereint eine umfangreiche Anzahl von Konzepten, welche
 in ihrer Gesamtheit eine saubere Trennung von Verantwortungen ermöglichen
 sollen.
 Diese Konzepte und ihr Zusammenwirken als MVC(S)-Architektur sollen im
 folgenden Abschnitt erläutert werden 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "StrangeIoC2015:Main"

\end_inset

.
\end_layout

\begin_layout Section
MVC(S)-Architektur in Unity3D mithilfe von StrangeIoC
\end_layout

\begin_layout Standard
Model-View-Controller-Service, oder kurz MVC(S), ist ein Architekturmuster,
 welches die Struktur einer Anwendung in vier eigenständige Module unterteilt:
 Model, View, Controller und Service.
 Es erweitert die klassische MVC-Architektur um eine Serviceschicht, unter
 welche der Zugriff auf externe Daten und Dienste, wie Webserver, Datenbanksyste
me oder Zugriffe auf das Dateisystem, fallen.
 
\end_layout

\begin_layout Standard
MVC(S) soll einen konsistenten Ansatz zur Strukturierung einer Anwendung
 liefern.
 Genauso wie bei der klassischen MVC-Architektur ist die Grundlage hierfür
 Präsentations- von Anwendungslogik zu trennen.
 Diese Trennung erfolgt durch die Definition folgender Schichten: Die Präsentati
onsschicht (View-Layer) ist für die Darstellung der Benutzeroberfläche und
 der Verarbeitung von Interaktionen mit dem Benutzer zuständig.
 Die Modellschicht (Model-Layer) speichert den aktuellen Zustand der Anwendung,
 der durch das Ausführen von Operationen durch den Nutzer und externer Quellen
 resultiert.
 Die Steuerungsschicht (Controller-Layer) stellt Mechanismen zur Interaktion
 und Koordination zwischen den anderen Schichten zur Verfügung.
 
\end_layout

\begin_layout Standard
Zusätzlich zu dem Vorteil der Strukturierung, hilft die MVC(S)-Architektur
 von StrangeIoC die Kopplung zwischen den einzelnen Schichten zu minimieren.
 Damit sollen einzelne Programmabschnitte testbar und die Austauschbarkeit
 der Darstellungs- und Serviceschicht gewährleistet werden.
 Abhängigkeiten zu externen APIs können in der Serviceschicht gekapselt
 und somit austauschbar gemacht werden.
 Somit ist es beispielsweise ohne große Umstände möglich, den Zugriff auf
 Daten aus dem lokalen Dateisystem mit dem Remotezugriff auf eine Datenbank
 auszutauschen.
\end_layout

\begin_layout Standard
Die Umsetzung der MVC(S)-Architektur weicht stark von der des klassischen
 MVC Entwurfsmusters ab.
 StrangeIoC verwendet eine Reihe von eigenen Konzepten und Mustern um die
 MVC(S)-Architektur umzusetzen 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "StrangeIoC2015:Howto"

\end_inset

.
\end_layout

\begin_layout Subsection
Umsetzung von MVC(S) in StrangeIoC
\end_layout

\begin_layout Standard
In diesem Abschnitt soll erklärt werden, wie die in StrangeIoC zur Verfügung
 stehenden Konzepte in der MVC(S)-Architektur zusammenspielen.
 Eine schlüssige Zusammenfassung der Architektur liefert ein Schaubild aus
 der Dokumentation (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MVCS-Context"

\end_inset

).
 Wie in der Grafik beschrieben, ist der Einstiegspunkt in die Anwendung
 der ContextView.
 Von ihm wird der eigentliche Context instanziiert.
\end_layout

\begin_layout Subsubsection
Context und ContextView
\end_layout

\begin_layout Standard
Der Context ist ein von den restlichen Schichten der Architektur unabhängiges
 Modul.
 Grob gesagt handelt es sich um einen Composition Root wie in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Definieren-des-Composition"

\end_inset

 definiert.
 Mit dem Unterschied, dass es möglich ist, mehr als einen Context zu definieren.
 Jeder Context wird an einen ContextView, ein MonoBehaviour in einer bestimmten
 Scene, angehängt.
 Im Context wird wie im Composition Root die Registrierung von Typen beim
 Dependency Injection Container vorgenommen.
 Der Context definiert den Sichtbarkeitsbereich aller bei ihm registrierten
 Typen.
 Es ist jedoch auch möglich Registrierungen über mehrere Contexte hinweg
 vorzunehmen.
 StrangeIoC bezeichnet den Container als Binder und die Registrierung als
 Binding.
 Der Grund hierfür ist, dass nicht nur zu injizierende Abhängigkeiten registrier
t werden können.
 Es können auch -- wie im später noch genauer erläutert wird -- Commands
 an Signals und Views an Mediators gebunden werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleContext : MVCSContext
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	protected override void mapBindings()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.mapBindings();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IBoardLayoutModel>()
\end_layout

\begin_layout Plain Layout

			.To<BoardLayoutModel>().ToSingleton();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<IMovementRules>().To<MovementRules>();
\end_layout

\begin_layout Plain Layout

		injectionBinder.Bind<FieldClickedSignal>().ToSingleton();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<StartSignal>().InSequence()
\end_layout

\begin_layout Plain Layout

			.To<LoadBoardLayoutCommand>()
\end_layout

\begin_layout Plain Layout

			.To<CreateBoardFieldViewsCommand>();
\end_layout

\begin_layout Plain Layout

		commandBinder.Bind<FieldClickedSignal>()
\end_layout

\begin_layout Plain Layout

			.To<ToggleSelectionCommand>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		mediationBinder.Bind<FieldView>().To<FieldMediator>();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override IContext Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		base.Start();
\end_layout

\begin_layout Plain Layout

		var startSignal = injectionBinder.GetInstance<StartSignal>();
\end_layout

\begin_layout Plain Layout

		startSignal.Dispatch();
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Contexts für ein Brettspiel.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Context"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel eines Contexts für ein Brettspiel
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-Context"

\end_inset

 zeigt ein Beispiel eines Contexts: In der 
\shape italic
mapBindings
\shape default
-Methode erfolgen die Typregistrierungen bei den jeweiligen Bindern.
 Abhängigkeiten werden beim InjectionBinder registriert, Commands werden
 über den CommandBinder an Signale gebunden und Views an Mediatoren durch
 den MediationBinder.
 Diese Registrierungen werden immer komplexer mit dem Wachstum der Anwendung.
 Aus diesem Grund können sie auch in einzelne Klassen ausgelagert werden.
 Ist die Registrierung abgeschlossen, wird die Anwendung durch das Auslösen
 eines Signals in der 
\shape italic
Start
\shape default
-Methode gestartet.
 An dieses Startsignal wurden zuvor einige Commands gebunden, die nun ausgeführt
 werden.
\end_layout

\begin_layout Subsubsection
Signals
\end_layout

\begin_layout Standard
Signals stellen einen typsicheren Weg zur Kommunikation zwischen den einzelnen
 Architekturschichten dar.
 Signals können Commands auslösen, aber auch wie herkömmliche Events abonniert
 werden.
 Es handelt sich um eine Umsetzung des Observer-Musters, das intern Action-Deleg
aten anstatt Interfaces verwendet.
 Das Auslösen eines Signals erfolgt über die 
\shape italic
Dispatch-
\shape default
Methode.
 Wurde das Signal beim CommandBinder registriert, so fügt sich dieser als
 Listener hinzu.
 Beim Auslösen des Signals instanziiert der CommandBinder Instanzen der
 hinzugefügten Commands und führt diese aus.
 Damit sind Sender und Empfänger eines Signals komplett voneinander entkoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//Deklaration
\end_layout

\begin_layout Plain Layout

public class FieldClickedSignal : Signal<int>{};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Verwendung
\end_layout

\begin_layout Plain Layout

[Inject]
\end_layout

\begin_layout Plain Layout

public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clickSignal.Dispatch(12);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Deklaration und Verwendung eines Signals.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Signals-Definition"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel der Deklaration und Verwendung eines Signals
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Signals-Definition"

\end_inset

 zeigt die Deklaration und Verwendung eines Signals.
 Signals können bis zu vier Parameter haben, dessen Typen als Generika bei
 der Deklaration des Signals definiert werden.
 Diese Parameter werden bei Aufruf in Properties des Commands injiziert.
 Signals sind typsicher: Fehlerhaftes Aufrufen oder Abonnieren führt zu
 einer Ausnahme zur Laufzeit.
\end_layout

\begin_layout Subsubsection
Commands
\end_layout

\begin_layout Standard
Commands sind zustandslose Controller-Objekte, die ein einzelnes Verhalten
 kapseln.
 Commands werden von Signals ausgelöst: Ein Aufruf der 
\shape italic
Execute
\shape default
-Methode erfolgt automatisch.
 Im Normalfall haben sie eine sehr kurze Lebenszeit: Ein Signal löst die
 Instanziierung und Ausführung des Commands aus.
 Direkt danach erfolgt die Entsorgung.
 Commands bilden die Logik der Anwendung ab, indem sie Manipulationen an
 Models vornehmen, Spielobjekte instanziieren oder mit Services kommunizieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ToggleSelectionCommand : Command
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public int index { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IService service { get; set; } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void Execute()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Retain();
\end_layout

\begin_layout Plain Layout

		service.SendRequestToServer(response => {
\end_layout

\begin_layout Plain Layout

			//...
\end_layout

\begin_layout Plain Layout

			Release();
\end_layout

\begin_layout Plain Layout

		});
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel für einen Command.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Command"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel für einen Command
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der an das Signal aus dem vorigen Beispiel gebundene Command, dargestellt.
 Der beim Auslösen des Signals übergebene Parameter wird bei Instanziierung
 des Commands in das Property 
\begin_inset Quotes gld
\end_inset

index
\begin_inset Quotes grd
\end_inset

 injiziert.
 Commands wird es durch Aufruf der 
\shape italic
Retain
\shape default
-Methode ermöglicht, seine Zerstörung zu verzögern.
 Die Ausführung der Anwendung wird nicht eingeschränkt, da der Aufruf eines
 Commands asynchron erfolgt.
 Sehr nützlich ist Erhalten eines Commands beispielsweise bei der Client-Server-
Kommunikation: In dem gezeigten Beispiel in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-Command"

\end_inset

 wird der Command so lange am Leben erhalten, bis dieser eine Antwort vom
 Server erhält.
 Dies geschieht durch den Aufruf der Release-Methode im Callback der Anfrage.
\end_layout

\begin_layout Standard
Commands bieten eine sehr effiziente Möglichkeit Anwendungsschichten voneinander
 zu entkoppeln.
 Der Grund hierfür ist, dass sie sich nur durch Signale ausführen lassen:
 Es gibt für Models, Services und Mediatoren keinen Grund überhaupt von
 ihnen zu wissen.
 Models und Mediatoren brauchen lediglich Signale auszulösen, um die Ausführung
 der Anwendung in Gang zu setzen.
\end_layout

\begin_layout Subsubsection
Views
\end_layout

\begin_layout Standard
Wie bereits erwähnt sind Views oder View-Komponenten für die Darstellung
 der Benutzeroberfläche und der Verarbeitung von Interaktionen mit dem Benutzer
 verantwortlich.
 Dabei ist der Begriff 
\begin_inset Quotes gld
\end_inset

View
\begin_inset Quotes grd
\end_inset

 nicht unbedingt wörtlich zu nehmen: Sie übernehmen jegliche Ein- und Ausgabelog
ik, wie Rendering, Darstellungslogik von User Interfaces, Audioausgabe und
 eventuell Interaktion mit der Physikengine.
 Es sind Aufgaben, für die die Interaktion mit Unity3D notwendig ist.
 Aus diesem Grund sind Views MonoBehaviours.
 Sie beinhalten jedoch keinerlei Anwendungslogik und kommunizieren lediglich
 zu ihren Mediatoren über Events.
 Ansonsten sind sie komplett autonome Komponenten, die ausschließlich ihren
 eigenen Zustand manipulieren können.
 Aus diesem Grund sollten auch keine Injections in MonoBehaviours vorgenommen
 werden.
 Die Absicht hierbei ist, das Unity-Framework soweit wie möglich aus der
 Anwendungslogik rauszuhalten, um eine enge Kopplung zu diesem zu verhindern.
\end_layout

\begin_layout Subsubsection
Mediation
\end_layout

\begin_layout Standard
Das Mediator-Muster beschreibt einen Weg der Interaktion zwischen Objekten
 über einen Vermittler 
\begin_inset CommandInset citation
LatexCommand citep
after "S. 273"
before "vgl."
key "Gamma1994"

\end_inset

.
 In StrangeIoC vermitteln Mediatoren zwischen View- und Anwendungslogik.
 Mediatoren interagieren im Auftrag ihres Views mit dem Rest des Frameworks
 und anders herum.
 Dies geschieht, indem der Mediator die Events seines Views abbonniert und
 daraufhin entsprechende Signals auslöst.
 Umgekehrt abonniert der Mediator auch die Events von Services oder Models
 und führt daraufin Operationen an seinem View aus.
 
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Schaubild-Mediation"

\end_inset

 wird veranschaulicht, wie der Mediations-Prozess in StrangeIoC vonstattengeht:
 Sobald ein View in eine Scene geladen wird, sendet dieser automatisch in
 der Awake-Methode eine Message an den ContextView.
 Dafür muss zwangsläufig jeder View ein Childobject des jeweiligen ContextViews
 sein.
 Über den Context des ContextViews wird der MediationBinder aufgerufen.
 Dieser instanziiert einen zuvor an den View gebundenen Mediator und versorgt
 ihn mit seinen Abhängigkeiten mithilfe des Injectors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class SampleMediator : Mediator
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public SampleView view { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public IBoardLayoutModel layout { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	[Inject]
\end_layout

\begin_layout Plain Layout

	public FieldClickedSignal clickSignal { get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public override void OnRegister()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.AddListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.AddListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public override void OnRemove()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.OnBoardClicked.RemoveListener(OnClick);
\end_layout

\begin_layout Plain Layout

		layout.OnLayoutChanged.RemoveListener(OnLayoutChange);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private void OnClick(Vector2 clickPosition)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var index = ClickPositionToFieldIndex(clickPosition);
\end_layout

\begin_layout Plain Layout

		clickSignal.Dispatch(index);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnLayoutChange()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		view.Refresh();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel der Implementation eines Mediators.
 Quelle: Eigene Abbildung
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-Mediator"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Beispiel der Implementation eines Mediators
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-Mediator"

\end_inset

 wird ein Beispiel für eine mögliche Implementation eines Mediators gezeigt.
 Der Mediator reagiert auf das 
\shape italic
OnBoardClicked
\shape default
-Event des Views, indem er die Klickposition in einen verwendbaren Index
 konvertiert und daraufhin ein 
\shape italic
FieldClickedSignal
\shape default
 mit dem Index als Parameter auslöst.
 Weiter abonniert der Mediator das 
\shape italic
OnLayoutChanged
\shape default
-Event des 
\shape italic
IBoardLayoutModels
\shape default
.
 In Reaktion auf dieses Event ruft der Mediator die 
\shape italic
Refresh
\shape default
-Methode des von ihm vermittelten Views auf.
 Das An- und Abmelden an die Events erfolgt in den 
\shape italic
OnRegister
\shape default
- und 
\shape italic
OnRemove
\shape default
-Callbacks.
 
\shape italic
OnRegister
\shape default
 wird direkt nach der Injektion von Abhängigkeiten aufgerufen.
 Der Aufruf von 
\shape italic
OnRemove
\shape default
 erfolgt beim Zerstören des Views.
\end_layout

\begin_layout Standard
Wie im Beispiel deutlich wird, agieren Mediatoren lediglich als Brücke zwischen
 Darstellungs- und Anwendungslogik.
 Sie sollten somit leichtgewichtig sein und möglichst keine eigene Logik
 beinhalten.
 Sie dienen einzig dazu, Anwendungslogik aus den Views herauszuhalten.
 Dafür gibt es zahlreiche Gründe: Darstellungslogik tendiert dazu mit der
 Zeit unüberschaubar zu werden, da an ihr oft Änderungen in letzter Minute
 vorgenommen werden.
 Weiter verwendet die Darstellungslogik eines Views die API von Unity3D,
 die durch statische Klassen und fehlendem Interfacesupport zu enger Kopplung
 und damit zu eingeschränkter Testbarkeit führt.
\end_layout

\begin_layout Subsubsection
Models und Services
\end_layout

\begin_layout Standard
Die Aufgaben eines Models in StrangeIoC unterscheiden sich nicht von denen
 eines Models in einer klassischen MVC-Architektur.
 Models kapseln Zustand und Daten der Anwendung und ermöglichen den Zugriff
 auf diese über wohldefinierte Schnittstellen.
 Andere Klassen können über diese Schnittstellen Anfragen an das Model senden.
 Models selber senden keine Anfragen: Wird ein Model geändert, lässt es
 dies den Rest der Anwendung wissen, indem es ein Event auslöst.
\end_layout

\begin_layout Standard
Services stehen eng mit Models in Verbindung.
 Dennoch sollten sie getrennt voneinander existieren.
 Ein Service beschafft -- oft durch die Kommunikation zur Außenwelt -- Daten.
 Ein Model speichert diese Daten.
 Services kommunizieren mit externen Ressourcen einer Applikation.
 Beispiele für solche Ressourcen sind unter anderem: Webserver und -Services,
 das Dateisystem und Datenbanken.
 Der Zugriff aus Services erfolgt über Commands, wie bereits in Abbildung
 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Beispiel-Command"

\end_inset

 gezeigt.
 
\end_layout

\begin_layout Subsection
Beispielanwendung
\end_layout

\begin_layout Standard
Die im letzten Abschnitt gezeigten Programmcode-Ausschnitte wurden aus einer
 für diese Arbeit programmierten Beispielanwendung übernommen.
 Damit der Fokus auf die zu erläuternden Konzepte nicht verloren geht, wurden
 die Klassen für die Beispiele teilweise gekürzt und abgeändert.
 Die tatsächliche Implementation der Beispielanwendung ist auf der sich
 im Anhang dieser Arbeit befindlichen CD zu finden.
 Es handelt sich um eine Implementation des Brettspiels Peg Solitaire.
\end_layout

\begin_layout Subsection
Beurteilung der Anwendbarkeit von MVC(S) in der Spieleentwicklung
\end_layout

\begin_layout Standard
Wie aus den vorgestellten Konzepten ersichtlich wird, wurde die MVC(S)-Architekt
ur von StrangeIoC speziell mit der Absicht entworfen, Kopplung zu minimieren.
 Durch die Architektur ist es möglich Daten, Präsentation und Anwendungslogik
 eines Videospiels weitestgehend voneinander zu entkoppeln.
 Dennoch kann keine eindeutige Empfehlung zur generellen Verwendung der
 Architektur in der Spieleentwicklung gegeben werden.
\end_layout

\begin_layout Standard
StrangeIoCs Architektur hat ihren Ursprung in der Entwicklung von Rich Internet
 Applications 
\begin_inset CommandInset citation
LatexCommand citep
after "S. IX"
before "vgl."
key "Hooks2011"

\end_inset

.
 Es werden weitaus weniger performancekritische Operationen als in Videospielen
 ausgeführt.
 In besonders performancekritischen Momenten innerhalb des Game Loops sollte
 deshalb auf eine hohe Anzahl an Injections und Signals verzichtet werden
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand citealp
key "StrangeIoC2015:Howto"

\end_inset

).
 Eine Empfehlung ist, MVC(S) als Anwendungsarchitektur auf einer höheren
 Ebene anzusehen: Es handelt sich um ein Gerüst, das auf die meisten Teile
 des Programms anwendbar ist.
 So eignet sich die Architektur beispielsweise dazu, Benutzeroberflächen,
 Dateizugriffe und Client-Server-Kommunikation umzusetzen.
 Ob die Architektur auch innerhalb des Game Loop angewendet werden kann,
 muss für ein Spiel im Speziellen entschieden werden.
 Sie kann dennoch für die restlichen Programmabschnitte des Spiels verwendet
 werden.
\end_layout

\begin_layout Standard
Die komponentenbasierte Architektur von Unity3D berücksichtigt StrangeIoC
 nur teilweise: Es ist möglich einzelne Komponenten zu mediieren.
 Dies würde jedoch zu einer stark erhöhten Komplexität der Anwendung führen.
 In der Praxis werden Spielobjekte deshalb als ein Ganzes -- einem View
 -- angesehen.
 
\end_layout

\begin_layout Chapter
Kritische Betrachtung & Fazit
\begin_inset CommandInset label
LatexCommand label
name "chap:Fazit"

\end_inset


\end_layout

\begin_layout Standard
Die Spieleengine Unity3D erfreut sich immer größerer Beliebtheit unter Spieleent
wicklern.
 Gründe dafür sind Plattformunabhängigkeit, ausgereifte Rendertechniken,
 Benutzerfreundlichkeit und der einfache Einstieg in die Entwicklungsumgebung.
 Mit Wachstum eines Softwareprojektes und Teams werden weitere nichtfunktionale
 Anforderungen wie Wartbarkeit, Erweiterbarkeit, Wiederverwendbarkeit, Testbarke
it und die Möglichkeit zur parallelen Entwicklung deutlich.
 Im zweiten Kapitel dieser Arbeit wurde beschrieben, dass sich Kopplung
 zwischen Entitäten maßgeblich auf diese Anforderungen auswirkt.
 Kopplung beschreibt die Anzahl und Stärke von Abhängigkeiten unter Softwareenti
täten.
 Eine Abhängigkeit entsteht, sobald eine Entität mit einer anderen kommunizieren
 muss, um zu funktionieren.
 Damit wurde das Ziel dieser Arbeit deutlich: Es soll untersucht werden,
 wie Kopplung zwischen Entitäten bei der Entwicklung von Videospielen in
 Unity3D minimiert werden kann.
 
\end_layout

\begin_layout Standard
Hierzu wurde zunächst Inversion Of Control als grundlegendes Paradigma präsentie
rt.
 Allein Inversion Of Control ermöglicht die Kommunikation zwischen Entitäten,
 ohne sie dabei eng miteinander zu koppeln.
 Mit Dependency Injection wurde eine konkrete Umsetzung von Inversion Of
 Control durch die Umkehr der Kontrolle über die Auflösung von Abhängigkeiten
 präsentiert.
 Es handelt sich um eine Reihe von Praktiken und Mustern, die es unter Wahrung
 der SOLID-Prinzipien ermöglichen, lose Kopplung zu erreichen.
 Die Vorteile loser Kopplung wurden durch die Umsetzung von Dependency Injection
 anhand eines Beispiels innerhalb einer Konsolenanwendung deutlich gemacht:
 Dadurch, dass Abhängigkeiten lediglich in Form von Interfaces vorliegen,
 ist es nicht notwendig, dass die eigentliche Implementierung überhaupt
 bekannt sein muss.
 Wie diese Implementierung tatsächlich aussieht, ergibt sich erst zur Laufzeit
 durch späte Bindung.
 Entitäten sind unabhängig voneinander austauschbar und erweiterbar.
 Durch diese Unabhängigkeit ist eine parallele Entwicklung gewährleistet.
 Lose Kopplung macht einzelne Entitäten testbar, indem sie in Isolation
 betrachtet werden können.
\end_layout

\begin_layout Section
Kopplung in Unity3D
\end_layout

\begin_layout Standard
Nachdem die Vorteile und eine mögliche Umsetzung von loser Kopplung durch
 Inversion Of Control deutlich gemacht wurden, wurde Unity3D auf die Anwendung
 des Paradigmas geprüft.
 Zunächst wurde untersucht, inwieweit sich Unitys komponentenbasierte Architektu
r von einer klassischen objektorientierten Vererbungshierarchie unterscheidet.
 Es wurde festgestellt, dass in Unity3D bereits Inversion Of Control stattfindet.
 Die Kontrolle über die Komposition und Lebenszeit von Objekten ist längst
 invertiert.
 Aus diesem Grund können Abhängigkeiten nicht auf herkömmlichen Wegen aufgelöst
 werden.
 Als Alternative stellt Unity3D eine Vielzahl von Kommunikationsmechanismen
 bereit.
 Diese wurden auf ihre Fähigkeit lose Kopplung umzusetzen untersucht.
 Es wurde festgestellt, dass diese Kommunikationsmechanismen bestimmten
 Beschränkungen unterliegen und einige Probleme mit sich bringen.
 Somit ist es zwar mit einigen Mechanismen, wie z.
 B.
 
\shape italic
GetComponent, 
\shape default
möglich lose Kopplung umzusetzen, jedoch ist die Kommunikation auf Objekte
 innerhalb der Szenenhierarchie beschränkt.
 Der Architektur von Unity3D fehlt ein Mittel zum Umgang mit geteilter Logik,
 die keinem einzelnen Spielobjekt zugeordnet werden kann.
 Das Resultat ist die häufige Verwendung von Anti-Patterns wie Managern,
 God Objects und Singletons, die zu enger Kopplung führen.
 Aus diesem Grund wurde die Entscheidung getroffen, Dependency Injection
 auch in Unity3D umzusetzen, um es so zu ermöglichen lose Kopplung zu realisiere
n, ohne dabei die Kommunikation auf Komponenten oder Spielobjekte zu beschränken.
\end_layout

\begin_layout Subsection
Dependency Injection
\end_layout

\begin_layout Standard
Aufgrund der bereits beschriebenen Einschränkungen durch Unitys Architektur,
 ist es nicht möglich Dependency Injection manuell durchzuführen.
 Aus diesem Grund wurde sich dazu entschieden Dependency Injection durch
 Implementation eines Inversion Of Control Frameworks zu automatisieren.
 Dabei gab es einige Probleme zu bewältigen: Es musste zunächst ein 
\begin_inset Quotes gld
\end_inset

künstlicher
\begin_inset Quotes grd
\end_inset

 Composition Root in Form eines MonoBehaviours definiert werden.
 Weiter wurden Möglichkeiten zu Injektion in MonoBehaviours beschrieben.
 Da alle Varianten mit Nachteilen behaftet sind, wurde sich nicht explizit
 für eine entschieden.
 Anzumerken ist, dass bei allen Methoden Property Injection verwendet werden
 muss.
 Bei der Implementation des Frameworks wurde deutlich, dass ein Dependency
 Injection Container von Attributes und Reflection Gebrauch macht.
 Da Reflection sehr performanceintensiv ist, sollte in zeitkritischen Momenten
 auf Dependency Injection verzichtet werden.
 Eine Funktionalität die deswegen noch zum Framework hinzugefügt werden
 sollte, ist das Caching von Reflectionaufrufen.
 Für eine tatsächliche Verwendung bei der Entwicklung eines Videospiels
 sollte somit ein ausgereifteres Framework verwendet werden.
 In dieser Arbeit wurde ein Überblick über die für Unity3D entwickelten
 Inversion Of Control Frameworks geliefert, um diese Entscheidung zu erleichtern.
 
\end_layout

\begin_layout Subsection
StrangeIoC
\end_layout

\begin_layout Standard
Dependency Injection allein führt noch nicht zu einer guten Softwarearchitektur.
 Um Kopplung weiter zu reduzieren, muss Inversion Of Control konsequent
 umgesetzt werden.
 StrangeIoC, eines der vorgestellten Inversion Of Control Frameworks, bietet
 hierzu zusätzlich eine individuelle MVC(S)-Architektur.
 Unterschiedliche Belange einer Anwendung werden in die Architekturschichten
 Model, View, Controler und Service eingeteilt.
 Durch die Vereinheitlichung der Kommunikation mittels Signals wird lose
 Kopplung zwischen den Architekturschichten ermöglicht.
 StrangeIoC liefert mit der MVC(S)-Architektur einen konsistenten Ansatz
 zur Strukturierung einer Anwendung.
 Mit diesem gernerellen Architekturansatz lässt sich ein breites Spektrum
 von Anwendungen umsetzen.
 Es gibt jedoch auch Fälle, für die die MVC(S)-Architektur weniger gut geeignet
 ist.
 Dies sind unter anderem Videospiele, die viel zeitkritische Logik beinhalten
 oder stark von der komponentenbasierten Architektur Unitys gebrauch machen.
\end_layout

\begin_layout Section
Ausblick und Alternativen
\end_layout

\begin_layout Standard
Zusammenfassend kann gesagt werden, dass Dependency Injection auch in Unitys
 komponentenbasierter Architektur seine Existenzberechtigung hat.
 Im Gegensatz zu integrierten Kommunikationsmechanismen ist die Kommunikation
 nicht auf Spielobjekte und Komponenten in der Szene beschränkt.
 Durch Dependency Injection wird es ermöglicht, lose Kopplung in Unity3D
 umzusetzen.
 Inversion Of Control Container und deren Integration in Unity gehen jedoch
 nicht nur mit Vorteilen einher: Injections können einen negativen Einfluss
 auf Performance haben.
 Da der Composition Root selbst ein Spielobjekt in der Szene sein muss,
 kann er streng genommen mit dem Manager Anti-Pattern in Verbindung gebracht
 werden.
 Es handelt sich um eine Einschränkung, die direkt auf die komponentenbasierte
 Architektur von Unity3D zurückzuführen ist.
\end_layout

\begin_layout Standard
Ferner ist es jedoch die Verantwortung der Engine, ein Kommunikationsmittel
 bereitzustellen, das lose Kopplung zwischen Entitäten ermöglicht.
 Ein Ansatz hierfür wäre, dass Unity3D von sich aus einen Composition Root
 oder sogar eine integrierte Form von Dependency Injection zur Verfügung
 stellt.
 Eine weitere Alternative wäre der Schritt zu einer Entity Component System
 Architektur.
 In einer solchen Architektur beinhalten Komponenten lediglich Daten und
 müssen somit nicht miteinander kommunizieren.
 Jegliches Verhalten wird von Systemen abgebildet.
 Die Engine sorgt dafür, dass das System Referenzen zu relevanten Komponenten
 aller Entities erhält.
 Somit machen auch Entity Component Systems gebrauch von Inversion Of Control.
 Indem der Zustand einer Anwendung ausschließlich in Komponenten gehalten
 wird, gibt es keinen Grund für Systeme untereinander zu kommunizieren.
 In einer Entity Component System Architektur existiert Kopplung somit lediglich
 in Form von Daten und Events von Komponenten, die von mehreren Systemen
 genutzt werden 
\begin_inset CommandInset citation
LatexCommand citep
before "vgl."
key "Mandala2015"

\end_inset

.
\end_layout

\begin_layout Standard
Die Ansätze schließen sich nicht gegenseitig aus: Dependency Injection kann
 auch in einer Entity Component System Architektur angewendet werden, um
 Abhängigkeiten von Systemen lose mit diesen zu koppeln.
 Es könnte sogar ein Dependency Injection Container zur Implementation einer
 Entity Component System Architektur genutzt werden.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Ab hier folgt nun der Glossar.
 Manchmal ist das nicht nötig, dann muss es auch unter Dokumente --> Einstellung
en --> Latex-Vorspann deaktivieren.
 Übrigens werden Lyx-Notizen im späteren Dokument nicht angezeigt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout

% Die folgende Zeile sorgt dafuer, dass der Glossar im Inhaltsverzeichnis
 angezeigt wird.
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Glossar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Single Responsibility Principle"
description "Eine Klasse soll nur eine Verantowrtlichkeit haben."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Open Closed Principle"
description "Eine Klasse soll offen für Erweiterung, jedoch geschlossen für Modifikation sein."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Liskov Subsitituion Principle"
description "Abgeleite Klassen sollen sich so verhalten wie der Basistyp es von ihnen erwartet."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Interface Segregation Principle"
description "Interfaces sollen nur die Funktionalität wiederspiegeln die ihre Klienten erwarten."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Dependency Inversion Principle"
description "High-Level Klassen sollen nicht von Low-Level Klassen abhängig sein, sondern beide von Interfaces. Interfaces sollen nicht von Details abhängig sein sondern Details von Interfaces"

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "System Under Test"
description "Ein System Under Test bezeichnet das eine zu testende Enität in einem Testszenario."

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "auto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Hier folgt nun das Literaturverzeichnis.
 Die benötigten Dateien liegen im Verzeichnis: bibtex-daten
\end_layout

\begin_layout Plain Layout
Dieses wird automatisch erstellt.
 Zum bearbeiten der 
\begin_inset Quotes gld
\end_inset

Literatur-Datenbank
\begin_inset Quotes grd
\end_inset

 verwende ich das Programm 
\begin_inset Quotes gld
\end_inset

JabRef
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex-daten/bachelorarbeit-info"
options "bibtotoc,natdin"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{appendices}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
MVC(S) Architekturübersicht
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/Strange_Flow_Chart.png
	lyxscale 40
	height 78text%
	scaleBeforeRotation
	rotateAngle 90
	rotateOrigin centerBaseline

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild MVC(S) Context Architektur.
 
\begin_inset CommandInset citation
LatexCommand citealp
before "Quelle:"
key "StrangeIoC2015:Main"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MVCS-Context"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Schaubild MVC(S) Context Architektur in StrangeIoC
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Mediation in StrangeIoC
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/strange_mediation.png
	lyxscale 60
	height 78text%
	scaleBeforeRotation
	rotateAngle 90

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schaubild zur Verdeutlichung des Mediation-Prozesses.
 
\begin_inset CommandInset citation
LatexCommand citealp
before "Quelle:"
key "StrangeIoC2015:Mediation"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Schaubild-Mediation"

\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Schaubild Mediation-Prozess in StrangeIoC
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{appendices}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
