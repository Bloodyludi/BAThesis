#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\captionsetup[table]{skip=10pt}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
\usepackage{lmodern}
\usepackage[scaled=0.92]{helvet}
\usepackage{mathptmx}
\usepackage{courier}

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{roman}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
\addto\captionsngerman{ 
\renewcommand{\figurename}{Abb.}% 
\renewcommand{\tablename}{Tab.}% 
\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}

%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
\usepackage{color}
\usepackage{listings}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
%xleftmargin = 15pt,
%frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\footnotesize,
backgroundcolor = \color{background},
tabsize=4,
}
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
todonotes
\end_modules
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 92
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Inversion of Control in Unity3D"
\pdf_author "Ludwig Lauer"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/hs-harz-logo.eps
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size larger
Bachelorarbeit
\end_layout

\begin_layout Standard
\noindent
\align left

\size large
Inversion Of Control in Unity3D
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eingereicht von:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrikelnummer: m18711
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fachbereich Automatisierung und Informatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Studiengang Medieninformatik
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erstprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Daniel Ackermann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zweitprüfer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Ph.
 D.
 Jürgen K.
 Singer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hochschule Harz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Eidesstattliche Erklärung
\end_layout

\begin_layout Standard
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst
 und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.
 Alle Ausführungen, die anderen veröffentlichten oder nicht veröffentlichten
 Schriften wörtlich oder sinngemäß entnommen wurden, habe ich kenntlich
 gemacht.
\end_layout

\begin_layout Standard
Die Arbeit hat in gleicher oder ähnlicher Fassung noch keiner anderen Prüfungsbe
hörde vorgelegen.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Berlin, der 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ludwig Lauer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Sperrvermerk
\end_layout

\begin_layout Standard
Die vorliegende Bachelorarbeit enthält vertrauliche Informationen der Firma
 Wooga GmbH, die der Geheimhaltung unterliegen.
 Veröffentlichungen oder Vervielfältigungen der Bachelorarbeit - auch nur
 auszugsweise - sind ohne ausdrückliche Genehmigung der Firma Wooga GmbH
 nicht gestattet.
 Die Bachelorarbeit ist nur den Mitarbeitern des betreuenden Lehrstuhls
 sowie den Mitgliedern des Prüfungsausschusses zugänglich zu machen.
 Alle Rechte zum Erwerb und zur Anmeldung gewerblicher Schutzrechte, insbesonder
e zur Anmeldung von Patenten, Gebrauchsmustern und/oder Geschmacksmustern
 sind der Firma Wooga GmbH vorbehalten.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
Exposé
\end_layout

\begin_layout Standard
Unity3D hat sich in den letzten Jahren als Spieleengine etabliert.
 Immer größere und ambitioniertere Projekte werden mit der Engine umgesetzt.
 Da Unity als Rapid Prototyping Tool für unabhängige Spieleentwickler konzipiert
 wurde, fällt die parallele Entwicklung in mittleren bis großen Teams schwer.
 Eine der Ursachen dieses Problems ist die enge Kopplung von Abhängigkeiten
 zwischen Objekten.
 Die Folgen sind Starrheit und Zerbrechlichkeit bei Veränderung des Programmcode
s.
\end_layout

\begin_layout Standard
In der objektorientierten Programmierung gilt Inversion Of Control als Maßnahme
 um lose Kopplung zu erzielen.
 In dieser Arbeit soll untersucht werden, ob sich das Paradigma auch in
 der komponentenbasierten Architektur von Unity3D anwenden lässt.
 Dafür soll das Framework StrangeIoC herangezogen und genauer betrachtet
 werden.
 Mit Features wie Automated Dependency Injection, eigenem Eventsystem und
 einer MVC(S) Architektur sollen die Qualität, Testbarkeit, Skalierbarkeit
 und Wartbarkeit der Anwendung erhöht werden.
\end_layout

\begin_layout Standard
Ziel der Bachelorarbeit ist folglich das Erstellen einer lose gekoppelten
 Beispielanwendung in Unity3D unter Verwendung von StrangeIoC.
 Zudem soll untersucht werden, welche Praktiken die Ursache von enger Kopplung
 in Unity3D sind, welche Folgen diese haben und wie diese mit Inversion
 Of Control, Dependency Injection und StrangeIoC im speziellen, vermeidbar
 sind.
\end_layout

\begin_layout Standard
Die Bachelorarbeit beinhaltet folgende Teilaufgaben:
\end_layout

\begin_layout Itemize
Analyse von Ursachen und Folgen enger Kopplung zwischen Objekten in Unity3D
\end_layout

\begin_layout Itemize
Auseinandersetzung mit den Paradigmen Inversion Of Control und Dependency
 Injection
\end_layout

\begin_layout Itemize
Entwicklung einer Beispielanwendung mit StrangeIoC mit dem Ziel lose Kopplung
 unter Objekten umzusetzen
\end_layout

\begin_layout Itemize
Kritische Betrachtung von Entwicklungsaufwand, Qualität, Testbarkeit, Skalierbar
keit und Wartbarkeit im Vergleich mit anderen Architekturansätzen 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ACHTUNG: Hier am Ende noch die richtige Seite einstellen! Sonst passt die
 Nummerierung nicht!
\end_layout

\begin_layout Plain Layout
!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Unity hat sich in den letzten Jahren zur führenden Spieleengine entwickelt.
 Mit über 45% des globalen Marktanteils unter Spieleengines
\begin_inset Foot
status open

\begin_layout Plain Layout
http://unity3d.com/public-relations
\end_layout

\end_inset

 trägt Unity maßgeblich an dem Independent Videogame Boom der letzten Jahre
 bei.
 Unity ermöglicht die plattformunabhägige Erstellung von 2D und 3D Spielen.
 Dies hat besonders auf dem fragmentierten Markt der mobilen Spieleindustrie
 Anklang gefunden.
 Mit sich fortlaufend verbessernder Performance und Rendertechniken sind
 immer ambitioniertere Projekte möglich.
 Dies bewegt nicht nur Indieentwickler und kleine Teams dazu, sich die Vorteile
 der Engine zunutze zu machen: Unity findet immer mehr Einzug in professionelle
 Spieleprojekte mit mittleren und großen Teams.
 Hier sind Tätigkeitsbereiche spezialisiert und klar definiert.
 Die Anforderungen an die Spieleengine beginnen sich zu wandeln.
 Parallele Entwicklung muss gewährleistet werden.
 Der Programmcode muss modular, skalierbar und wiederverwendbar sein.
 Es darf keinen Raum für Fehlkonfigurationen geben.
 Neue Geschäftsmodelle wie Free-to-Play bewirken, dass Spiele immer mehr
 zur Dienstleistung werden.
 Sie müssen über mehrere Jahre hinweg wartbar und erweiterbar bleiben.
\end_layout

\begin_layout Standard
Schaut man sich auf den zahlreichen Websites, Blogs und Foren über Unity
 um, scheinen diese Anforderungen Unity's Schwachstelle zu sein: Frustration
 und Beschwerden über entstehenden Spaghetti-Code
\begin_inset Foot
status open

\begin_layout Plain Layout
https://np.reddit.com/r/gamedev/comments/3hr8al/coming_from_a_net_programming_back
ground_unitys/
\end_layout

\end_inset

, Kritik an der Komponentenbasierten Architektur
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.unityninjas.com/code-architecture/unity3d-game-code-architecture/
\end_layout

\end_inset

, Fehlende Testbarkeit
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.mikecann.co.uk/games/taming-unity/
\end_layout

\end_inset

 und Aussagen, dass Unity nur als Rapid Prototyping Tool tauglich ist und
 Kollaboration in großen Teams kaum möglich ist.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.namekdev.net/2014/06/why-i-hate-unity3d-popularity/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oft sollen die Ursachen gerade die Dinge sein, die unerfahrenen Programmierern
 den einfachen Umgang mit Unity ermöglichen.
 Unter diesen Ursachen ist eine Sache so gut wie immer vertreten: Die Auflösung
 von Abhängigkeiten und Kommunikation zwischen Objekten.
 Enge Kopplung von Abhängigkeiten zwischen Objekten führt zu Starrheit und
 Zerbrechlichkeit bei Veränderung des Programmcodes.
 In der objektorientierten Programmierung ist dieses Problem seit langem
 bekannt.
 Es existieren zahlreiche Lösungen für die unteschiedlichsten Situationen
 und Entwicklungsumgebungen.
 Oft sind diese Lösungen Frameworks, die eng mit den Begriffen Inversion
 Of Control und Dependency Injection in Verbindung stehen.
\end_layout

\begin_layout Standard
Nun implementiert Unity keine klassische objektorientierte Hierarchie, sondern
 eine komponentenbasierte Architektur.
 Trotzdem haben auch für Unity eine Handvoll Inversion of Control Frameworks
 das Licht der Welt erblickt.
 
\end_layout

\begin_layout Section
Zielsetzung
\end_layout

\begin_layout Standard
In dieser Arbeit wird sich auf ein Problem beschränkt: Die Kopplung von
 Abhängigkeiten zwischen Modulen in Unity.
 Ziel dieser Arbeit ist die Umsetzung Spiels in Unity zu ermöglichen, dessen
 Module lose miteinander gekoppelt sind.
\end_layout

\begin_layout Standard
Zunächst soll die Problematik der Kopplung beschrieben werden.
 Vorraussetzung dafür ist, zu erläutern, was Abhängigkeiten sind und warum
 Sie entstehen.
 Weiter sollen auch die Folgen von enger Kopplung erläutert werden.
 Dabei soll klar werden, dass Kopplung direkten Einfluss auf die Erweiterbarkeit
 des Programmcodes hat.
 
\end_layout

\begin_layout Standard
Weiter soll anhand eines Beispiels erklärt werden, wie lose Kopplung mittels
 Dependency Injection umzusetzen ist.
 In diesem Zusammenhang sollen auch zugrunde liegende Prinzipien erläutert
 werden.
\end_layout

\begin_layout Standard
Infolgedessen soll der Schritt zu Unity getätigt werden.
 Es soll untersucht werden inwiefern Unity von einer herrkömmlichten objektorien
tierten Hierarchie abweicht und ob dies hinderlich dabei ist, lose Kopplung
 umzusetzen.
 Es sollen häufig verwendete Praktiken wie das Singleton-Pattern und Managerobje
kte untersucht werden.
 Wie später im Detail erklärt wird, entstehen Abhängigkeiten unter anderem
 aus dem Bedürfnis, dass Objekte miteinander kommunizieren müssen.
 Unity stellt dafür unterschiedliche Wege der Kommunikation bereit.
 Es soll untersucht werden, ob diese Wege es bereits ermöglichen lose Kopplung
 umzusetzen.
 Auf Basis dieser Erkenntnisse soll ein Zwischenfazit gezogen werden.
\end_layout

\begin_layout Standard
Im nächsten Schritt soll Inversion Of Control in Unity implementiert werden.
 Das Resulat dieses Teils ist ein Dependency Injection Container der es
 eine lose gekoppelte Anwendung in Unity zu schreiben.
 Die technische Umsetzung soll erläutert werden.
 Mit Unity in Verbinung stehende Hürden bei der Umsetzung sollen überwunden
 und beschrieben werden.
\end_layout

\begin_layout Standard
Der nächste Teil gibt einen Überblick über die vorhandenen Inversion Of
 Control Frameworks für Unity.
 Besonderheiten, Funktionsweise und -Umfang soll beschrieben werden.
 Besondere Betrachtung soll StrangeIoC finden.
\end_layout

\begin_layout Standard
Im nächsten Teil sollen Entwicklungsaufwand, Wartbarkeit, Erweiterbarkeit,
 Testbarkeit, Wiederverwendbarkeit und Performance von einer Anwendung,
 die mithilfe von StrangeIoc umgesetzt wurde, untersucht werden.
 Dies soll anhand von Beispielen geschehen.
\end_layout

\begin_layout Itemize
Untersuchen, ob und wie Inversion Of Control auch in der komponentenbasierten
 Architektur von Unity anwendbar ist
\end_layout

\begin_layout Itemize
Inversion of Control Frameworks für Unity erläutern: Testbarkeit, Wartbarkeit,
 Aufwand, Performance, Erweiterbarkeit allgemein und im speziellen
\end_layout

\begin_layout Itemize
Alternative Lösungsansätze für Decoupling und Architektur in Unity präsentieren
 und untersuchen
\end_layout

\begin_layout Itemize
Entscheiden, für welche Anwendungsgebiete die Architekturen am besten geeignet
 sind/ob sie immer zu empfehlen sind
\end_layout

\begin_layout Section
Aufbau der Arbeit
\end_layout

\begin_layout Standard
Teil 1
\end_layout

\begin_layout Itemize
Unity Architektur, Komponentensystem, Objektlebenszyklus: Beschreiben und
 Probleme aufzeigen
\end_layout

\begin_layout Itemize
Auf das Problem der Auflösung von Abhängigkeiten tiefer eingehen
\end_layout

\begin_layout Standard
Teil 2
\end_layout

\begin_layout Itemize
Inversion Of Control als Lösung und alle verbundenen Begriffe beschreiben,
 Beispielhaft erläutern
\end_layout

\begin_layout Itemize
Herkunft von Inversion Of Control: OO, Enterprise Architecture
\end_layout

\begin_layout Itemize
Anwendung von Inversion Of Control in Unity beschreiben
\end_layout

\begin_layout Itemize
Funktionalität auf Basis des eigenen DIContainers erläutern
\end_layout

\begin_layout Itemize
Anwendbarkeit in der Komponentenbasierten Welt von Unity kritisch betrachten
\end_layout

\begin_layout Standard
Teil 3
\end_layout

\begin_layout Itemize
Existierende Inversion Of Control Frameworks in Unity
\end_layout

\begin_layout Itemize
StrangeIoC
\end_layout

\begin_layout Itemize
Zenject
\end_layout

\begin_layout Itemize
ADIC
\end_layout

\begin_layout Standard
Teil 4
\end_layout

\begin_layout Itemize
Beispiel Anwendung
\end_layout

\begin_layout Itemize
Entwicklungsaufwand, Wartbarkeit, Erweiterbarkeit, Testbarkeit, Wiederverwendbar
keit, Performance
\end_layout

\begin_layout Standard
Teil 5 
\end_layout

\begin_layout Itemize
Alternative Architekturansätze
\end_layout

\begin_layout Itemize
Entity Component System
\end_layout

\begin_layout Standard
Teil 6
\end_layout

\begin_layout Itemize
Fazit
\end_layout

\begin_layout Itemize
Entscheiden, für welche Anwendungsgebiete die Architekturen am besten geeignet
 sind/ob sie immer zu empfehlen sind
\end_layout

\begin_layout Chapter
Grundlagen
\end_layout

\begin_layout Standard
Lose Kopplung zwischen Softwareentitäten (Modulen, Klassen, Methoden) wird
 als Indiz für gute Softwarearchitektur angesehen.
 Inversion Of Control und genauer Dependency Injection werden als Werkzeuge
 angesehen um lose Kopplung umzusetzen.
 In diesem Teil der Arbeit soll erläutert werden was Kopplung zwischen Modulen
 ist und wie diese Zustande kommt.
 
\end_layout

\begin_layout Itemize
Das Problem soll verstanden werden
\end_layout

\begin_layout Itemize
Wie die Lösung (DI) in einer Konsolenanwendung umzusetzen ist
\end_layout

\begin_layout Itemize
Was lose Kopplung ermöglicht
\end_layout

\begin_layout Section
Kopplung und Kohäsion
\end_layout

\begin_layout Standard
Kopplung ist ein Maß, das die Anzahl und Stärke von Abhängigkeiten unter
 Softwareentitäten einer Anwendung beschreibt.
\begin_inset CommandInset citation
LatexCommand cite
after "S. 2-3"
key "Society2014"

\end_inset

 Ist eine Softwareentität direkt von der Implementation einer anderen Entität
 abhängig, so sind diese eng miteinander gekoppelt.
 Ziel ist es, die Anzahl und Stärke von Abhängigkeiten zu minimieren und
 so lose Kopplung umzusetzen.
 Martin Fowler beschreibt in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2001"

\end_inset

 Kopplung wie folgt:
\end_layout

\begin_layout Verse
\begin_inset Quotes gld
\end_inset

If changing one module in a program requires changing another module, then
 coupling exists.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Eine Abhänigigkeit zwischen Entitäten entsteht, sobald eine Entität von
 der anderen wissen muss um zu funktionieren.
 Abhängigkeiten können unterschiedliche Stärken und Ausprägungen haben.
 Je größer das Wissen über eine andere Entität ist, desto stärker ist die
 Abhängigkeit zu ihr.
 Muss also eine Entität von der konkreten Implementation einer anderen Entität
 wissen, so existiert eine starke Abhängigkeit und folglich eine enge Kopplung.
 Wird sich hingegen auf eine Schnittstelle zur Kommunikation geeinigt, existiert
 lediglich eine Abhängigkeit zu eben dieser Schnittstelle.
 Die Entitäten selbst sind lose miteinander gekoppelt.
\end_layout

\begin_layout Standard
Kopplung steht im Kontrast zu dem Begriff der Kohäsion.
 Kohäsion beschreibt ein Maß für den inneren Zusammenhalt einer Softwareentität.
 Hohe Kohäsion liegt dann vor, wenn eine Entität nur Funktionalitäten aufweist
 die einer einzelnen, wohldefinierten Aufgabe dienen.
 In anderen Worten: Eine Entität weist eine hohe Kohäsion auf, wenn ihre
 Elemente in einem engen Zusammenhang stehen.
\end_layout

\begin_layout Standard
Kohäsion beschreibt wie gut Entitäten aufgeteilt wurden.
 Kopplung beschreibt wie gut die Verbindungen zwischen Entitäten sind.
 Ein qualitativ hochwertiges Softwaredesign weist also hohe Kohäsion unter
 minimaler Kopplung auf.
 Im nächsten Abschnitt soll Inversion Of Control als Maßnahme präsentiert
 werden um lose Kopplung umzusetzen.
\end_layout

\begin_layout Section
Inversion of Control
\end_layout

\begin_layout Standard
Im ursprünglichen Sinne beschreibt Inversion Of Control nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson1988"

\end_inset

 lediglich die Charakteristik eines Frameworks: 
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

[...] methods defined by the user to tailor the framework will often be called
 from within the framework itself, rather than from the user's application
 code.
 The framework often plays the role of the main program in coordinating
 and sequencing application activity.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Frameworks diktieren die Architektur und den Kontrollfluss einer Anwendung.
 Sie definieren einen wiederverwendbaren Teil eines Softwaredesigns.
 Der vom Nutzer des Frameworks geschriebene, anwendungsspeziefische Code
 wird vom Framework aufgerufen.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 27"
key "Gamma1994"

\end_inset

) Der Nutzer gibt also die Kontrolle über den Fluss der Anwendung an das
 Framework.
 Die Kontrolle über den Anwendungsfluss ist somit invertiert: Es ist nicht
 der Nutzer der das Framework aufruft sondern das Framework den Code des
 Nutzers.
 Diese Tatsache wird oft als Hollywood-Prinzip bezeichnet: "Don't call us,
 we'll call you".
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2005"

\end_inset

)
\end_layout

\begin_layout Standard
Inversion Of Control ist eines der zentralen Merkmale welches Frameworks
 von Bibliotheken unterscheidet.
 Allein Inversion Of Control ermöglicht die Definition einer wiederverwendbaren
 Softwarearchitektur ohne die konkrete Implementation zu kennen.
 Das Framework ist lose mit der Implementation der eigentlichen Anwendung
 gekoppelt.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Wege und Entwurfsmuster um Inversion Of Control in unterschie
dlichen Aspekten einer Anwendung umzusetzen.
 In dieser Arbeit soll der Fokus auf der Umkehr der Kontrolle über Abhängikeiten
 liegen, mit dem Ziel lose Kopplung zu ermöglichen.
 Um diese spezielle Art von Inversion Of Control besser abzugrenzen, verwendet
 Fowler in seinem Artikel 
\begin_inset Quotes gld
\end_inset

Inversion of Control Containers and the Dependency Injection pattern
\begin_inset Quotes grd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Fowler2004"

\end_inset

 den Begriff Dependency Injection.
\end_layout

\begin_layout Section
Dependency Injection
\end_layout

\begin_layout Standard
Seemann gibt in 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 4"
key "Seemann2011"

\end_inset

 eine sehr vage Definitition des Begriffs Dependency Injection:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency Injection is a set of software design principles and patterns
 that enable us to develop loosely coupled code.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Wobei alles an dieser Aussage stimmt, lässt sich der Kern von Dependency
 Injection auf eine einzige Praktik reduzieren.
 James Shore beschreibt diese in 
\begin_inset CommandInset citation
LatexCommand cite
key "Shore2006"

\end_inset

 wie folgt:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Dependency injection means giving an object its instance variables.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Anstatt, dass sich das Objekt selbst um die Erstellung seiner Abhängigkeiten
 - seiner Intanzvariablen - kümmert, wird diese Aufgabe an einen Dritten
 übergeben.
 Die Verwendung des benötigten Objekts ist von der Konfiguration des Objekts
 getrennt.
 
\end_layout

\begin_layout Standard
Doch dies allein genügt noch nicht: Um lose Kopplung mittels Dependency
 Injection zu ermöglichen, müssen zudem eine Reihe von Prinzipien gewahrt
 werden.
 Diese wurden von Robert C.
 Martin geprägt und sind im allgemeinen als SOLID-Prinzipien bekannt.
\end_layout

\begin_layout Section
SOLID
\end_layout

\begin_layout Standard
SOLID ist ein Akronym, welches für die folgenden Prinzipien steht: Das Single-Re
sponsibility Prinzip, das Open/Closed Prinzip, das Liskov Substitution Prinzip,
 das Interface Segregation Prinzip und das Dependency-Inversion Prinzip.
 Es handelt sich um eine Sammlung von Richtlinien, die eine saubere Softwarearch
itektur ermöglichen sollen.
 An dieser Stelle wird auf eine ausführliche Beschreibung aller Prinzipien
 verzichtet.
 Es soll jedoch eine kurze Vorstellung der Prinzipien stattfinden und auf
 ihre Relevanz bei der Umsetzung von Dependency Injection eingegangen werden.
\end_layout

\begin_layout Subsection
Single-Responsibility Prinzip
\end_layout

\begin_layout Standard
Das Single-Responsibility Prinzip besagt, dass es niemals mehr als einen
 Grund geben sollte um eine Klasse zu ändern.
 Darauf Folgend wird eine Verantwortung in dem Zusammenhang als ein 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 definiert.
 Jedoch wurde 
\begin_inset Quotes gld
\end_inset

Grund zur Änderung
\begin_inset Quotes grd
\end_inset

 bewusst gewählt, da es auch legitim ist mehrere Verantwortlichkeiten in
 einer Klasse unterzubringen, wenn diese sich mit hoher Wahrscheinlichkeit
 gemeinsam ändern.
\end_layout

\begin_layout Standard
Wird das Single-Responsibility Prinzip gewahrt, so ist davon auszugehen,
 dass Klassen hohe Kohäsion aufweisen.
 Hohe Kohäsion ist jedoch nicht immer auf das Single-Responsibility Prinzip
 zurückzuführen.
 So kann eine Klasse hohe Kohäsion aufweisen, aber trotzdem mehrere Verantwortun
gen haben.
\end_layout

\begin_layout Standard
Dependency Injection wendet das Single-Responsibility Prinzip an, indem
 Klassen die Verantwortung über die Erstellung von Instanzen ihrer Abhängigkeite
n entzieht.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 24"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Open/Closed Prinzip
\end_layout

\begin_layout Standard
Software-Einheiten (Klassen, Methoden, Funktionen) sollen offen für Erweiterung
 aber geschlossen für Modifikation sein.
 
\begin_inset Quotes gld
\end_inset

Offen für Erweiterung
\begin_inset Quotes grd
\end_inset

 meint, dass es möglich sein soll, das Modul in seinem Umfang und Verhalten
 zu erweitern.
 
\begin_inset Quotes gld
\end_inset

Geschlossen für Modifikation
\begin_inset Quotes grd
\end_inset

 zum anderen bedeutet, dass zur Erweiterung keine Änderungen an dem Modul
 notwendig sind.
\end_layout

\begin_layout Standard
Abstraktion ermöglicht die Umsetzung des Open/Closed Prinzips.
 Wird von einer abstrakten Basisklasse geerbt, so ist es möglich das Verhalten
 der Abstraktion zu ändern, ohne die Abstraktion selbst zu manipulieren.
 Die Entwurfsmuster Strategy und Template Method sind Beispiele für das
 Open/Closed Prinzip.
\end_layout

\begin_layout Standard
Auch Dependency Injection setzt das Open/Closed Prinzip um, indem Abhängigkeiten
 lediglich in Form von Abstraktionen existieren.
 Dieses Prinzip ist eine Grundlage für lose Kopplung.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 106"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Liskov Substitution Prinzip
\end_layout

\begin_layout Standard
Das Liskov Substitution Prinzip beschreibt einer grundlegende Anforderung
 beim Einsatz von Vererbung: Untertypen einer Basisklasse sollen untereinander
 ersetzbar sein, ohne dabei die Verhalten des Programms selbst zu verändern.
 Das Programm selbst darf zu keinem Zeitpunkt einen Untertyp anders als
 ein anderen behandelt.
\end_layout

\begin_layout Standard
Dependency Injection ermöglicht es, dass Abhängigkeiten beliebig austauschbar
 sind, solange sie die nötige Abstraktion implementieren.
 Dies ist jedoch nur möglich, wenn das Liskov Substitution Prinzip gewahrt
 wird.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 9-10"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
Dieses Prinzip kommt besonders beim Unit-Testing zum Vorschein: Abhängigkeiten
 eines System Under Test können durch Test Doubles ersetzt werden, ohne
 das Verhalten des Systems selbst zu verändern.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S.19"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Interface Segregation Prinzip
\end_layout

\begin_layout Standard
Anstatt große (
\begin_inset Quotes gld
\end_inset

fat
\begin_inset Quotes grd
\end_inset

) Interfaces zu nutzen, sollten diese in mehrere schlanke Interfaces aufgeteilt
 werden.
 Die Aufteilung soll nach Methodengruppen erfolgen, entsprechend wie sie
 von Modulen, die das Interface nutzen gebraucht werden.
 So wird gewährleistet, dass andere Module nur von Abstraktionen mit hoher
 Interfacekohäsion abhängig sind.
 Auch wenn diese Abstraktionen von einem einzigen nicht-kohäsiven Modul
 implementiert werden.
\end_layout

\begin_layout Standard
Das Interface Segregation Prinzip scheint zunächst nicht mit Dependency
 Injection im Zusammenhang zu stehen.
 Es ist eher eine Richtlinie die bei der Anwendung von Dependency Injection
 gewahrt werden sollte.
 Wird eine Abhängigkeit von einem einzigen großen Interface repräsentiert,
 lenkt dieses Interface in die Richtung einer konkreten Implementation.
 Die Folge ist, dass Abhängigkeiten schwieriger auszutauschen sind und Interface
methoden implementieren, die sie eigentlich gar nicht benötigen um die Abhängigk
eit zu erfüllen.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 284"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Subsection
Dependency-Inversion Prinzip
\end_layout

\begin_layout Standard
Das Dependency-Inversion Prinzip besteht aus zwei Teilen:
\end_layout

\begin_layout Itemize
High-Level Module sollen nicht von Low-Level Modulen abhängig sein.
 Beide sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Itemize
Abstraktionen sollten nicht von Details abhängen.
 Details sollten von Abstraktionen abhängen.
\end_layout

\begin_layout Standard
Zum einen beschreibt das Dependency-Inversion Prinzip, dass die Architektur
 einer Anwendung in Schichten erfolgen sollte.
 Dabei soll die abstraktere, höher liegende Schicht ihre Abhängigkeiten
 in Form von Interfaces deklarieren.
 Die ihr untergeordnete Schicht wird basierend auf diesen Interfaces realisiert.
 Folglich sind die übergeordnete Schichten nicht von untergeordneten Schichten
 abhängig.
 Stattdessen sind untergeordnete Schichten von den abstrakten Interfaces
 in den übergeordneten Schichten abhängig.
 
\end_layout

\begin_layout Standard
Zum anderen beschreibt Martin eine weitere, allgemeinere Interpretation
 des Dependency-Inversion Prinzips:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Depend on abstractions.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
So sollen Klassen keine Referenzen zu anderen konkreten Klassen halten,
 von ihnen ableiten oder Methoden ihrer Basisklasse überschreiben.
 Diese Praxis wurde bereits von der Gang of Four in 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 17-18"
key "Gamma1994"

\end_inset

 mit folgenden Worten beschrieben:
\end_layout

\begin_layout Quote
\begin_inset Quotes gld
\end_inset

Program to an interface, not an implementation.
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Die Deklaration von Abhängigkeiten in Form von Abstraktionen ist die Grundlage
 um Inversion Of Control mittels Dependency Injection umzusetzen.
 Späte Bindung ermöglicht es, dass die konkrete Implementation auf diesem
 Wege erst zur Laufzeit bekannt sein muss.
\end_layout

\begin_layout Section
Umsetzung von Dependency Injection
\end_layout

\begin_layout Standard
Um zu erläutern wie die in den vorherigen Abschnitten erklärten Prinzipien
 bei der Umsetzung von Inversion of Control mittels Dependency Injection
 zusammenspielen, soll ein Beispiel herangezogen werden.
 Anhand dieses Beispiels sollen Patterns die im direkten Zusammenhang zu
 Dependency Injection stehen, beschrieben werden.
 Um das Beispiel so einfach wie möglich zu halten, wird hierfür eine Konsolenanw
endung in C# gewählt.
\end_layout

\begin_layout Subsection
Ausgangssituation
\end_layout

\begin_layout Standard
Eine gewünschte Funktionalität eines zu entwickelnden Spiels ist auszugeben,
 dass eine verwundbare Entität schaden genommen hat.
 Die in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Ausgangssituation"

\end_inset

 dargestellte Klasse DamageRenderer setzt diese Funktionalität um.
 Zunächst scheint alles zu stimmen: Die Klasse beschränkt ihre Verantwortung
 auf eine einzige Funktionalität, formatiert die Information in ein lesbares
 Format und gibt diese in der Konsole aus.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format("{0} was attacked and took {1} damage.", target,
 damage);         		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ausgangssituation des Beispiels
\begin_inset CommandInset label
LatexCommand label
name "fig:Ausgangssituation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Neue Anforderungen
\end_layout

\begin_layout Standard
Im Verlauf der Entwicklung des Spieles wird klar, dass das Spiel in verschiedene
n Sprachen veröffentlicht werden soll.
 Lokalisierung ist eine gängige Anforderung für jegliche Art von Software.
 Es wird mit dem Refactoring begonnen und die Klasse EnglishLocalization
 extrahiert.
 Abbildung
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Extraction"

\end_inset

 zeigt das Resultat.
 Die Verantwortung für die Lokalisierung wurde in eine allein dafür vorgesehene
 Klasse verschoben.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly EnglishLocalization localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Extraction der englischen Lokalisierung aus der existierenden Klasse
\begin_inset CommandInset label
LatexCommand label
name "fig:Extraction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Klasse DamageRenderer funktioniert immernoch wie im vorherigen Beispiel.
 Der Unterschied ist, dass DamageRenderer nun eine Abhängigkeit zu EnglishLocali
zation besitzt.
 Wie kann es nun ermöglicht werden, die englische Lokalisierung mit der
 Deutschen in Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Deutsche-Lokalisierung"

\end_inset

 auszutauchen? Das Problem hierbei ist, dass DamageRenderer eine konkrete
 Abhängigkeit zu EnglishLocalization hat.
 Mit anderen Worten, sie sind eng miteinander gekoppelt.
 Die Folge ist, dass EnglishLocalization nicht ohne DamageRenderer zu ändern
 durch GermanLocalization ausgetauscht werden kann.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class GermanLocalization
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Deutsche Lokalisierung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Deutsche-Lokalisierung"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Programming to an Interface
\end_layout

\begin_layout Standard
Um lose Kopplung umzusetzen darf keine Abhängigkeit zu einer konkreten Implement
ation existieren.
 Stattdessen muss sich auf eine Abstraktion als Abhängigkeit verlassen werden.
 In dem Beispiel in Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Depend-Abstractions"

\end_inset

 wird dies umgesetzt indem English- und GermanLocalization das Interface
 ILocalizationService implementieren.
 Dadurch, dass DamageRenderer nur noch eine Variable des Interfaces ILocalizatio
nService hält, lässt sich die konkrete Implementation austauschen.
 Dies ist jedoch immernoch nur möglich wenn DamageRenderer geändert wird.
 Der Grund dafür ist, dass EnglishLocalization im Konstruktor von DamageRenderer
 instanziiert wird.
 Somit ist DamageRenderer immernoch eng mit EnglishLocalization gekoppelt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public DamageRenderer()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		localization = new EnglishLocalization();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	string GetText();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EnglishLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} was attacked and took {1} damage.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class GermanLocalization : ILocalizationService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public string GetText()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return "{0} wurde angegriffen und hat {1} Schaden genommen.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von 
\begin_inset Quotes gld
\end_inset

Depend on abstractions
\begin_inset Quotes grd
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:Depend-Abstractions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Injecting Dependencies
\end_layout

\begin_layout Standard
Anstatt, dass sich eine Klasse selbst um die Auflösung ihrer Abhängigkeiten
 kümmert, sollte sie von Aussen mit diesen versorgt werden.
 Die Verantwortung über die Auflösung der Abhängigkeiten wird abgegeben.
 Die Klasse selbst macht lediglich deutlich, dass Sie ein Objekt benötigt,
 welches die abstrakten Bedürfnisse eines Interfaces umsetzt.
 In diesem Fall, die eines ILocalizationService.
 Die Klassen sind durch Dependency Injection lose miteinander gekoppelt.
 Dependency Injection lässt sich auf unterschiedlichen Wegen umsetzten.
 Die gebräuchlichsten sind Constructor Injection und Property Injection.
\end_layout

\begin_layout Subsubsection
Constructor Injection
\end_layout

\begin_layout Standard
Die Abhängigkeit wird über den Konstruktor bei der Instanziierung des Objektes
 bereitgestellt.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Constructor"

\end_inset

 wird Constructor Injection in der DamageRenderer angewandt.
 Eine Instanz von ILocalizationService muss bei Aufruf des Konstruktors
 bereitgestellt werden.
\end_layout

\begin_layout Standard
Constructor Injection stellt sicher, dass die nötige Abhängigkeit auch tatsächli
ch verfügbar ist, indem eine Instanziierung des Objektes (ein Konstruktoraufruf)
 ohne sie nicht möglich ist.
 Damit wird erzwungen, dass der gesamte Abhängigkeitsgraph aufgebaut wird,
 bevor die Klasse genutzt werden kann.
 Eine Guard Clause stellt sicher, dass nicht null als Argument übergeben
 wird.
 Constructor Injection sollte in den meisten Fällen angewand werden, denn
 in den meisten Fällen ist die benötigte Abhängigkeit zwingend notwendig.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private readonly ILocalizationService localization;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public DamageRenderer(ILocalizationService localization)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		this.localization = localization;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var output = string.Format(localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Constructor Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Constructor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Property Injection
\end_layout

\begin_layout Standard
Ist eine Abhängigkeit optional, kann die Klasse über ein Property mit einer
 Instanz dieser Abhängigkeit versorgt werden.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Beispiel-von-Property"

\end_inset

 zeigt die Umsetzung von Property Injection anhand des gewählten Beispiels.
 Die Klasse stellt ein öffentlich setzbares Property vom Typ der Abhängigkeit
 bereit.
 In dem gezeigten Beispiel ist Property Injection wenig angebracht, da die
 Abhängigkeit notwendig ist.
 Man könnte jedoch, falls kein LocalizationService bereitgestellt wird,
 beispielsweise im Getter eine Instanz von EnglishLocalization erstellen
 und diese so als Local Default verwenden.
\end_layout

\begin_layout Standard
Mit Properties lässt sich so das Open-Closed Principle umsetzen: Sie bieten
 eine optionale Abhängigkeit zur Erweiterung der Funktionalität einer Klasse
 ohne dabei die Klasse selbst zu modifizieren.
\end_layout

\begin_layout Standard
Ein Nachteil ist, dass andere Klassen zu jeder Zeit Veränderungen an dem
 Property vornehmen können.
 Aus diesem Grund wird Property Injection in manchen Kreisen kritisiert,
 da es die Datenkapselung bricht.
\end_layout

\begin_layout Standard
Oft hindert auch die Verwendung eines Frameworks die Verwendung von Constructor
 Injection, zum Beispiel, wenn dieses Framework vorscheibt, dass Klassen
 einen Default Constructor haben.
 In diesem Fall kann auch auf Property Injection zurückgegriffen werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class DamageRenderer : IDamageRenderer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ILocalizationService Localization { private get; set; }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public void Render(string target, int damage)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (localization == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			throw new ArgumentNullException("localization");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		var output = string.Format(Localization.GetText(), target, damage);
\end_layout

\begin_layout Plain Layout

		System.Console.WriteLine(output);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel von Property Injection
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-von-Property"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Composition Root
\end_layout

\begin_layout Standard
In den letzten Abschnitten wurde verdeutlicht, dass Dependency Injection
 es verlangt, die Verantwortung über die Auflösung der Abhängigkeiten abzugeben.
 Es wurde jedoch nicht beschrieben, an wen diese Verantwortung übertragen
 werden soll.
 Die Antwort ergibt sich, wenn man Dependency Injection konsequent umsetzt:
 Abhängigkeiten werden in der Objekthierarchie nach oben gereicht, bis dies
 nicht mehr möglich ist.
 Die Auflösung der Abhängigkeiten sollte also so nah wie möglich beim Einstiegsp
unkt der Applikation geschehen.
 Soweit möglich sollte die Initialisierungslogik aller Objekte an diesem
 zentralen Ort umgesetzt werden.
 Dieser zentrale Ort wird als Composition Root bezeichnet.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 76-77"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
In einer Konsolenapplikation, wie dem gezeigten Beispiel, erfüllt die Main-Metho
de die Vorraussetzungen für einen Composition Root: Sie ist der Einstiegspunkt
 in die Anwendung und zugleich der höchste Punkt in der Objekthierarchie.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CompositionRoot"

\end_inset

 zeigt den Composition Root des gewählten Beispiels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class CompositionRoot
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void Main(string[] args)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		var localization = new GermanLocalization();
\end_layout

\begin_layout Plain Layout

		var renderer = new DamageRenderer(localization);
\end_layout

\begin_layout Plain Layout

		renderer.Render("Mario", 10);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Die Main-Methode erfüllt die Eigenschaften des Composition Roots in einer
 Konsolenanwendung
\begin_inset CommandInset label
LatexCommand label
name "fig:CompositionRoot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Composition Root wird die Konfiguration der Anwendung vorgenommen.
 Es ist der einzige Ort an dem die konkreten Instanzen von Objekten bekannt
 sein müssen.
 Er sollte unabhängig von dem Rest der Anwendung kompilierbar sein und sich
 deswegen in einem seperaten Assembly befinden.
\end_layout

\begin_layout Subsection
Stable and volatile Dependencies
\end_layout

\begin_layout Standard
Nicht jede Abhängigkeit muss lose mit der Anwendung gekoppelt werden.
 Tatsächlich ist dies für bestimmte, feste Abhängigkeiten unnötig.
 Wichtig ist jedoch unterscheiden zu können, wann eine Abhängigkeit als
 fest (stable) und wann als unbeständig (volatile) angesehen werden sollte.
 
\end_layout

\begin_layout Standard
Kann davon ausgegangen werden, dass ein bereits existierendes Modul niemals
 ausgetauscht oder verändert wird, so kann es als eine feste Abängigkeit
 angesehen werden.
 Ein Beispiel hierfür sind die meisten Module der Base Class Library, da
 sie fester Bestandteil des .NET Frameworks sind.
 Ob ein Modul als feste Abhängigkeit angesehen werden kann, lässt sich anhand
 der folgenden Kriterien beurteilen:
\end_layout

\begin_layout Itemize
Die Klasse oder das Modul existiert bereits.
\end_layout

\begin_layout Itemize
Es ist zu erwarten ist, dass neue Versionen keine Änderungen enthalten werden
 die Auswirkungen auf den Programmcode haben werden.
\end_layout

\begin_layout Itemize
Das Modul lediglich deterministische Algorithmen beinhaltet.
\end_layout

\begin_layout Itemize
Es nicht zu erwarten ist, dass das Modul jemals durch ein anderes ausgetauscht
 wird.
\end_layout

\begin_layout Standard
Den Gegensatz zu festen Abhängigkeiten bilden Klassen und Module bei denen
 es absehbar ist, dass sie sich verändern werden.
 Ist eine Abhängigkeit unbeständig, sollte sie lose mit dem Rest der Anwendung
 gekoppelt werden, um ihre Austauschbarkeit zu ermöglichen.
 Eine Abhängigkeit wird als unbeständig angesehen, wenn eines der folgenden
 Kriterien auf sie zutrifft:
\end_layout

\begin_layout Itemize
Durch die Abhängigkeit wird eine bestimmte Laufzeitumgebung vorrausgesetzt.
 
\end_layout

\begin_layout Itemize
Die Abhängigkeit existiert noch nicht.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nutzt eine thrid-party Library, die nicht auf allen Systemen
 vorhanden ist.
\end_layout

\begin_layout Itemize
Die Abhängigkeit nichtdeterministisches Verhalten aufweist.
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
after "S. 23-24"
key "Seemann2011"

\end_inset

)
\end_layout

\begin_layout Standard
Ein Beispiel für eine in der Base Class Library vorhandene Klasse die als
 unbeständige Abhängigkeit behandelt werden sollte, ist System.Random.
 Die Klasse weist nichtdeterministisches Verhalten auf, was sich besonders
 auf die Testbarkeit der Anwendung auswirkt.
\end_layout

\begin_layout Section
Resultierende Vorteile und Möglichkeiten
\end_layout

\begin_layout Standard
Programming to an interface ist eine Vorraussetzung um lose Kopplung über
 Dependency Injection umzusetzen
\end_layout

\begin_layout Chapter
Komposition als Architekturgrundlage
\end_layout

\begin_layout Section
Klassischer objektorientierter Ansatz 
\end_layout

\begin_layout Itemize
Spielobjekte werden von einer Vererbungshierarchie abgeleitet
\end_layout

\begin_layout Itemize
Alle Objekte werden von einer Basisklasse, meistens GameObject, abgeleitet
\end_layout

\begin_layout Itemize
Basisklasse enthält Funktionalität die für alle Klassen notwendig ist (z.b.
 Serialisierung)
\end_layout

\begin_layout Itemize
Mit Wachstum des Projektes wird die Hierarchie immer tiefer und weiter
\end_layout

\begin_layout Itemize
Eine Monolytische Klassenhierarchie entsteht und Probleme folgen (Doesn't
 scale)
\end_layout

\begin_layout Itemize
Es kann nur ein Merkmal als Basis für die Vererbungshierarchie gewählt werden
\end_layout

\begin_layout Itemize
An Axis has to be picked to set the hierarchy, once this axis changes an
 object needs behaviour of two different classes
\end_layout

\begin_layout Itemize
Beispiel:
\end_layout

\begin_layout Itemize
Geteilte Funktionalitäten müssen in der Hierarchie nach oben verschoben
 werden, obwohl sie nicht von allen abgeleiten Klassen benötigt werden
\end_layout

\begin_layout Itemize
Das Problem kann in einigen Sprachen auch durch multiple Vererbung gelöst
 werden, welche aber zu einem Deadly Diamond führen kann
\end_layout

\begin_layout Itemize
Lösung: Komposition und Aggregation anstelle von Vererbung
\end_layout

\begin_deeper
\begin_layout Itemize
compose: object owns other objects, they get destroyed once the owner is
 destroyed 
\end_layout

\begin_layout Itemize
aggregate: object is linked to other object, not destroyed when owner is
 destroyed 
\end_layout

\end_deeper
\begin_layout Itemize
not to be confused with: “In business software, there’s a “Component” design
 pattern that describes decoupled services that communicate over the web.”
\end_layout

\begin_layout Section
Komponentenbasierte Architektur von Unity3D
\end_layout

\begin_layout Itemize
Unity implementiert eine komponentenbasierte Game Object Architektur
\end_layout

\begin_layout Itemize
has-a anstelle von is-a
\end_layout

\begin_layout Itemize
Purpose: “Allow a single entity to span multiple domains without coupling
 the domains to each other.”
\end_layout

\begin_layout Itemize
SpielObjekte werden mit Komponenten dekoriert
\end_layout

\begin_layout Itemize
Komponenten sollen eine Funktionalität kapseln
\end_layout

\begin_layout Itemize
Keeps different domains in a program isolated from each other 
\end_layout

\begin_layout Itemize
Components contain Data and Behaviour
\end_layout

\begin_layout Itemize
data can be exposed to the editor and then be edited by the artists
\end_layout

\begin_layout Itemize
GameObjects sind Objekte die eine variable Kombination von MonoBehaviours
 besitzen (container of components)
\end_layout

\begin_layout Itemize
Components are reusable plugins that can be plugged into the socket on the
 entity
\end_layout

\begin_layout Itemize
Scripte müssen Komponenten sein.
 Unity3D insists that scripts you write are components.
 Components attach to objects, and the objects belong to a scene or prefab
\end_layout

\begin_layout Itemize
Code can be reused because classes can own an instance of the same Component
 
\end_layout

\begin_layout Itemize
Some Component will need to communicate to others, but communication is
 restricted to those cases.
\end_layout

\begin_layout Itemize
The Game Object is completely decoupled from it’s components 
\end_layout

\begin_layout Itemize
It is possible to add and remove components without the enitiy even knowing
\end_layout

\begin_layout Itemize
Game Objects can be composed in the unity engine tool by designers
\end_layout

\begin_layout Section
Objektlebenszyklus
\end_layout

\begin_layout Itemize
In Unity gibt es keine Main Methode
\end_layout

\begin_layout Itemize
Die Kontrolle über die Komposition von Objekten ist bereits invertiert,
 Sie liegt in den Händen von Unity
\end_layout

\begin_layout Itemize
Es gibt keine Konstruktoren
\end_layout

\begin_layout Itemize
Die Instanziierung und Ausführung von Spielobjekten und Komponenten wird
 von Unity übernommen
\end_layout

\begin_layout Itemize
Soweit nicht anders spezifiziert, erfolgt die Aufrufreihenfolge von Scripten
 zufällig nach der Reihenfolge in der sie geladen werden
\end_layout

\begin_layout Itemize
Es ist möglich, eine Reihenfolge in den Script Execution Order settings
 anzugeben
\end_layout

\begin_layout Itemize
Aufgrund der fehlender Main und Constructors ist es nicht möglich Scripte
 von aussen mit ihren Abhängigkeiten zu versorgen
\end_layout

\begin_layout Itemize
Aus diesem Grund stellt unity wege bereit, wie das Script seine Abhängigkeiten
 auflösen kann
\end_layout

\begin_layout Section
Kommunikation und Abhängigkeiten
\end_layout

\begin_layout Standard
Im Idealfall sind MonoBehaviours komplett unabhängig voneinander.
 Dennoch sind Sie Teile eines größeren Ganzen und müssen somit kommunizieren
 und interagieren.
 Oft beschränkt sich diese Kommunikation auf Komponenten des selben GameObjects.
 Es kommt jedoch auch vor, dass ein MonoBehaviour mit einem MonoBehaviour
 eines anderen GameObjects kommunizieren muss.
 Folglich wird zwischen zwei Arten der Kommunikation unterschieden:
\end_layout

\begin_layout Standard
Die Intra-Objekt-Kommunikation erfolgt unter MonoBehaviours des selben GameObjec
ts oder Children von diesem.
\end_layout

\begin_layout Standard
Inter-Objekt-Kommunikation beschreibt die Kommunikation zu anderen GameObjetcts
 die ansonsten in keiner Relation zueinander stehen.
\end_layout

\begin_layout Standard
In beiden Fällen kann die Kommunikation direkt oder indirekt erfolgen.
 Bei direkter Kommunikation ist es notwendig, dass entweder Sender oder
 Empfänger einander kennen.
 Eines der Objekte muss also eine Referenz zu dem anderen halten.
 Kommunikation erfolgt indirekt, wenn Sie über ein drittes Objekt \SpecialChar \nobreakdash-
 einem
 Vermittler \SpecialChar \nobreakdash-
 stattfindet.
 In jedem Fall wird eine Referenz auf ein weiteres Objekt benötigt.
 In Unity gibt es eine Vielzahl von Möglichkeiten wie diese Abhängigkeiten
 aufgelöst werden können.
 Diese sollen an dieser Stelle genauer beschrieben werden.
\end_layout

\begin_layout Subsection
Referenzieren von anderen MonoBehaviours
\end_layout

\begin_layout Standard
Unity bietet unterschiedliche Möglichkeiten um Zugriff auf unterschiedliche
 Objekte zu erlangen.
 So werden zahlreiche Game Object Queries für die Inter-Objekt-Kommunikation
 bereit gestellt.
 Um andere Komponenten referenzieren zu können gibt es Component Queries.
 Desweiteren gibt es auch komponentenunabhängige Kommunikation über Events.
\end_layout

\begin_layout Subsubsection
SerializeField
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[SerializeField]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SerializeField ist ein Attribut, das ermöglicht private Member einer Komponente
 zu serialisieren und somit im Inspektor zu setzen.
 Setzbare Datentypen sind primitive Datentypen wie int, float, bool und
 in Unity eingebaute Datentypen wie Vector, Quaternion und Color, sowie
 Strings, Enums und Structs.
 Desweiteren ist es möglich Referenzen zu Klassen und Objekten durch drag-and-dr
op im Editor zu setzen.
 Dabei ist zu beachten, dass diese Objekte vom Typ UnityEngine.Object ableiten
 müssen.
 Es ist also möglich andere Komponenten oder Spielobjekte zu referenzieren.
 Jedoch ist es aufgrund dieser Limitierung nicht möglich, Interfaces im
 Editor zugänglich zu machen.
 Neben Variablen mit dem SerializeField-Attribut werden Variablen, die mit
 dem Zugriffsmodifizierer public gekennzeichnet wurden im Editor zugänglich
 gemacht.
 Dies ist jedoch ausdrücklich nicht zu empfehlen, da so die Datenkapselung
 des Objektes gebrochen wird.
\end_layout

\begin_layout Standard
Ist bereits vor Ausführung des Spiels bekannt welche Referenzen benötigt
 werden, sollten diese wenn möglich über ein SerializeField aufgelöst werden.
 Um sicherzugehen, dass die Referenz im Editor aufgelöst wurde, ist es ratsam
 einen Guard Clause in die OnValidate-Funktion der Komponente hinzuzufügen.
 Abb.
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SerializeField"

\end_inset

 verdeutlicht dies anhand eines einfachen Beispiels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.UI;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Assertions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SomeBehaviour : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	[SerializeField]
\end_layout

\begin_layout Plain Layout

	private Image myImage;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void OnValidate()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Assert.IsNotNull(myImage);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SerializeField mit Guard Clause in OnValidate
\begin_inset CommandInset label
LatexCommand label
name "fig:SerializeField"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn erst zur Laufzeit bestimmt werden kann welches das benötigte Objekt
 ist, zum Beispiel wenn sich die Abhängigkeit ausserhalb eines instanziierten
 Prefab befindet, so muss auf eine andere Methode der Referenzierung zurückgegri
ffen werden.
\end_layout

\begin_layout Subsubsection*
GetComponent
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponent(Type type);
\end_layout

\begin_layout Plain Layout

public T GetComponent();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
GetComponent ermöglicht es, auf andere Komponenten des selben GameObjects
 zuzugreifen.
 Ist keine Komponente des gewünschten Typs vorhanden, wird null zurückgegeben.
 Dies kann verhindert werden, indem man dem Script das Attribut RequireComponent
 hinzufügt.
 RequireComponent bewirkt, dass die benötigte Komponente automatisch an
 das GameObject angefügt wird.
 Um auf Komponenten von anderen GameObjects in der über- und untergeordneten
 Hierarchieebene zugreifen zu können, werden zusätzlich folgende Methoden
 bereit gestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Component GetComponentInChildren(Type t);
\end_layout

\begin_layout Plain Layout

public Component GetComponentInParent(Type t);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle GetComponent-Methoden spezifizieren einen Typparameter T als Suchkriterium.
 Da T nicht weiter \SpecialChar \nobreakdash-
 zum Beispiel auf UnityEngine.Object \SpecialChar \nobreakdash-
 eingeschränkt wird,
 ist es Möglich, anstatt konkreten Komponenten auch Komponenten anhand eines
 Interfaces zu finden.
\end_layout

\begin_layout Standard
Beim Verwenden von GetComponent wird implizit eine Anordnung in der Objekthierar
chie festgelegt.
 Wird zum Beispiel eine benötigte Komponente in ein Child-GameObject verschoben,
 ist das Spiel ohne Änderung im Programmcode nicht mehr lauffähig.
 Aus diesem Grund sollte GetComponent nur in Ausnahmefällen, wenn Beispielsweise
 eine Komponete zur Laufzeit hinzugefügt wird, verwendet werden.
 
\end_layout

\begin_layout Subsubsection*
String-Based Find Functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static GameObject Find(string name);
\end_layout

\begin_layout Plain Layout

public static GameObject FindWithTag(string tag);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unity's Find Functions sind klassische Game Object Queries zur Inter-Objekt
 Kommunikation.
 Das gewünschte Spielobjekt wird auf Basis eines Strings als Suchkriterium
 zurückgegeben.
 Dieser String kann entweder der Name oder ein Tag sein.
 Die Funktionen unterscheiden sich im Verhalten, falls kein GameObject mit
 dem passenden Namen gefunden wird: Wird kein Objekt mit dem passenden Namen
 gefunden, gibt Find null zurück.
 Wird kein Objekt mit dem passenden Tag gefunden, wirft FindWithTag eine
 UnityException.
 Nachdem das gesuchte Objekt gefunden wurde, muss die gewünschte Komponente
 mittels GetComponent ausfindig gemacht werden.
\end_layout

\begin_layout Standard
Generell ist von der Nutzung beider Funktionen abzuraten, da sie nicht gewährlei
sten, dass das gesuchte GameObject tatsächlich auffindbar ist.
 Es wird sich darauf verlassen, dass ein GameObject mit bestimmten Namen/Tag
 in der Szene existiert und bestimmte Komponenten an diesem vorhanden sind.
 Es gibt somit viel Raum für Fehlkonfiguration.
\end_layout

\begin_layout Subsubsection*
FindObjectOfType
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static Object FindObjectOfType(Type type);
\end_layout

\begin_layout Plain Layout

public static T FindObjectOfType<T>() where T : Object;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im Gegensatz zu den anderen Find Functions ist FindObjectOfType typsicher.
 Es wird gewährt, dass eine in der Szene aktive Instanz eines bestimmten
 Typs erhalten wird.
 Anzumerken ist, dass der gewünschte Typ von UnityEngine.Object abgeleitet
 sein muss.
 Somit funktioniert auch FindObjectOfType nicht mit Interfaces.
 Die generische Variante von FindObjectOfType ist anderen Find Funktionen
 vorzuziehen, da sie direkt die Instanz der gesuchten Komponente vom Typ
 T als Rückgabewert liefert.
 Es ist also nicht nötig GetComponent zu nutzen.
\end_layout

\begin_layout Standard
In der Dokumentation der Funktion wird angemerkt, dass FindObjectOfType
 sehr langsam ist.
 Sie sollte daher nicht jeden Frame genutzt werden.
 Als Alternative wird das Singleton Pattern vorgeschlagen.
\end_layout

\begin_layout Subsubsection*
Singleton und Statics
\end_layout

\begin_layout Standard
Singletons stellen sicher, dass nur eine Instanz einer Klasse gibt, auf
 welche ein globaler Zugriffspunkt existiert.
 Hier mit aufgeführt, weil sie in Unitz alternativ zu FindObjectOfType genutzt
 werden können, mit der Beschränkung, dass sie auf eine Instanz limitiert
 sind.
 Abb.
 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Singleton"

\end_inset

 zeigt eine mögliche Implementation eines Singletons welches von MonoBehaviour
 ableitet.
 Die Singletonkomponente muss lediglich einem Spielobjekt in der Szene hinzugefü
gt werden um es global verfügbar zu machen.
 Der Zugriff auf die Singleton-Komponente erfolgt über die statische Variable
 Instance.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Singleton : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static Singleton Instance { get; private set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void Awake ()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (Instance == null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Instance = this;
\end_layout

\begin_layout Plain Layout

			DontDestroyOnLoad (this);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Destroy (gameObject);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation des Singleton Patterns in Form eines MonoBehaviours
\begin_inset CommandInset label
LatexCommand label
name "fig:Singleton"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Form des Singletons erlaubt dem Objekt die Funktionalitäten eines
 MonoBehaviours - wie dem Update Loop - zu nutzen.
 Sollten diese Funktionalitäten nicht notwendig sein, oder soll der Singleton
 Lazy intitalisiert werden, kann auch ein klassischer Singleton nach GoF
 verwendet werden.
 Sollte gar keine Vererbung notwendig sein, gibt es oft jedoch gar keinen
 Grund ein Singleton zu implementierten.
 Stattdessen kann eine statische Klasse verwendet werden.
\end_layout

\begin_layout Standard
An dieser Stelle sei bereits anzumerken, dass Singletons aus vielen Gründen
 als Anti-Pattern angesehen werden.
 Eine der Ursachen dafür ist, dass sie einen Globalen Zustand einführen.
 Gleiches gilt für statische Klassen.
\end_layout

\begin_layout Subsection
Events und Messages
\end_layout

\begin_layout Standard
Alternativ kann die Kommunikation zwischen Objekten auch über Events erfolgen.
 Events können im Unterschied zu Methodenaufrufen keinen oder mehrere Empfänger
 haben.
 Events sind eine Umsetzung des Observer Patterns.
 Die Klasse die den Event auslöst wird als Publisher und die Klassen, die
 das Ereignis behandeln als Subscriber bezeichnet.
 Ein typischer Anwendungsfall für Events sind UI-Elemente wie Buttons, Slider
 und Toggles.
 Mit Events kann nichtsdestotrotz das gleiche Ergebnis wie mit Referenzierung
 und Methodenaufruf erzielt werden.
 Unity und C# bieten mehrere Möglichkeiten um die Kommunikation mittels
 Events umzusetzen.
 In dieser Arbeit wird davon abgesehen, darzustellen wie C# Events implementiert
 werden, da Sie ohne Mediation oder Statics nicht das Problem der Referenzierung
 lösen.
 Wird ein gewöhnlicher C# Event als Kommunikationskanal gewählt, so muss
 der Empfänger über einen der im letzten Abschnitt beschriebenen Wege Zugriff
 auf den Sender erhalten.
 Um diese Limitierung zu umgehen bietet Unity ab der Version 4.6 eine eigene
 Implementierung von Events.
\end_layout

\begin_layout Subsubsection*
UnityEvent (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public abstract class UnityEvent<T,...,Tn>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents ermöglichen das Setzen von Callbacks über das Editorfenster.
 Auf diese Weise sind Sender und Empfänger komplett voneinander entkoppelt.
 Zudem bieten sie zusätzlich nahezu identische Funktionalität wie klassische
 C# Events.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEventCode"

\end_inset

 zeigt die Verwendung eines nicht generischen UnityEvents ohne Parameter.
 Die Publisher Komponente löst den Event in der Start-Methode aus.
 Ein Subscriber benötigt lediglich eine öffentliche Methode mit der passenden
 Signatur.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.Events;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public UnityEvent myEvent;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (myEvent != null)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			myEvent.Invoke();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Recieved");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Beispiel eines Publishers und Subscribers unter Verwendung eines UnityEvents
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEventCode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist, dass bis jetzt noch keine Verbindung zwischen Publisher und
 Subscriber existiert.
 Diese kann im Editor gesetzt werden (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:UnityEvent"

\end_inset

).
 Somit wird es ohne weiteren Programmcode möglich zu bestimmen wer auf ein
 Event reagieren soll.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/UnityEvent.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Hinzufügen einer Callback-Methode für einen UnityEvent im Editor
\begin_inset CommandInset label
LatexCommand label
name "fig:UnityEvent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
UnityEvents bieten somit eine Möglichkeit Sender von Empfänger komplett
 zu entkoppeln.
 Andererseits gibt es auch hier viel Raum zur Fehlkonfiguration.
 Es ist nicht im Programmcode ersichtlich ob und wer die Subscriber eines
 Events sind.
 Genauso wenig ist ersichtlich ob eine als öffentlich gekennzeichnete Methode
 als Callback genutzt wird oder nicht.
 Oft werden Methoden und Events auf die keine Referenzen im Programmcode
 existieren einfach gelöscht.
\end_layout

\begin_layout Standard
Events sind ein geeignetes Mittel um optionale Abhängigkeiten aufzulösen.
 Ist eine Abhängigkeit jedoch zwingend erforderlich, sollte zu einer anderen
 Möglichkeit gegriffen werden.
\end_layout

\begin_layout Subsubsection*
Sending Messages
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void SendMessage(string methodName, object value = null, SendMessageOptio
ns options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void SendMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, object parameter = null,
 SendMessageOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\begin_layout Plain Layout

public void BroadcastMessage(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, SendMessageOptions options);
\end_layout

\begin_layout Plain Layout

public void SendMessageUpwards(string methodName, object value = null, SendMessa
geOptions options = SendMessageOptions.RequireReceiver);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
MonoBehaviours bieten die Funktionalität untereinander mittels Messages
 zu kommunizieren.
 SendMessage ermöglicht die Kommunikation zwischen Komponenten innerhalb
 eines Spielobjekts.
 BroadcastMessage sendet eine Message an das gewählte Spielobjekt und dessen
 Children.
 SendMessageUpwards sendet die Nachricht an alle Spielobjekte die sich dem
 gewählten Spielobjekt übergeordnet in der Szene-Hierarchie befinden.
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:SendMessage"

\end_inset

 zeigt die Verwendung von SendMessage anhand von zwei Komponenten, die sich
 am gleichen Spielobjekt befinden.
 Der Publisher eines Events spezifiziert die Callback-Methode mittels eines
 Strings.
 Dieser String repräsentiert den Namen der gesuchten Callback-Methode.
 Der Zugriffsmodifizierer der Callback-Methode ist dabei nicht relevant.
 Sie kann wie im Beispiel auch als private deklariert werden.
 Durch den Aufzählungstyp SendMessageOptions ist es möglich zu spezifizeren,
 ob ein Empfänger zwingend erforderlich ist.
 Wenn dieser als erforderlich gekennzeichnet wurde und dennoch kein Empfänger
 gefunden wird, wirft SendMessage eine Exception zur Laufzeit.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessagePublisher : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		SendMessage("Receive");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MessageSubscriber : MonoBehaviour
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwendung von SendMessage
\begin_inset CommandInset label
LatexCommand label
name "fig:SendMessage"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
SendMessage verwendet 
\begin_inset Quotes gld
\end_inset

Magic Strings
\begin_inset Quotes grd
\end_inset

 zur Identifikation der Callback-Methode.
 Refactorings der Methodennamen haben keinen Einfluss.
 Auch hier ist es nicht ersichtlich, dass die private Methode als Callback
 genutzt wird.
 Nach dem YAGNI Prinzip werden nicht verwendete private Methode einfach
 gelöscht.
 SendMessage legt implitzit eine Anordnung in der Hierarchie fest.
\end_layout

\begin_layout Standard
Aus diesen Gründen ist der Nutzung von SendMessage generell abzuraten.
 Besonders, da mit der Unity Version 4.6 ein neues Messaging System als Ersatz
 für SendMessage vorgestellt wurde.
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.unity3d.com/Manual/MessagingSystem.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
UnityEngine.EventSystems (Unity 4.6+)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static bool Execute(GameObject target, EventSystems.BaseEventData
 eventData, EventFunction<T> functor);
\end_layout

\begin_layout Plain Layout

public static GameObject ExecuteHierarchy(GameObject root, EventSystems.BaseEvent
Data eventData, EventFunction<T> callbackFunction);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Event System wurde in Verbindung mit uGUI in Unity 4.6 eingeführt.
 Es wird dazu verwendet um Events bei Nutzereingaben zu senden.
 Man kann es jedoch auch für benutzerdefinierte Events verwenden.
 Anstelle eines Strings wird ein Interface verwendet um eine Komponente
 zu kennzeichnen, die eine Callback-Funktion für ein bestimmtes Event implementi
eren.
 Events können mittels ExecuteHierarchy in der Objekthierarchie nach oben,
 jedoch nicht nach unten, gesendet werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using UnityEngine;
\end_layout

\begin_layout Plain Layout

using UnityEngine.EventSystems;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventPublisher : MonoBehaviour 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private void Start()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		ExecuteEvents.Execute<IEventTarget>(this.gameObject, null, (target, data)
 => target.Receive());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IEventTarget : IEventSystemHandler
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	void Receive();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class EventSubscriber : MonoBehaviour, IEventTarget 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public void Receive()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Debug.Log("Received");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verwenden von UnityEngine.EventSystems
\end_layout

\end_inset


\end_layout

\end_inset

Das neue EventSystem ist ein typsicherer Ansatz Events an Komponenten in
 der Szenehierarchie zu senden.
 Ohne das Spielobjekt der Empfängerkomponente zu kennen, kann jedoch nur
 an das eigene oder direkte parent Spielobjekte gesendet werden.
 
\end_layout

\begin_layout Section
Wertung und Konsequenzen
\end_layout

\begin_layout Standard
Unitys Komponentenbasierte Architektur hilft dabei Klassen mit nur einer
 Verantwortung zu erstellen.
 Spielobjekte lassen sich durch Komposition aus Komponenten in der Szenehierarch
ie arrangieren.
 Sobald Komponenten jedoch Kommunizieren müssen oder Abhängigkeiten zu anderen
 Objekten haben, muss sich für ein Kommunikationsmittel entschieden werden.
 Unity stellt unterschiedliche Wege zur Kommunikation mit anderen Komponenten
 bereit.
 Eine Sache haben jedoch alle Methoden miteinander gemeinsam: Das andere
 Objekt muss eine Komponente sein.
 Dies führt dazu, dass Objekte nur aus dem Grund der Kommunikation von MonoBehav
iour ableiten.
 
\end_layout

\begin_layout Itemize
Scripts about never affect just one object.
 Sometimes they do not affect an object at all
\end_layout

\begin_layout Itemize
other objects can only be created within components
\end_layout

\begin_layout Itemize
unless they are a singleton
\end_layout

\begin_layout Itemize
No way to keep state (data) independent of a game object
\end_layout

\begin_layout Itemize
This forces Developers to Create “Manager” GameObjects
\end_layout

\begin_layout Itemize
Polymorphismus kann trotzdem genutzt werden
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/1799_Diplomarbeit_Schnitt.jpg
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Dies ist ein sehr langer Text.
 Hier sollte das Bild so beschrieben werden, dass man auch eine Ahnung vom
 Bild hat, wenn man nur den Bilduntertitel liest.
 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Kurztitel der nur in Abb.
 Verzeichnis angezeigt wird
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Testbild"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Text verweise ich nun auf das eben genannte Bild (Vgl.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Testbild"

\end_inset

).
 Dazu muss im Bild eine sog.
 Marke eingefügt werden (in diesem Fall: fig:Testbild).
 Als Bildbreite ist in diesem Dokument 15cm gewählt.
 Dies sieht dann sehr passabel im Fließtext aus.
 Versucht bei den Breiten der Bilder einheitlich zu bleiben.
 Also 15cm und 10cm zum Beispiel.
 Dies hilft dem Leser und unterbricht nicht dauernd im Lesefluss.
 Im Fließtext umschlossene Bilder sind weniger gern gesehen in Bachelorarbeiten,
 aber hier auch wieder den Prof.
 fragen.
\end_layout

\begin_layout Subsection
Tabelle mit Untertitel
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="3cm">
<column alignment="left" valignment="top" width="3cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
titelzeile
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Titel über zwei Spalten
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aufzählungen
\end_layout

\begin_layout Itemize
1
\end_layout

\begin_layout Itemize
2
\end_layout

\begin_layout Itemize
3
\end_layout

\begin_layout Itemize
4
\end_layout

\begin_layout Plain Layout
gehen nur bei festgelegter Zeilenbreite
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Auch Absätze gehen nur bei festgelegter Spaltenbreite.
\end_layout

\begin_layout Plain Layout
Wie man hier sieht!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zwei Zeilen zusammenfassen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Genau wie bei Bildern sollte auch der Tabellenuntertitel die Tabelle grob
 beschreiben 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Dies ist wieder der Kurztitel zur Tabelle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Ausseinandersetzung mit Paradigmen
\end_layout

\begin_layout Section
SOLID, Inversion Of Control, DI, DIContainer
\end_layout

\begin_layout Standard
Hier ein Beispiel wie man Programmcode richtig darstellen könnte:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C},numbers=left,basicstyle={\footnotesize\sffamily},breaklines=true,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

main() 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        int i;
\end_layout

\begin_layout Plain Layout

        for (i = 0; i<=2; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

	        fork();
\end_layout

\begin_layout Plain Layout

	        setvbuf(stdout, NULL, _IOLBF, 0); //(Stream, Pufferangabe, Puffertyp,
 Puffergroesse)
\end_layout

\begin_layout Plain Layout

	        printf("PID=%6d, i=%d
\backslash
n", getpid(), i);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modifiziertes Programm mit setvbuf()
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unter 
\begin_inset Quotes gld
\end_inset

Dokument --> Einstellungen --> Latexvorspann
\begin_inset Quotes grd
\end_inset

 habe ich für die Hintergrundfarbe folgendes eingefügt:
\end_layout

\begin_layout Itemize

\backslash
definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\end_layout

\begin_layout Standard
Dies legt die Hintergrundfarbe fest.
 Sie kann natürlich nach belieben angepasst werden.
 Wenn ihr Rechtsklick auf das Programmlisting macht und dann unter 
\begin_inset Quotes gld
\end_inset

Einstellungen --> Erweitert
\begin_inset Quotes grd
\end_inset

 geht, seht ihr einige Anpassungen die ich gemacht habe.
 Unter Anderem wird hier auch 15pt von links eingerückt, damit die Zeilennummern
 schön zum Fließtext passen.
 
\end_layout

\begin_layout Chapter
Entwicklung einer Beispielanwendung mit StrangeIoC mit dem Ziel lose Kopplung
 unter Objekten umzusetzen 
\end_layout

\begin_layout Section
StrangeIoC und verwendete Entwurfsmuster
\end_layout

\begin_layout Standard
Ich versuche immer nach DIN zu zitieren, ist aber echt eine Sache für sich.
 Hier gebe ich keine Garantie auf Richtigkeit.
 Bitte vorher mit dem Betreuer abklären.
\end_layout

\begin_layout Standard
Hier zitiere ich aus einem bestimmten Buch: Dieses Zitat ist aus einem spezielle
n Buch das ich am Ende angeben muss.
 Es sind sogar zwei Bücher, nur damit ihr das mal seht.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Williams201205,Siegert200612"

\end_inset


\end_layout

\begin_layout Standard
Es ist meist nicht gern gesehen wenn man aus dem Internet zitiert, aber
 wenn es doch mal nötig ist würde ich es so machen.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:42"

\end_inset

 Übrigens könnt ihr bei Wikipedia direkt an die Bibtex-Informationen kommen.
 Einfach Links im Menü unter 
\begin_inset Quotes gld
\end_inset

Werkzeuge --> Seite zitieren
\begin_inset Quotes grd
\end_inset


\end_layout

\begin_layout Standard
Gesetztestexte müssen zum Beispiel nicht zitiert werden.
 Hier reicht ein Verweis in der Fußnote
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Das hier ist die supertolle Fußnote, hier steht jetzt irgendwas von BGB
 §12 Abs.
 3 Satz 4
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Zum Bearbeiten der Literatur-Datenbank verwende ich JabRef.
\end_layout

\begin_layout Section
Walk-Through Beispielanwendung
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
todo{Elobarate example!}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Kritische Betrachtung & Fazit
\end_layout

\begin_layout Standard
Dieses Dokument ist sicherlich nicht vollständig und gibt euch auch nur
 bedingt Hilfe dabei, welche Unterpunkte ihr in eurer Bachelorarbeit schreiben
 solltet.
 Das Dokument soll euch nur ein paar Tipps und Tricks geben wie ihr Anfangen
 könnt.
 Fragen und Anregungen könnt ihr mir gerne per Mail oder in meinem Blog
 schreiben.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ab hier folgt nun der Glossar.
 Manchmal ist das nicht nötig, dann muss es auch unter Dokumente --> Einstellung
en --> Latex-Vorspann deaktivieren.
 Übrigens werden Lyx-Notizen im späteren Dokument nicht angezeigt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout

% Die folgende Zeile sorgt dafuer, dass der Glossar im Inhaltsverzeichnis
 angezeigt wird.
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Glossar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Single Responsibility Principle"
description "Eine Klasse soll nur eine Verantowrtlichkeit haben."

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Open Closed Principle"
description "Eine Klasse soll offen für Erweiterung, jedoch geschlossen für Modifikation sein."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Liskov Subsitituion Principle"
description "Abgeleite Klassen sollen sich so verhalten wie der Basistyp es von ihnen erwartet."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Interface Segregation Principle"
description "Interfaces sollen nur die Funktionalität wiederspiegeln die ihre Klienten erwarten."

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Dependency Inversion Principle"
description "High-Level Klassen sollen nicht von Low-Level Klassen abhängig sein, sondern beide von Interfaces. Interfaces sollen nicht von Details abhängig sein sondern Details von Interfaces"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "auto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Dieser Code ist noetig, da sonst die falsche Seitenzahl im Inhaltsverzeichnis
 angezeigt wird
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier folgt nun das Literaturverzeichnis.
 Die benötigten Dateien liegen im Verzeichnis: bibtex-daten
\end_layout

\begin_layout Plain Layout
Dieses wird automatisch erstellt.
 Zum bearbeiten der 
\begin_inset Quotes gld
\end_inset

Literatur-Datenbank
\begin_inset Quotes grd
\end_inset

 verwende ich das Programm 
\begin_inset Quotes gld
\end_inset

JabRef
\begin_inset Quotes grd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex-daten/bachelorarbeit-info"
options "bibtotoc,bibtex-daten/unsrtdin"

\end_inset


\end_layout

\end_body
\end_document
